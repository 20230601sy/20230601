package 논리연산;

public class Sample02 {
	public static void main(String[] args) {
		int a = 10;
		/* 
		 * 시프트연산
		 * 10을 2진수 변환하면 1010, 1010(2) : 10
		 * int는 32bit, 0000...001010 (32자리)
		 * 오른쪽으로 시프트하면 끝에 벗어난 10은 사라지고 앞에 빈 두 칸은 0이 채워짐 // 그냥 2^2으로 나눈 거
		 * 왼쪽으로 시프트하면 끝에 생긴 칸에 0이 채워지고 벗어난 두 칸은 사라짐 // 그냥 2^2으로 곱한 거 근데 음수하면 달라지긴 하겠다.
		 * // Java에만 있는 시프트연산이 하나 더 있긴 한데 그거까지 하면 복잡하니까 넘어간다심ㅠ // 라운드시프트인가?? 뭐 그런 거 있었던 거 같기도
		 */
		System.out.println(a>>2);
		System.out.println(a<<2); 
		
		/* 
		 * 비트연산: 예전에 컴퓨터 사양이 안 좋을 때 10진수 처리를 못할 때, 비트연산으로 했던 시절이... 속도 향상 등이 되긴 함.
		 * & : 비트단위 and
		 * | : 비트단위 or
		 * true : 1
		 * false : 0
		 * 같은 자리 상에 있는 비트끼리 연산을 시킴
		 * ^ : 비트단위 XOR, 배타적 논리합 → 서로 다를 때만 1
		 * ~ : 비트 반전 → 1은 0, 0은 1로 뒤집힘, 제일 첫 비트가 부호를 나타내는데, 음수를 표현할 때 보수 개념이 필요함.
		 * 보수의 종류: 1의 보수, 2의 보수
		 * 1의 보수: 0 → 1, 1 → 0
		 * 2의 보수: 1의 보수 + 1, 부호 비트는 안 바뀜
		 */
		int num1=10, num2=8;
		System.out.println(num1 & num2);
		System.out.println(num1 | num2);
		System.out.println(~num1);
	}
}
