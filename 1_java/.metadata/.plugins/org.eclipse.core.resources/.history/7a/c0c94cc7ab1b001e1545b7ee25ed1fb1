// ====================================================================================================
Day0601
// ====================================================================================================
0. 개인폴더 만들기 - D:\Java DO NOT USE 한글

1. jdk 설치
 jdk 11 검색
 oracle 회원 가입 r@g A
 이메일 인증
 installer download
 next 기본 설치
 (경로 C:\Program Files\Java\jdk-11)

2. 환경변수 설정
 win 작업표시줄 환경 변수 검색
 시스템 환경 변수 편집
 시스템 변수
 새로 만들기 / JAVA_HOME / C:\Program Files\Java\jdk-11\ (뒤에 '\' 추가)

 시스템 변수 path 편집
 새로 만들기 %JAVA_HOME%\bin

 cmd 에서 java -version && javac -version

3. 이클립스 설치
 이클립스 2022-06 구글링
 Eclipse IDE for Enterprise Java and Web Developers / Windows x86_64 다운로드
 압축 풀기
 바로가기 만들기
 실행

*이클립스 IDE vs 인텔리제이 - 전반적으로 유사 단축키는 다름
 인텔리제이는 유료, 무료 / 웹개발까지 하려면 유료 버전 필요
*jdk : 이것좀해주세요 -> 컴퓨터 언어로 변환, 실행
 jdk - tool 도구모음
 jre - java를 실행하는 환경 제공
 jvm - java 가상 머신 실제 실행을 위한 소프트웨어

*컴파일러 vs 인터프리터

*오라클 jdk vs open jdk
 오라클 jdk는 8버전까지는 무료, 그 이후는 유료, 버전은 8(legacy), 11, 17(최신), 빈도는 11 or 8
 open jdk는 무료

 개발환경 setting 매번 검색 헤헷.

*수강 목적
 취업? 11월 비수기 / 3월 성수기 ...

*개발자(프로그래머) FrontEnd, 앞단 + BackEnd, 눈에 안 보이는 것들
 요즘은 경계가 모호, 프론트가 백까지 할 수 있게 하는 인프라가...

*컴활 Visual Basic 옛날 사람 하하하ㅋㅋㅋ

4. 이클립스 실행
개인폴더\java
window - preference - Java - Compiler 11 apply
JRE - JavaSE-11 - jre - apply and close
window - preference - General - workspace - utf-8

국민취업제도 상담 다녀옴
출력까지 진도 나갔다심
============================================================

data type
int num; ( long, short )
double num; ( float )
char c; ( 'A', '김' )
string str; ("asdf", "a")
boolean b ( true, false )

대입연산자 a = 1; 1을 a에 넣어라


자료형 변환

중간에 토하느라 날라감, 에어컨 아 죽을 거 같다 진짜 내일은 꼭 옷 챙겨올 것!!!

자동 import : ctrl + shift + o
자동 완성 : ctrl + space

import java.util.Scanner;

		Scanner sc = new Scanner(System.in);
		
		System.out.print("정수 입력: ");
		int x = sc.nextInt();
		System.out.println("입력한 값: " + x);
		
		System.out.print("실수 입력: ");
		double y = sc.nextDouble();
		System.out.println("입력한 값: " + y);
		
		System.out.print("문자 입력: ");
		char c = sc.next().charAt(0); // 0 = 문자열의 index
		System.out.println("입력한 값: " + c);

		System.out.print("문자열 입력: ");
		String str = sc.next(); // sc.next() 하면 space 포함하면 첫 공백 앞 단어만, String str = sc.nextLine(); 을 더 많이 씀 // 그런데 연속으로 실행하게 되면 char c 입력 때 눌린 enter 때문에 그냥 넘어가게 되버림
		System.out.println("입력한 값: " + str);
// ====================================================================================================
Day0602
// ====================================================================================================
/*
 * 0601 복습
 * 대부분의 명령문에는 ; 로 완료, 필요 없는 거는 그때그때 말해주겠음.
 * 출력문: System.out.print("출력할 내용"), println, printf
 * 변수: 값을 저장하는 공간
 * 변수 선언 방법: 데이터타입 변수이름;
 * 데이터타입 종류: 정수 int, short, long / 실수 double, float / 문자 char / 문자열 String (S는 대문자, 정확하게는 데이터타입이 아님) / bool 타입 boolean
 * 변수 이름: 이름만 봐도 대충 뭔지 알 수 있도록 설정 / eg. num1, num2, sum
 * 변수 이름 가이드: 축약 average → avg / 임시 temp, t, tmp / 순서 i, j, k / 특수기호 _ $, 임시저장의 경우 _num1 or num1_ 를 쓰기도 함, $는 거의 안 씀
 * 대입연산자: a=1; 등호 오른쪽에 있는 걸 왼쪽에 넣어라
 * 입력문: import java.util.Scanner; Scanner sc = new Scanner(System.in); int num = sc.nextInt();
 * 데이터타입에 맞게 입력문 명령이 달라짐: nextInt(), nextDouble(), next.charAt(0), nextLine()
 * 자동import 단축키: ctrl + shift + o
 * 자동완성 단축키: ctrl + space
 * 		System.out.print("문자 입력: ");
		char c = sc.next().charAt(0); // 0 = 문자열의 index
		sc.nextLine(); // ← Enter를 한 번 소비시키는 방법도 있음
		System.out.println("입력한 값: " + c);

		System.out.print("문자열 입력: ");
		String str = sc.nextLine(); // sc.next() 하면 space 포함하면 첫 공백 앞 단어만, String str = sc.nextLine(); 을 더 많이 씀 
		System.out.print("입력한 값: " + str);
 */
// ==================================================================================================== 
package 복습;
import java.util.Scanner;
public class Test01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("이름을 입력하세요 : ");
		String name = sc.next();
		System.out.print("나이를 입력하세요 : ");
		int age = sc.nextInt();
		System.out.print("성별을 입력하세요 : ");
		char gender = sc.next().charAt(0);
		System.out.print("전화번호를 입력하세요 : ");
		String phone = sc.next();
		System.out.println("====회원정보====");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		System.out.println("성별 : " + gender);
		System.out.println("전화번호 : " + phone);	
	}
}
// ====================================================================================================
package 복습;
import java.util.Scanner;
public class Test02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);		
		System.out.print("국어 점수를 입력 : ");
		int sum = sc.nextInt(); 
		System.out.print("영어 점수를 입력 : ");
		sum += sc.nextInt();
		System.out.print("수학 점수를 입력 : ");
		sum += sc.nextInt();
		System.out.println("점수 총합 : " + sum);
		System.out.printf("점수 평균 : %.1f\n", sum/3.0);
	}
}
// ====================================================================================================
package 복습;
import java.util.Scanner;
public class Test03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("금액 : ");
		int money = sc.nextInt();
		System.out.println("<결과>");		
		System.out.println("5만원권 : "	+ money/50000 + "장");
		System.out.println("만원권 : "	+ (money%50000)/10000 + "장");
		System.out.println("오천원권 : "	+ (money%10000)/5000 + "장");
		System.out.println("천원권 : "	+ (money%5000)/1000 + "장");
	}
}
// ====================================================================================================
package 복습;
import java.util.Scanner;
public class Test04 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("두 자연수를 입력 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		System.out.println(num1*(num2%10));
		System.out.println(num1*((num2/10)%10));
		System.out.println(num1*(num2/100));
		System.out.println(num1*num2);
	}
}
// ====================================================================================================
/*
 * 연산자 책 진도 나감
 */
package 증감연산자;
public class Sample01 {
	public static void main(String[] args) {
		int num = 5;
		// num이 1 증가된 값을 출력
		System.out.println(num + 1);
		
		// num을 1 증가시킬 때
		num = num + 1;
		num += 1; // step variable
		++num; --num; // step 1로 고정, 전위연산자
		num++; num--; // step 1로 고정, 후위연산자
		// 출력문 내부에 전위, 후위 연산자를 쓰지는 않기 때문에 보통은 num++; num--;이런식으로 쓴다.
		
		// num을 1 증가시켜 값을 출력
		System.out.println(++num);
		// 출력은 먼저 시키고 num을 1 증가시키기
		System.out.println(num++);
	}
}
// ====================================================================================================
package 형변환;
public class Sample01 {
	public static void main(String[] args) {
		int a = 97;
		System.out.println((char)a); // 아스키 코드표(ASCII Table) 'a' == 97, 'A' == 65
	}
}
// ====================================================================================================
package 형변환;
public class Sample02 {
	public static void main(String[] args) {
		double pi = 3.141592;
		double shortPi = Math.round(pi); // round는 소수 첫째자리(고정)에서 반올림됨 → 정수(long) 반환
		System.out.println(shortPi);
		shortPi = Math.round(pi * 1000) / 1000.0;
		System.out.println(shortPi);
	}
}
// ====================================================================================================
package 논리연산;
public class Sample01 {
	public static void main(String[] args) {
		int a=8, b=20;
		// 조건식을 한 번에 묶거나 부등식을 한 번에 쓸 수 없으니 모두 따로 따로 표기해야 함
		// 각각의 조건식을 먼저 계산함 → 괄호 필요 없음
		// 조건식 || 조건식 : or 연산
		// 논리 부정 !
		// !a>=10 이면 !a가 먼저 연산되어 에러 발생 → 괄호 필요,!(a>=10) 
		System.out.println( a>=5 && b>=15 );
		System.out.println( a>=5 && b<=15 );
		System.out.println( a>=5 || b<=15 );
		System.out.println( !(a>=5) );
	}
}
// ====================================================================================================
시프트 연산
>>
<<
2진수: 0과 1로 이루어진, 컴퓨터가 이해하는(?) 수
// ====================================================================================================
package 논리연산;
public class Sample02 {
	public static void main(String[] args) {
		int a = 10;
		/* 
		 * 시프트연산
		 * 10을 2진수 변환하면 1010, 1010(2) : 10
		 * int는 32bit, 0000...001010 (32자리)
		 * 오른쪽으로 시프트하면 끝에 벗어난 10은 사라지고 앞에 빈 두 칸은 0이 채워짐 // 그냥 2^2으로 나눈 거
		 * 왼쪽으로 시프트하면 끝에 생긴 칸에 0이 채워지고 벗어난 두 칸은 사라짐 // 그냥 2^2으로 곱한 거 근데 음수하면 달라지긴 하겠다.
		 * // Java에만 있는 시프트연산이 하나 더 있긴 한데 그거까지 하면 복잡하니까 넘어간다심ㅠ // 라운드시프트인가?? 뭐 그런 거 있었던 거 같기도
		 */
		System.out.println(a>>2);
		System.out.println(a<<2); 
		
		/* 
		 * 비트연산: 예전에 컴퓨터 사양이 안 좋을 때 10진수 처리를 못할 때, 비트연산으로 했던 시절이... 속도 향상 등이 되긴 함.
		 * & : 비트단위 and
		 * | : 비트단위 or
		 * true : 1
		 * false : 0
		 * 같은 자리 상에 있는 비트끼리 연산을 시킴
		 * ^ : 비트단위 XOR, 배타적 논리합 → 서로 다를 때만 1
		 * ~ : 비트 반전 → 1은 0, 0은 1로 뒤집힘, 제일 첫 비트가 부호를 나타내는데, 음수를 표현할 때 보수 개념이 필요함.
		 * 보수의 종류: 1의 보수, 2의 보수
		 * 1의 보수: 0 → 1, 1 → 0
		 * 2의 보수: 1의 보수 + 1, 부호 비트는 안 바뀜
		 */
		int num1=10, num2=8;
		System.out.println(num1 & num2);
		System.out.println(num1 | num2);
		System.out.println(~num1);
	}
}
// ====================================================================================================
조건 연산자: 삼항 연산자라는 용어를 더 많이 씀
단항: 값이 1개 있으면 계산되는 연산자 eg. !a, ~a, -a
이항: 값이 2개 있으면 계산되는 연산자 eg. a+b, a*b 
삼항 연산자: 조건식 결과에 따라 출력값을 설정
조건식 ? 조건식이 참인 경우 처리할 값 : 조건식이 거짓일 경우 처리할 값
실제로는 삼항 연산자보다는 if문을 더 많이 씀
// ====================================================================================================
package 논리연산;
public class Sample03 {
	public static void main(String[] args) {
		int a = 80, b = 50;
		int result = a>b ? a-b : b-a;
		System.out.println(result);
	}
}
// ====================================================================================================
if문: 조건식을 계산한 결과에 따라 출력
조건식이 참이면 참인 경우 코드가 작동
조건식이 거짓이면 거짓인 경우 코드가 작동

기본틀:
if(조건식){
    조건식이 참인 경우 실행할 코드
} else{
    조건식이 거짓인 경우 실행할 코드
}

* if문은 ; 으로 안 끝남!
* 실행할 코드가 한줄이면 중괄호 생략 가능!
* else 자체는 작업의 조건에 따라 필요 없을 수도 있는데, 필요 없는 경우 생략 가능!
// ====================================================================================================
// 점수를 입력받아 입력한 점수가 80점 이상이면 합격, 아니면 불합격 출력
package N05_if문;
import java.util.Scanner;
public class Sample01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("점수를 입력해주세요 : ");
		int score = sc.nextInt();
		if(score>=80)
			System.out.println("합격");
		else
			System.out.println("불합격");
	}
}
// ====================================================================================================
변수 가용 범위
 지역변수: 변수 선언한 해당 중괄호 안에서만 사용 가능함
 전역변수
// ====================================================================================================
if(조건식1) {
    조건식1이 참인 경우 실행할 코드
} else if(조건식2) {
    조건식2이 참인 경우 실행할 코드
} else if(조건식3) {
    조건식3이 참인 경우 실행할 코드
} else {
    모두 거짓인 경우 실행할 코드
}
// ====================================================================================================
// 점수를 입력받아 입력한 점수가 80점 이상이면 "상", 60점 이상이면 "중" 나머지는 "하" 출력
package N05_if문;
import java.util.Scanner;
public class Sample02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("점수를 입력해주세요 : ");
		int score = sc.nextInt();
		if(score>=80)
			System.out.println("상");
		else if(score>=60)
			System.out.println("중");
		else
			System.out.println("하");
	}
}
// ====================================================================================================
// 교재 105p 예제
package N05_if문;
import java.util.Scanner;
public class Sample03 {
	public static void main(String[] args) {
		char grade = ' ';
		char opt = '0';
		Scanner sc = new Scanner(System.in);
		System.out.print("점수를 입력하세요 : ");
		int score = sc.nextInt();
		System.out.println("당신의 점수는 " + score + "점 입니다.");
		if(score>=90) {
			grade = 'A';
			if (score>=98)
				opt = '+';
			else if (score<94)
				opt = '-';
		} else if(score>=80) {
			grade = 'B';
			if (score>=88)
				opt = '+';
			else if (score<84)
				opt = '-';
		} else {
			grade = 'C';
		}
		System.out.println("당신의 학점은 " + grade + opt + "입니다.");
	}
}
// ====================================================================================================
Day0605
// ====================================================================================================
0602 복습부터
// ====================================================================================================
// 두 개의 점수를 입력받아 두 점수의 합이 150 이상이면 "합격" 아니면 "불합격"으로 출력하는 프로그램을 완성
package N01_복습;
import java.util.Scanner;
public class Test01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("두 개의 점수를 입력하세요 : ");
		int score1 = sc.nextInt();
		int score2 = sc.nextInt();
		if (score1+score2 >= 150)
			System.out.println("합격");
		else
			System.out.println("불합격");
	}
}
// ====================================================================================================
// 두 개의 점수를 입력받아 두 점수의 합이 150 이상이고, 평균이 80 이상이면 "합격" 아니면 "불합격"으로 출력하는 프로그램을 완성
package N01_복습;
import java.util.Scanner;
public class Test01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("두 개의 점수를 입력하세요 : ");
		int score1 = sc.nextInt();
		int score2 = sc.nextInt();
		int sum = score1+score2;
		System.out.print("<결과>\n합계 : " + sum + " 평균 : " + sum/2);
		if (sum >= 160) // sum >= 150 && sum/2 >= 80  
			System.out.println(" 합격");
		else
			System.out.println(" 불합격");
	}
}
// ====================================================================================================
리팩토링 → 목적: 코드 최적화, 클린코드 코드를 깔끔하게 정리, 결과 값이 달라지진 않지만 코드가 수정되는 것
중복된 코드를 최소화하는 것을 지향함
현업에서도 코드를 완성한 후 리팩토링하는 시간을 따로 가지기도 함
줄인다는 게 코드 라인 수를 줄인다는 것이 아님, 늘어날 수도 있음, 연산수가 주는 것임
// ====================================================================================================
// 정수 하나를 입력받아 입력받은 정수가 홀수면 "홀수입니다" 짝수면 짝수입니다"라고 출력하는 프로그램을 완성하시오
package N01_복습;
import java.util.Scanner;
public class Test02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력하세요 : ");
		int num = sc.nextInt();
		if (num%2 == 1)
			System.out.print("홀수입니다");
		else
			System.out.print("짝수입니다");
	}
}
// ====================================================================================================
// 세 정수를 입력받아 최대값과 최소값을 출력하는 프로그램을 완성하시오
package N01_복습;
import java.util.Scanner;
public class Test03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("세 정수를 입력하세요 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		int num3 = sc.nextInt();
		int max, min;
		
		max = num1;
		min = num1;
		if (max < num2)
			max = num2;
		if (max < num3)
			max = num3;
		if (min > num2)
			min = num2;
		if (min > num3)
			min = num3;

		System.out.println("최대값 : " + max + "최소값 : " + min);
	}
}
// ====================================================================================================
// method 1
if (num1 >= num2) {
	if (num2 >= num3)
		System.out.print("최대값 : " + num1 + "최소값 : " + num3);
	else if (num1 >= num3)
		System.out.print("최대값 : " + num1 + "최소값 : " + num2);
	else
		System.out.print("최대값 : " + num3 + "최소값 : " + num2);
} else { // num1 < num2
	if (num3 <= num1)
		System.out.print("최대값 : " + num2 + "최소값 : " + num3);
	else if (num3 <= num2)
		System.out.print("최대값 : " + num2 + "최소값 : " + num1);
	else
		System.out.print("최대값 : " + num3 + "최소값 : " + num1);
}
// ====================================================================================================
// method2
if (num1 > num2 && num1 > num3)
	System.out.println("최대값 : " + num1);
else if (num2 > num1 && num2 > num3)
	System.out.println("최대값 : " + num2);
else
	System.out.println("최대값 : " + num3);

if (num1 < num2 && num1 < num3)
	System.out.println("최소값 : " + num1);
else if (num2 < num1 && num2 < num3)
	System.out.println("최소값 : " + num2);
else
	System.out.println("최소값 : " + num3);
// ====================================================================================================
/* 주문수량을 입력받아 주문금액과 배달비를 출력하는 프로그램을 완성
 * - 물건 하나의 가격은 12,000원
 * - 배달비는 주문금액이 15,000원 이하면 3,000원
 *                   30,000원 이하면 1,500원
 *                   나며지는 무료
 */
package N01_복습;
import java.util.Scanner;
public class Test04 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("주문수량을 입력하세요 : ");
		int ea = sc.nextInt();
		int price = 12000 * ea;
		System.out.print("주문금액 : " + price + "원, 배달비 : ");
		if (price < 15000)
			System.out.println("3000원");
		else if (price < 30000)
			System.out.println("1500원");
		else
			System.out.println("무료");
	}
}
// ====================================================================================================
/* 국어, 영어, 수학 점수를 입력받아
 * 3과목의 평균이 70이상이면 "합격", 아니면 "불합격"으로 출력
 * 단, 평균이 70이상이지만
 * 3과목 중 하나라도 60미만이면 "과락"으로 출력할 것
 */
package N01_복습;
import java.util.Scanner;
public class Test05 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("국어, 영어, 수학 점수를 입력하세요 : ");
		int kor = sc.nextInt();
		int eng = sc.nextInt();
		int math = sc.nextInt();
		
		if ((kor + eng + math)/3.0 > 70) {
			if (kor < 60 || eng < 60 || math < 60)
				System.out.println("과락");
			else
				System.out.println("합격");
		}
		else
			System.out.println("불합격");
	}
}
// ====================================================================================================
/* 
 * 년도를 입력받아 해당 년도가 윤년인지 아닌지 출력하는 프로그램을 완성하시오
 * 윤년 : 년도가 4의 배수이면서, 100의 배수가 아닌 경우 또는 400의 배수인 경우이다
 */
package N01_복습;
import java.util.Scanner;
public class Test06 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("년도를 입력하세요 : ");
		int year = sc.nextInt();
		if ((year%4==0 && year%100!=0) || year%400==0)
			System.out.print("윤년입니다");
		else
			System.out.print("윤년이 아닙니다");
	}
}
// ====================================================================================================
/*
 * 45분 일찍 알람 설정하기
 * 두 H와 M이 주어진다, 0≤H≤23, 0≤M≤59, H시 M분
 * 시간을 나타낼 때, 불필요한 0은 사용하지 않는다
 */
package N01_복습;
import java.util.Scanner;
public class Test07 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("==45분 일찍 알람 설정하기==");
		System.out.print("알람 설정 시간 입력 : ");
		int H = sc.nextInt();
		System.out.print("알람 설정 분 입력 : ");
		int M = sc.nextInt();
		M -= 45;
		if (M<0) {
			M += 60;
			H--;
			if (H<0)
				H = 23;
		}
		System.out.println("설정된 알람 시간은 " + H + "시 " + M + "분 입니다.");
	}
}
// ====================================================================================================
/*
 * 주사위 눈 3개
 * 같은 눈 3개이면 상금 10,000원 + (같은 눈)x1,000원
 * 같은 눈 2개이면 상금 1,000원 + (같은 눈)x100원
 * 모두 다른 눈이 나오면 가장 (큰 눈)x100원
 */
package N01_복습;
import java.util.Scanner;
public class Test08 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("세 주사위 눈을 입력하세요 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		int num3 = sc.nextInt();
		int reward;
		if (num1 == num2 && num1 == num3) 
			reward = 10000 + num1*1000;
		else if ((num1 == num2) || (num1 == num3))
			reward = 1000 + num1*100;
		else if (num2 == num3)
			reward = 1000 + num2*100;
		else {
			if(num1 > num2 && num1 > num3)
				reward = num1*100;
			else if(num2 > num1 && num2 > num3)
				reward = num2*100;
			else
				reward = num3*100;
		}
		System.out.print("상금은 " + reward + "원입니다.");
	}
}
// ====================================================================================================
/*
 * 알파벳 한글자를 입력받아 입력한 글자가	소문자면 "소문자를 입력하셨습니다."으로 출력하고,
 * 									대문자면 "대문자를 입력하셨습니다."으로 출력,
 * 									둘다 아닌 경우에는 "알파벳이 아닙니다."라고 출력하시오.
 */
package N01_복습;
import java.util.Scanner;
public class Test09 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("알파벳 한글자를 입력하세요 : ");
		char t = sc.next().charAt(0);
		if (t>='a' && t<='z')
			System.out.print("소문자를 입력하셨습니다.");
		else if (t>='A' && t<='Z')
			System.out.print("대문자를 입력하셨습니다.");
		else
			System.out.print("알파벳이 아닙니다.");
	}
}
// ====================================================================================================
0605 15:48 책 진도
조건문 - switch ~ case 문 106p.
조건식 ? 이라고 하기보다는 계산식 혹은 변수, 그냥 값이 들어감, if의 조건식처럼 참, 거짓이 아님
switch(계산식 또는 변수){
	case 값1:
		해당 계산식이랑 값1이 같은 경우 처리할 코드
		break;
	case 값2:
		해당 계산식이랑 값2이 같은 경우 처리할 코드
		break;
	default :
		나머지일 경우 처리할 코드
}
*여기도 ; 안 씀!
*case는 {} 블록 처리 안 함!
*default는 생략가능!
*default에는 break 생략가능!
*break를 만나는 시점에 중괄호 밖으로 빠지게 됨
// switch문은 그렇게 많이 쓰지는 않음
// ====================================================================================================
// 문자를 입력받아 A이면 "최우수", B이면 "우수", C이면 "장려", 나머지는 "잘못 입력하셨습니다." 출력
package N02_switch연습;
import java.util.Scanner;
public class Sample01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("문자를 입력하세요 : ");
		char ch = sc.next().charAt(0);
		switch(ch) {
			case 'A':
				System.out.println("최우수");
				break;
			case 'B':
				System.out.println("우수");
				break;
			case 'C':
				System.out.println("장려");
				break;
			default:
				System.out.println("잘못 입력하셨습니다.");
		}
	}
}
// ====================================================================================================
// 교재 예저 108p
package N02_switch연습;
import java.util.Scanner;
public class Sample03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("월을 입력하세요 : ");
		int month = sc.nextInt();
		switch (month) {
			case 3:
			case 4:
			case 5:
				System.out.println("봄입니다");
				break;
			case 6:
			case 7:
			case 8:
				System.out.println("여름입니다");
				break;
			case 9:
			case 10:
			case 11:
				System.out.println("가을입니다");
				break;
			case 12:
			case 1:
			case 2:
				System.out.println("겨울입니다");
				break;
			default:
				System.out.println("잘못 입력하셨습니다");
		}
	}
}
// ====================================================================================================
/*
 * 정수를 입력받아 입력한 정수가 5의 배수인지 아닌지 출력하는 프로그램을 완성
 */
package N02_switch연습;
import java.util.Scanner;
public class Test01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력하세요 : ");
		int num = sc.nextInt();
		switch (num%5) {
			case 0:
				System.out.println("5의 배수입니다");
				break;
			default:
				System.out.println("5의 배수가 아닙니다");
		}
	}
}
// ====================================================================================================
/*
 * 성별을 입력받아 'm', 'M'은 남자, 'f' 'F'는 여자, 나머지는 잘못 입력하셨습니다 출력
 */
package N02_switch연습;
import java.util.Scanner;
public class Test02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("성별을 입력하세요 : ");
		char gender = sc.next().charAt(0);
		switch(gender) {
			case 'm':
			case 'M':
				System.out.println("남자");
				break;
			case 'f':
			case 'F':
				System.out.println("여자");
				break;
			default:
				System.out.println("잘못 입력하셨습니다");
		}
	}
}
// ====================================================================================================
/*
 * 두 정수와 연산 기호를 입력받아 결과값을 출력하는 프로그램을 완성
 * 단, 나누기한 결과는 반올림해서 소수 둘째자리까지 표시
 * 연산기호는 +, -, *, /, %
 */
package N02_switch연습;
import java.util.Scanner;
public class Test03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		System.out.print("연산방법 : ");
		char op = sc.next().charAt(0);
		System.out.print(num1 + " " + op + " " + num2 + " = ");
		switch(op){
			case '+':
				System.out.println(num1+num2);
				break;
			case '-':
				System.out.println(num1-num2);
				break;
			case '*':
				System.out.println(num1*num2);
				break;
			case '/':
//				System.out.printf("%.2f\n",(double)num1/num2);
				System.out.println(Math.round(100*(double)num1/num2)/100.0);
				break;
			case '%':
				System.out.println(num1%num2);
				break;
			default :
				System.out.println("잘못 입력하셨습니다");
		}
	}
}
// ====================================================================================================
지금 연습하는 내용들은 다른 python이나 javascript에서도 비슷비슷하게 쓸 수 있음
더 하기 싫은지?? ㄷㄷ
금주 QnA or 남아서 공부 가능 → 헤헷.
// ====================================================================================================
Day0607
// ====================================================================================================
오늘은 진도부터 나갈 거임. 복습들은 다 했는지?? ㄷㄷ
// ====================================================================================================
/*
 * 교재 109p
 * Math.random() → 랜덤
 * 0~0.999999999999 (1전까지)
 * 따지자면, Math는 class, random()은 method, M이 대문자
 * 할 때마다 다른 값을 가짐, 모두 다른 값 출력
 * round와 동일하게 추가 해야 할 것이 있음 ∵ 보통은 1~10 중에서 정수 하나를 고르라는 식이므로...
 * 로또 번호 생성기 같은 거 할 때 쓸 거임???
 * eg. 1~X → 1+X*Math, 0~Y → Y*Math...???
 */
package N01_난수;
public class Sample01 {
	public static void main(String[] args) {
		System.out.println(((int)(Math.random()*10)+1));
	}
}
// ====================================================================================================
110p 반복문 for문 (for문이 가장 많이 쓰임)
for(시작값;조건식;증감식){
	반복실행코드
}
// ====================================================================================================
package N02_for문;
public class Sample01 {
	public static void main(String[] args) {
		for(int i=0; i<5; i++) {
			System.out.println("hello");
		}
		/*
		 * i 조건식 	i<5 실행코드
		 * 0 T		1번 실행
		 * 1 T		2번 실행
		 * ...
		 * 5 F		반복탈출
		 */
		
		for(int i=0; i<5; i++) { // i를 꼭 여기서 새로 선언해야 하는 것은 아님, i의 가용 범위가 달라짐
			System.out.println(i);
		}
		// System.out.println(i); 반복문에서 i를 선언하면, for문 바깥에서 i 사용은 error 발생
		
		int i;
		for(i=0; i<5; i++) { // i를 반복문 밖에서 사용하려면 먼저 선언해야 함
			System.out.println(i);
		}
		System.out.println("반복문 탈출 후 i : " + i);
		
		// 증감식도 내마음대로 써도 됨 i++ 대신 i=i+1 이나 i+=1 를 써도 동일함
		// 대부분은 1씩 증감이긴한데, 아닌 경우도 있으니 비슷하게 사용하면 됨
		for(i=0; i<10; i+=3) {
			System.out.println(i);
		}
		System.out.println("반복문 탈출 후 i : " + i);
		
		// 반복할 코드가 1줄이면 {} 생략 가능
		for(int j=0; j<5; j++)
			System.out.println(j);
	}
}
// ====================================================================================================
// 1~100까지 합계
package N02_for문;
public class Sample02 {
	public static void main(String[] args) {
		int sum = 0;
		for(int i=1; i<=100; i++) {
//			System.out.println(i);
			sum += i;
		}
		System.out.println("합계 : " + sum);
	}
}
// ====================================================================================================
// 1~100까지 짝수들의 합계
package N02_for문;
public class Test01 {
	public static void main(String[] args) {
		int sum = 0;
		for(int i=1; i<=100; i++) {
			if(i%2 == 0)
				sum += i;
		}
		System.out.println("짝수합 : " + sum);
	}
}
// ====================================================================================================
// 1~100까지 짝수들의 합계, 홀수들의 합계
package N02_for문;
public class Test02 {
	public static void main(String[] args) {
		int evenSum = 0;
		int oddSum = 0;
		for(int i=1; i<=100; i++) {
			if(i%2 == 0)
				evenSum += i;
			else
				oddSum += i;
		}
		System.out.println("짝수합 : " + evenSum);
		System.out.println("홀수합 : " + oddSum);
	}
}
// ====================================================================================================
// 정수를 입력받아 1부터 입력받은 정수까지의 합계를 출력
package N02_for문;
import java.util.Scanner;
public class Test03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력하세요 : ");
		int num = sc.nextInt();
		int sum = 0;
		for(int i=1; i<=num; i++) {
			sum += i;
		}
		System.out.println("합계 : " + sum);
	}
}
// ====================================================================================================
들여쓰기 단축키 : ctrl + shift + f
그런데 괄호가 빠진 부분이나 실수가 있었다고 자동 보정해주지는 않고, 본인이 지정해놓은 구간도 있기 때문에, 애초에 걍 잘 들여쓰기 할 것. 
실행 단축키 : ctrl + f11
영역 옮기기 단축키 : 영역 지정 후 alt + 상하화살표
출력문 단축키 : syso까지 입력 후 + (ctrl + space)
// ====================================================================================================
// 두 정수를 입력받아 두 정수 사이의 합계를 구하는 프로그램을 완성하시오
package N02_for문;
import java.util.Scanner;
public class Test04 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("두 정수를 입력하세요 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		int sum=0;
		if(num1 > num2) {
			int tmp = num1;
			num1 = num2;
			num2 = tmp;
		}
		for(; num1<=num2; num1++)
			sum += num1;
		System.out.println("합계 : " + sum);
	}
}
// ====================================================================================================
/*
 *  1부터 100까지 숫자 중 3의 배수이면서 2의 배수가 아닌 수들의 목록, 개수, 합계를 출력하는 프로그램을 완성
 *  <결과 화면>
 *  3 9 15 21 ....
 *  개수 : xx개
 *  합 : yy
 */
package N02_for문;
public class Test05 {
	public static void main(String[] args) {
		int cnt = 0;
		int sum = 0;
		for(int i=1; i<=100; i++) {
			if(i%3==0 && i%2!=0) {
				System.out.print(i + " ");
				cnt++;
				sum += i;
			}
		}
		System.out.println("\n개수 : " + cnt);
		System.out.println("합 : " + sum);
	}
}
// ====================================================================================================
코드가 이해가 안 가거나 값이 이상하게 출력될 경우
손으로 직접 코드를 돌려보는 것이 필요, 내부적으로 실행한 내용은 눈에 보이지 않기 때문에... 중간중간 print 출력한다던지...  
// ====================================================================================================
/*
 * 소수 - 1과 자기 자신으로만 나눠지는 수
 * 정수를 입력받아 입력한 정수가 소수인지 아닌지를 출력
 */
package N02_for문;
import java.util.Scanner;
public class Test06 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력하세요 : ");
		int num = sc.nextInt();
		int flag = 0;
		for(int i=2; i<num; i++) {
			if(num%i == 0) {
				flag++;
//				System.out.println(i);
				break;
			}
		}
		if(flag > 0)
			System.out.println("소수 아닙니다");
		else
			System.out.println("소수입니다");
	}
}
// ====================================================================================================
/* 
 * 정수를 입력받아 해당 정수의 팩토리얼을 계산한 결과를 출력
 */
package N02_for문;
import java.util.Scanner;
public class Test07 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력하세요 : ");
		int num = sc.nextInt();
		int result = 1;
		System.out.print(num + "! = ");
		for(int i=num; i>1; i--) {
			System.out.print(i + " * ");
			result *= i;
		}
		System.out.println("1 = " + result);
	}
}
// ====================================================================================================
/*
 * 이중 for문, 중첩 for문 @ 113p
 * for문 안에 for문이 있다는 거임 
 * 실제로 프로젝트를 할 때 이중 for문까지 쓸일은 많지 않음
 */
package N02_for문;
public class Sample03 {
	public static void main(String[] args) {
		for(int i=1; i<=5; i++) {
			for(int j=1; j<=10; j++)
				System.out.print("*");
			System.out.println();
		}		
//		해당 예제는 꼭 이중 for문 안 써도 됨!
//		for(int i=1; i<=50; i++) {
//			System.out.print("*");
//			if(i%10==0)
//				System.out.println();
//		}
	}
}
// ====================================================================================================
// 구구단 2단부터 5단까지 출력
package N02_for문;
public class Sample04 {
	public static void main(String[] args) {
//		1줄로 계속 출력됨
//		for(int i=2; i<=5; i++) {
//			for(int j=1; j<=9; j++) {
//				System.out.println(j + "*" + i + "=" + j*i);
//			}
//		}
		
//		같은 단끼리만 가로 한 줄씩 출력
//		for(int i=2; i<=5; i++) {
//			for(int j=1; j<=9; j++) {
//				System.out.print(j + "*" + i + "=" + j*i + " ");
//			}
//			System.out.println();
//		}
		
//		같은 단이 세로로 출력되게 for문 순서와 출력문 index를 수정
		for(int i=1; i<=9; i++) {
			for(int j=2; j<=5; j++) {
//				System.out.print(j + "*" + i + "=" + j*i + "\t");
				System.out.printf("%d*%d = %2d │ ",j, i, j*i);
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
// 114p 예제, 별찍기, 반복문의 기초 예제, 모든 java 책 반복문에 다 있을 거임. 그니까 다 할 거임 ㄷㄷ
package N02_for문;
public class Sample05 {
	public static void main(String[] args) {
		// 기본 삼각형 별찍기
		for(int i=1; i<=5; i++) {
			for(int j=1; j<=i; j++)
				System.out.print("*");
			System.out.println();
		}
		
		// 역순
		for(int i=1; i<=5; i++) {
			for(int j=1; j<=6-i; j++)
				System.out.print("*");
			System.out.println();
		}
		
		// 역순 거울상
		for(int i=1; i<=5; i++) {
			for(int j=1; j<=5; j++) {
				if(i>j)
					System.out.print(" ");
				else
					System.out.print("*");
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
반복문 하다가 실수로 안 끝나게 되면 결과창과 느낌이 쎄한데, 늦어지면 하얀색 화면으로 바뀌고 이클립스가 꺼짐
그러니 그런 일이 발생할 거 같으면 그전에 console창에 빨간색 버튼을 눌러서 잽싸게 반복문 중지시킬 것!!! 
// ====================================================================================================
이중 반복문은 행렬로 생각하면 패턴 찾기가 편함
		1열(j)	2열	3열	4열	5열	i	j
1행(i)	*		*	*	*	*	1	1~5 (6-i까지 반복!)
2행		*		*	*	*		2	1~4
3행		*		*	*			3	1~3
4행		*		*				4	1~2
5행		*						5	1~1
// ====================================================================================================
// 두 정수를 입력받아서 두 수 사이의 소수들의 합계, 개수, 목록을 출력
package N02_for문;
import java.util.Scanner;
public class Test08 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("두 정수를 입력하세요 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		int sum=0, cnt=0;
		if(num1 > num2) {
			int tmp = num1;
			num1 = num2;
			num2 = tmp;
		}
		
		System.out.println("=== 소수 목록 ===");
		for(; num1<=num2; num1++) {
			int cnt_ = 0;
			for(int j=1; j<=num1; j++) {
				if(num1%j == 0)
					cnt_++;
			}
			if(cnt_ == 2) { // flag && num1>1
				System.out.print(num1 + " ");
				cnt++;
				sum += num1;
			}
		}
		System.out.println();
		System.out.println("합계 : " + sum + ", 개수 : " + cnt);
	}
}
// ====================================================================================================
Day0608
// ====================================================================================================
전일 숙제 Test08 설명
NCS 시험 (직업윤리) 진행
이제 진도 시작~
while문
while(조건식){
	반복 실행할 코드
}
for문과 달리 시작값을 while문 안에 넣어주는 것이 아니므로, 반복문 시작 전에 값 지정 필요
반복 실행할 코드 내부에 조건식 안의 변수가 변하는 내용도 필요함
어떨 때 for문을 써야 하고, 어떨 때 while문으로 써야 하는 건 없음. 취향차이!
while문에서 증감연산자를 먼저 바꾸지 않는 등... 의도한 대로 결과값이 나오므로 for문보다 조금 더 신경써야 함
그래서 대체적으로는 for문을 더 많이 쓰는 편 
무한 루프 돌릴 때 정도는 while문을 씀
// ====================================================================================================
// 정수 한 개를 입력받아서 입력받은 정수의 해당하는 구구단을 출력
package N01_while문;
import java.util.Scanner;
public class Sample02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num = sc.nextInt();
		System.out.println("==== " + num + " 단 ====");
		int i = 1;
		while (i <= 9) {
			System.out.printf("%d * %d = %2d\n", num, i, num * i);
			i++;
		}
	}
}
// ====================================================================================================
// 하나의 정수를 입력받아 1부터 해당 정수까지의 홀수의 합과 개수를 출력
package N01_while문;
import java.util.Scanner;
public class Sample03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num = sc.nextInt();
		int sum=0, cnt=0;

		while(num>=1) {
			if(num%2 == 1) {
				sum += num;
				cnt++;
			}
			num--;
		}
		System.out.println("홀수 합 : " + sum + " 개수 : " + cnt);
	}
}
// ====================================================================================================
// 인원을 먼저 입력 받고, 그다음 각 학생의 성적을 입력 받은 다음, 모든 학생의 합계와 평균을 출력
package N01_while문;
import java.util.Scanner;
public class Sample04 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("인원수를 입력하시오 : ");
		int nStd = sc.nextInt();	// 학생수
		int sum = 0; 				// 점수 총합
		
		int i=1;
		while(i<=nStd) {
			System.out.print(i + "번째 학생 성적 입력 : ");
			sum += sc.nextInt();
			i++;
		}
		System.out.println(nStd + "명 성적의 총 합계 : " + sum);
		System.out.printf("%d명 성적의 총 평균 : %.2f", nStd, sum/(double)nStd);
	}
}
// ====================================================================================================
// 정수를 입력받아서 입력받은 정수의 각 자리수 합계를 출력, 교재 117p 예제
package N01_while문;
import java.util.Scanner;
public class Sample05 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num = sc.nextInt();
		int sum = 0;
		String str = "";
		
		while(num>=1) {
			sum += num%10;
			str = ((num/10>=1) ? " + " : "자리수 합 : ") + num%10 + str;
			num /= 10;
		}
		System.out.println(str + " = " + sum);
	}
}
// ====================================================================================================
다들 수학 좋아하는지? 헤헷. 수학이랑 다른 점은 만들어진 공식을 사용하는 게 아니라...
고민하는 거예 재미를 붙이도록 노력해볼 것... vs 아니면 문제를 엄청 많이 풀어보든가
둘 중에 하나는 해야 함 ㄷㄷ 즐기는 쪽으로 해보...세요.
// 모듈화 개념이나 기본 개념의 응용 그리고 약간의 비약만 있어도...
끝나고 집에 가서 뭐하는지... 복습들 하시오. 지금은 20분이면 어느 정도 끝나지만 나중에는 한 문제에 하루가 걸릴 수도... 
// ====================================================================================================
// 정수를 입력 받아 while문을 사용해서 삼각형 별찍기
package N01_while문;
import java.util.Scanner;
public class Sample06 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력하시오 : ");
		int num = sc.nextInt();
		
		int i=1;
		while(i<=num) {
			int j=1;
			while(j<=i) {
				System.out.print("*");
				j++;
			}
			System.out.println();
			i++;
		}
	}
}
// ====================================================================================================
// 정수를 계속 입력받아 1부터 입력받은 정수까지 3의 배수 개수를 출력 (0을 입력하면 종료)
package N01_while문;
import java.util.Scanner;
public class Sample07 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력(종료 → 0) : ");
		num = sc.nextInt();
		while(num != 0) {
			System.out.println("1부터 " + num + "까지 3의 배수 개수 : " + num/3);
			System.out.print("정수 입력(종료 → 0) : ");
			num = sc.nextInt();
		}
	}
}
// ====================================================================================================
break; 반복문 탈출에서도 자주 사용!!! Sample07 break 활용해서 수정할 수 있음
for( ; ; ){
	무한 반복함
}
while(true){
	무한루프
}
무한루프는 while문을 더 많이 사용하는 경향이 있음 
왜 그런지는 모르겠음 for문 형식에 저렇게 시작점, 조건식, 증감식 등이 다 비어있어서 안 예뻐서 그런지는... ㅇㅇ 안 예쁨!!! ㅋㅋ
// ====================================================================================================
반복문 : do~while
do { 		// 한번 작동됨
	반복실행 코드
} while(조건식);
*while 뒤에 ; 들어감 주의!
잘 안씀, 아마 오늘 이후에 수업에선 쓸일 없을 듯...
do-while은 조건에 만족하든 안하든 한번은 무조건 실행된다.
쉽게 조건문이 뒤에 있기 때문에 do에 있는 것이 최소 한 번은 실행된다고 생각하면 편함
애초에 그러한 상황이 안되게 반복문을 구성하기 때문에 do-while문을 사용할 일이 별로 없다는 것임
// ====================================================================================================
package N02_do_while문;
public class Sample01 {
	public static void main(String[] args) {
		int i =5;
		do {
			System.out.println("이거 진짜 실행되냐?");
		} while(i<3);
	}
}
// ====================================================================================================
// 정수를 입력받아 1부터 해당 값까지 합계를 구하는 프로그램을 do-while을 사용하여 완성
package N02_do_while문;
import java.util.Scanner;
public class Sample02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num = sc.nextInt();
		int sum = 0;
		do {
			sum += num;
			num--;
		} while(num>=1);
		System.out.println("합계 : " + sum);
	}
}
// ====================================================================================================
// 책 118p 예제, 1~100 사이 숫자 랜덤 1개 생성 후 사용자가 맞춰가는 형태
// 술 게임 ?? 소주병 뚜겅 ㄷㄷ 모름!
package N02_do_while문;
import java.util.Scanner;
public class Sample03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int input;
		int answer = (int)(Math.random()*100) + 1;
		
		int cnt=0;
		do {
			System.out.print("1과 100 사이의 정수를 입력하세요 : ");
			input = sc.nextInt();
			cnt++;
			if(input > answer)
				System.out.println("더 작은 수로 다시 시도해보세요.");
			else if(input < answer)
				System.out.println("더 큰 수로 다시 시도해보세요.");			
		} while(input != answer);
		System.out.println(cnt+"회 시도 후 정답입니다.");
	}
}
// ====================================================================================================
break는 반복문 탈출이 다임
break문 위치는 위든 아래든 상관없는데 그때 조건문이 달라질 거임 그부분만 신경쓰면 됨
// ====================================================================================================
package N03_break문;
public class Sample01 {
	public static void main(String[] args) {
		int i;
		for(i=1; i<=100; i++) {
			if(i==51)
				break;
			System.out.println(i);
//			if(i==50)
//				break;
		}
	}
}
// ====================================================================================================
break는 바로 상위의 반복문만 탈출함
// ====================================================================================================
package N03_break문;
public class Sample02 {
	public static void main(String[] args) {
		while(true) {
			for(int i=1; i<=5; i++) {
				System.out.println(i);
				if(i==3)
				break; // 해당 break는 for문만 나가는 것이므로 while의 무한루프는 벗어나지 않음
			}
		}
	}
}
// ====================================================================================================
continue문 break는 멈추는 거고 continue는 아래를 무시하고 반복을 다시 올라감
특정 조건을 건너 뛸 수 있게 함.
흐름 제어를 강제하는 거는 별로 좋은 코드가 아니어서 continue나 내일 배울 loop에 이름 붙이는 거 같은 거는 실제로 잘 쓰지 않음!
// ====================================================================================================
package N04_continue문;
public class Sample01 {
	public static void main(String[] args) {
		for(int i=1; i<=10; i++) {
			if(i%2 == 0)
				continue;
			System.out.println(i);
		}
	}
}
// ====================================================================================================
/*
 * 숙제! 집에 가서 해오세요~
 * 자판기 [1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료
 * ====자판기 작동중====
 * 어떤 상품을 구매하시겠습니까?
 * ([1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료)
 * 1
 * 소주를 구매하셨습니다.
 * 어떤 상품을 구매하시겠습니까?
 * ([1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료)
 * 2
 * 라면을 구매하셨습니다.
 * 어떤 상품을 구매하시겠습니까?
 * ([1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료)
 * 9
 * 잘못 입력하셨습니다.
 * 어떤 상품을 구매하시겠습니까?
 * ([1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료)
 * 4
 * ====자판기 종료====
 */
package N04_continue문;
import java.util.Scanner;
public class Sample02 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("====자판기 작동중====");
		int sel;
		
		while(true) {
			System.out.println("어떤 상품을 구매하시겠습니까?");
			System.out.println("([1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료)");
			sel = sc.nextInt();
			
			if(sel==1)
				System.out.println("소주를 구매하셨습니다.");
			else if(sel==2)
				System.out.println("라면을 구매하셨습니다.");
			else if(sel==3)
				System.out.println("커피를 구매하셨습니다.");
			else if(sel==4) {
				System.out.println("====자판기 종료====");
				break;
			}
			else
				System.out.println("잘못 입력하셨습니다.");
		}
	}
}
// ====================================================================================================
Day0609
// ====================================================================================================
숙제들 해오셨는지
자판기 설명
if문으로 설명 후 switch-case문으로 수정
Loop(=반복문의 원하는 이름):
while(true){
	switch(num){
		case 4:
			break Loop; // 이러면 반복문 종료 가능
// ====================================================================================================
package N01_복습;
import java.util.Scanner;
public class Sample01 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("====자판기 작동중====");
		int sel;
		Loop:
		while(true) {
			System.out.println("어떤 상품을 구매하시겠습니까?");
			System.out.println("([1] 소주, [2] 라면, [3] 커피, [4] 자판기 종료)");
			sel = sc.nextInt();
			switch(sel) {
				case 1:
					System.out.println("소주를 구매하셨습니다.");
					break;
				case 2:
					System.out.println("라면을 구매하셨습니다.");
					break;
				case 3:
					System.out.println("커피를 구매하셨습니다.");
					break;
				case 4:
					System.out.println("====자판기 종료====");
					break Loop;
				default:
					System.out.println("잘못 입력하셨습니다.");
			}
		}
	}
}
// ====================================================================================================
반복문에 이름 붙이는 거는 진짜 부득이한 경우 아니면 안 쓰도록 유도함, 거의 쓸일이 없음
그 내용이 교재 122p, 123p있음 내일 심심하면 집에서 봐요. 굳이 안 봐도 돼.
반복문 하나 더 있긴 한데, for문이 배열...?? 형식이 달라짐. 다른 거 좀 배우고 아직 못 하기 때문에 나중에 할 거임
책에 중간중간에 연습문제가 있는데 답도 없음 알아서 해보고 2개만 해봅시다...웩
125p 4-3번, 4-4번  
// ====================================================================================================
// 교재 125p 4-3번, 4-4번
package N01_복습;
public class Test01 {
	public static void main(String[] args) {
		int result = 0;
		for(int i=1; i<=10; i++)
			for(int j=1; j<=i; j++)
				result += j;
		System.out.println("교재 125p 4-3번 결과 : " + result);
		
		// if 안 쓰고 하는 거
		idx = 0;
		sum = 0;
		int sw = 1;
		while(sum<100) {
			idx++;
			sum += idx*sw;
			sw = -sw;
		}
		System.out.println("교재 125p 4-4번 답안 : " + idx + "까지 더해야 총합이 100 이상이 됩니다.");
	}
}
// ====================================================================================================
배열(배열 변수)
변수랑 똑같은데, 우리가 알고 있는 변수는 값을 저장하는 공간인데, 변수 안에는 종류는 다양해도 값을 무조건 하나만 넣을 수 있음.
여태껏 우리가 사용했던 일반 변수와 차이는, 여러 개의 값을 저장할 수 있는 변수
배열도 자료형을 저장함
여러 개를 저장할 수 있지만, 여러 개의 자료형을 저장할 수는 없음
int면 int만, double이면 double만!
선언 방식: 자료형 뒤에 대괄호가 들어감
eg. int[] 변수이름 = new int[5]; // 5개의 정수들을 보관하는 배열 변수 선언
*대괄호 위치는 변수이름 뒤에도 되긴 함 int 변수이름[] 
근데 일반적으로는 자료형 뒤에 [] 씀.
어떨 때 쓰는지? eg. 학교에 40명 수학점수를 저장 → int[] math = new int[40]; 
일반 변수랑은 조금 조금 다른 점이 있으니까 코드 쓰면서 얘기할 것임
첫번째 차이점 일반변수는 초기설정 안 되어 있으면 출력할 때 에러가 나는데, 배열은 초기설정 안해도 출력시키면 배열의 정보(정확히는 자바가 알아서 정해준 컴퓨터의 주소값)이 출력됨
// ====================================================================================================
package N02_배열;
public class Sample01 {
	public static void main(String[] args) {
		int[] arr = new int[5];
		int a;
//		System.out.println(a); a를 초기화하지 않은 상태에서 출력하면 에러 발생(실행되지 않음)
		System.out.println(arr); // arr를 출력하면 주소값이 출력됨
		System.out.println(arr[0]); /* 배열의 시작은 0부터! arr[0], arr[1], ... , arr[4] 
									 * 배열은 값을 안 넣어도 값을 알아서 채워놓음
									 * int는 0
									 * double은 0.0
									 * char는 '0'(출력해보면 공백 한칸 나옴)
									 * string은 null (null이라는 게 null이 문자로 저장된 게 아니고 비어있다는 의미)
									 * boolean은 false
									 * 그러니까 특별히 따로 초기화 하지 않아도 기본값으로 초기화되어 있음!
									 */
		// 배열의 초기화는 중괄호를 사용해서함, 배열을 아래 값직접 먼저 
		int[] array = {1, 2, 3, 4, 5};
		System.out.println(array[0]);
		System.out.println(array[1]);
		System.out.println(array[2]);
		System.out.println(array[3]);
		System.out.println(array[4]);
//		System.out.println(array[5]); 범위에 벗어나는 배열값 출력 실행 시 에러발생!
		
		arr[3] = 10; // 특정 배열값 수정은 그냥 대입연산자, 변수랑 똑같이 사용해서 쓰면 됨

		// 배열은 반복문과 뗄레야 뗄 수 없음...
		int x=10, y=20, z=30;
		arr[0]=10;
		arr[1]=20;
		arr[2]=30;
		for(int i=0; i<3; i++)
			System.out.println(arr[i]); // x, y, z 는 print를 각각 해야 함, 배열은 반복문을 이용하면 입력, 출력을 좀더 용이하게 할 수 있음!
		//배열 너무 어렵게 생각하지는 말고 그냥 변수구나라고 생각...
	}
}
// ====================================================================================================
// 배열 arr에 저장된 숫자들의 합계를 출력
package N02_배열;
public class Sample02 {
	public static void main(String[] args) {
		int[] arr = {10, 20, 30, 40, 50}; // int[] arr; arr = new int[]{10, 20, 30, 40, 50};
		int sum = 0;
		for(int i=0; i<5; i++)
			sum += arr[i];
		System.out.println("합계 : " + sum);
	}
}
// ====================================================================================================
// 5개의 점수를 입력받아서 출력
package N02_배열;
import java.util.Scanner;
public class Sample03 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] score = new int[5];
		for(int i=0; i<5; i++) {
			System.out.print((i+1) + "번째 점수 입력 : ");
			score[i] = sc.nextInt();
		}
		System.out.println("====결과 확인1====");
		for(int i=0; i<5; i++)
			System.out.print(score[i] + " ");
		System.out.println();
		System.out.println("====결과 확인2====");
		System.out.println("score.length : " + score.length);
		for(int i=0; i<score.length; i++) // 배열 크기 알려주는 명령어를 사용하면, 귀찮게 배열 크기를 항상 기억하고 있을 필요가 없어지고 나중에 배열크기가 변경이 필요할 때도 코드 수정이나 유지보수에 용이
			System.out.print(score[i] + " ");
		System.out.println();
		System.out.println("====결과 확인3====");
		// 향상된 for문 (8버전부터 생겼으면 난 본적이 없겠군ㅋㅋㅋ)
		// a는 임시로 보관해서 사용할 변수, 아무 거나 상관없는데, 자료형은 배열의 자료형과 동일해야 함
		// 반복 횟수같은 건 신경 안 써도 알아서 해준다는 의미!!! 이거 좋네, python에서 in이랑 비슷한 듯
		// 향상된 for문은 편해 보이죠? 그래서 배열이나 차후에 사용할 collection 같은 곳에서 쓸 수 있음
		// a는 지금 임시로 써놨는데 보통은 배열명을 scores(s 붙이고), for문 임시변수를 score를 붙이기도 함(당연히 중복 이름은 쓸 수 없음)
		for(int a : score)
			System.out.print(a + " ");
		System.out.println();
		System.out.println("====결과 확인4====");
		// 배열에 저장된 값 단순 출력, 작업은 안 됨, Arrays.toString 쓰면 반복문은 안 써도 됨, A랑 S 대소문자이니까 신경쓸 것!
		// 지금 단계에서 용어를 써서 설명하기는 어려우니 현시점에서는 그냥 자바 명령어라고 생각하라심
		// 출력이 된 거는 정확하게는 각각 따로 출력한 게 아니고, 하나의 문자열임 eg. "[3, 6, 5, 7, 9]"
		// 실제로 많이 쓸일은 없다심
		System.out.println(Arrays.toString(score));
	}
}
// ====================================================================================================
// 교재 138p 예제: 점수를 보관하는 배열에 100, 88, 100, 100, 90을 저장, 그 점수들의 합계와 평균을 출력
package N02_배열;
public class Sample05 {
	public static void main(String[] args) {
		int[] scores = {100, 88, 100, 100, 90};
		int sum = 0;
		for(int score : scores)
			sum += score;
		System.out.println("합계 : " + sum);
		System.out.println("평균 : " + sum/(double)scores.length);
	}
}
// ====================================================================================================
// 점수 5개를 입력받아 배열에 저장한 후 점수들 중 최대값과 최소값을 출력
package N02_배열;
import java.util.Scanner;
public class Sample06 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] scores = new int[5];
		for(int i=0; i<scores.length; i++) {
			System.out.print((i+1) + "번째 점수 입력 : ");
			scores[i] = sc.nextInt();
		}
		int max = scores[0];
		int min = scores[0];
		for(int score:scores) {
			if(score > max)
				max = score;
			if(score < min)
				min = score;
		}
		System.out.println("최대값 : " + max + " 최소값 : " + min);
	}
}
// ====================================================================================================
// arr의 값을 오름차순 정렬해서 출력하는 프로그램
package N02_배열;
import java.util.Arrays;
public class Sample07 {
	public static void main(String[] args) {
		int[] arr = {70, 30, 50, 90, 60};
		int i, j, tmp;
		for(i=0; i<arr.length-1; i++) {
			for(j=i+1; j<arr.length; j++) {
				if(arr[i] > arr[j]) { // 내림차순 정렬하려면 부등호 방향만 바꾸면 됨!
					tmp = arr[j];
					arr[j] = arr[i];
					arr[i] = tmp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
	}
}
// ====================================================================================================
// 로또 번호 생성, 책 140p에 있는 거 그대로 설명
package N02_배열;
public class Sample08 {
	public static void main(String[] args) {
		int[] ball = new int[45];
		
		for(int i=0; i<ball.length; i++)
			ball[i] = i+1;
		
		int j, tmp;
		for(int i=0; i<6; i++) {
			j = (int)(Math.random()*45);
			tmp = ball[i];
			ball[i] = ball[j];
			ball[j] = tmp;
			System.out.print(ball[i] + " ");
		}
	}
}
// ====================================================================================================
// 로또 번호 생성 다른 방법
package N02_배열;
import java.util.Arrays;
public class Sample09 {
	public static void main(String[] args) {
		int[] lotto = new int[6];
		int num = 45; // 45로 하면 너무 확인하기 어려우니까 6으로 줄여서 1~6이 잘 나오는지 확인
		for(int i=0; i<lotto.length; i++) {
			lotto[i] = (int)(Math.random()*num)+1;
			for(int j=0; j<i; j++) {
				if(lotto[i] == lotto[j])
					i--;
			}
		}
		System.out.println(Arrays.toString(lotto));
	}
}
// ====================================================================================================
// 5명의 점수를 입력받아서 순위를 출력
package N02_배열;

import java.util.Scanner;

public class Sample10 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] score = new int[5];
		int[] rank = new int[score.length];
		for(int i=0; i<score.length; i++) {
			System.out.print((i+1) + "번째 학생 점수 입력 : ");
			score[i] = sc.nextInt();
		}
		for(int i=0; i<score.length; i++) {
			rank[i] = 1; // 배열 초기값이 0이니까 그걸 활용해서 if 조건문에 등호를 포함하면 초기화 할 필요가 없기도 함
			for(int j=0; j<score.length; j++) {
				if(score[i] < score[j]) {
					rank[i]++;
				}
			}
		}
		System.out.println("\n====결과 출력====\n");
		for(int i=0; i<score.length; i++)
			System.out.printf("%d번째 학생 점수 : %3d점, 순위 : %d위\n", i+1, score[i], rank[i]);
	}
}
// ====================================================================================================
후딱 과제요. 주말을 알차게??? ㄷㄷ
5명의 국어, 영어, 수학점수를 입력받아서 순위를 출력
각 학생의 국영수 합계와 평균 그리고 순위를 출력
--------------
1번 학생의 국어점수 입력 : 
1번 학생의 영어점수 입력 :
1번 학생의 수학점수 입력 :
...
5번 학생의 수학점수 입력 :
====성적표====
번호 국어 영어 수학 총점 평균 순위
// ====================================================================================================
Day0612
// ====================================================================================================
지난 주말 과제 설명
// ====================================================================================================
package N01_숙제;
import java.util.Scanner;
public class Sample01 {
	public static void main(String[] args) {
		int cnt = 5;
		int[] kor = new int[cnt];
		int[] eng = new int[cnt];
		int[] math = new int[cnt];
		int[] sum = new int[cnt];
		double[] avg = new double[cnt];
		int[] rank = new int[cnt];		
		Scanner sc = new Scanner(System.in);
		for(int i=0; i<cnt; i++){
			System.out.print((i+1)+"번 학생의 국어점수 입력 : ");
			kor[i] = sc.nextInt();
			System.out.print((i+1)+"번 학생의 영어점수 입력 : ");
			eng[i] = sc.nextInt();
			System.out.print((i+1)+"번 학생의 수학점수 입력 : ");
			math[i] = sc.nextInt();
			sum[i] = kor[i] + eng[i] + math[i];
			avg[i] = sum[i]/3.0;
		}
		for(int i=0; i<cnt; i++){
			rank[i] = 1;
			for(int j=0; j<cnt; j++) {
				if(avg[i] < avg[j])
					rank[i]++;
			}
		}	
		System.out.println("====성적표====");
		System.out.println("번호\t국어\t영어\t수학\t총점\t평균\t순위");
		for(int i=0; i<cnt; i++)
			System.out.printf("%d\t%3d\t%3d\t%3d\t%3d\t%.1f\t%d\n", (i+1), kor[i], eng[i], math[i], sum[i], avg[i], rank[i]);
	}
}
// 나중에 클래스 배우면... 배열을 이런 식으로 쓸일은 없을 거라고 하심.
// ====================================================================================================
책 설명에는 String만 따로 설명하고 있는데 사용법은 int, double이랑 똑같음
가볍게 이차원 배열로 넘어가심
이차원 배열도 이중 반복처럼 잘 안 쓴다고 하심
일차원 배열 0번방, 1번방, 2번방, 3번방, ...
이차원 	(0,0), (0,1), (0,2), ...
		(1,0), (1,1), (1,2), ...
		(2,0), (2,1), (2,2), ...
컴퓨터는 행렬이라는 개념이 없어서, 실제로는 이렇게 네모로 만들어지는 건 아니고 일차원배열이 만들어짐
선언방식은 대괄호 하나 더 들어간다고 생각하면 됨
int[][] b = new int[5][6];
5개 행 6개 열, 행렬로 생각하면 좀 편함.
// ====================================================================================================
package N02_이차원배열;
public class Sample01 {
	public static void main(String[] args) {
		int[][] arr = {{1,2,3},{4,5,6}}; // 이차원배열 arr = new int[2][3]
		int[][] arr1 = {
				{1,2,3},
				{4,5,6}
				}; // 가독성을 위해서 엔터. 나중에 자바스크립트도 이런 식으로 쓴다심.
		//출력은 이중 for문
		System.out.println("이차원 배열 arr 행 개수 : " + arr.length);
		System.out.println("이차원 배열 arr 열 개수 : " + arr[0].length);	// 꼭 0을 써야 하는 것은 아님, 그냥 하나 넣으면 그 다음 길이가 나오는 거.
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[0].length; j++)
				System.out.print(arr[i][j] + " ");
			System.out.println();
		}
	}
}
// ====================================================================================================
// 1~25까지 5-by-5에 값을 저장하고 출력
package N02_이차원배열;
import java.util.Arrays;
public class Sample02 {
	public static void main(String[] args) {
		int[][] arr = new int[5][5];
		int k = 1;
		for(int i=0; i<arr.length; i++){
			for(int j=0; j<arr[i].length; j++){
				arr[i][j] = k;
				k++;
			}
		}
		for(int i=0; i<arr.length; i++){
			for(int j=0; j<arr[i].length; j++){
				System.out.printf("%3d", arr[i][j]);
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
/*
 * 별찍기랑 똑같은 방식으로 값 저장 후 출력
 *   1
 *   2  3
 *   4  5  6
 *   7  8  9 10
 *   11 12 13 14 15
 */
package N02_이차원배열;
public class Sample03 {
	public static void main(String[] args) {
		int[][] arr = new int[5][5];
		int k = 1;
		for(int i=0; i<arr.length; i++){
			for(int j=0; j<=i; j++){
				arr[i][j] = k;
				k++;
				System.out.printf("%3d", arr[i][j]);
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
/*
 * 구구단 출력과 똑같은 방식으로 값 저장 후 출력
 * 1  6 11 16 21
 * 2  7 12 17 22
 * 3  8 13 18 23
 * 4  9 14 19 24
 * 5 10 15 20 25
 */
package N02_이차원배열;
public class Sample04 {
	public static void main(String[] args) {
		int[][] arr = new int[5][5];
		int k = 1;
		for(int i=0; i<arr.length; i++){
			for(int j=0; j<arr.length; j++){
				arr[j][i] = k;
				k++;
			}
		}
		for(int i=0; i<arr.length; i++){
			for(int j=0; j<arr.length; j++){
				System.out.printf("%3d", arr[i][j]);
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
/*
 * 별찍기랑 똑같은 방식으로 값 저장 후 출력
              1
           2  3
        4  5  6
     7  8  9 10
 11 12 13 14 15
 */
package N02_이차원배열;
public class Sample05 {
	public static void main(String[] args) {
		int[][] arr = new int[5][5];
		int k = 1;
		for(int i=0; i<arr.length; i++)
			for(int j=4-i; j<arr[i].length; j++)
				arr[i][j] = k++;
		
		for(int i=0; i<arr.length; i++){
			for(int j=0; j<arr[i].length; j++){
				if(i+j>=4) // if(arr[i][j] == 0)
					System.out.printf("%3d", arr[i][j]);
				else
					System.out.print("   ");
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
/* 
 * 1~25까지 5-by-5에 값을 달팽이로 저장하고 출력
 *    1  2  3  4  5
 *   16 17 18 19  6
 *   15 24 25 20  7
 *   14 23 22 21  8
 *   13 12 11 10  9
 */
package N02_이차원배열;
public class Sample07 {
	public static void main(String[] args) {
		int size = 5;
		int[][] arr = new int[size][size];
		for(int k=1; k<=size*size; k++) {
			arr[i][j] = k;
			if(i<=j+1 && i+j<size-1)
				j++;
			else if(i+j>=size-1 && i<j)
				i++;
			else if(i>=j && i+j>size-1)
				j--;
			else if(i+j<=size-1 && i>j+1)
				i--;
		}
		for(i=0; i<arr.length; i++){
			for(j=0; j<arr[i].length; j++){
				System.out.printf("%3d", arr[i][j]);
			}
			System.out.println();
		}
	}
}
// ====================================================================================================
삼차원 배열
collection이라는 게 따로 있어서 나중에 안 씀
배열을 안 쓰는 이유는 배열 크기를 먼저 지정해야 하고 변경할 수 없기 때문임
int[][][] arr = new int[4][5][6]
그래서 사이즈 변경하고 그러려면 복사하고 넘기고 해야함
// ====================================================================================================
package N02_이차원배열;
import java.util.Arrays;
public class Sample08 {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4};
		int[][] arr2 = {
				{1, 2, 3},
				{4, 5, 6}
		};
		System.out.println(Arrays.toString(arr));
		System.out.println(Arrays.deepToString(arr2)); // 이차원 배열을 출력시키기 위한 명령어

		String[] str1 = {"abc", "def"};
		String[] str2 = {"abc", "ghi"};
		System.out.println(str1[0] + " " + str2[0]);
		System.out.println(str1 == str2); // 주소값이니까 false
		System.out.println(str1[0] == str2[0]); // 값비교니까 true
		System.out.println(str1[0].equals(str2[0])); // 지금은 왜 이게 필요할까 싶지만 나중에 객체 사용할 때 필요함
	}
}
// ====================================================================================================
package N02_이차원배열;
import java.util.Arrays;
public class Sample09 {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4};
		int size = 7;
		int[] arr2 = Arrays.copyOf(arr, size);
		System.out.println(Arrays.toString(arr2));
		int[] arr3 = Arrays.copyOfRange(arr, 1, 3);		
		System.out.println(Arrays.toString(arr3));
	}
}
// ====================================================================================================
교재 160p
크게 두개로 나뉘는데
객체지향 프로그래밍 java, c++
절차(순차)지향 프로그래밍 c
python은 절차이긴 한데 객체도 쓸 수 있어서 경계가 모호
절차는 말그대로 위에서 아래로 쭈루룩 실행되는 거
객체도 기본적으로는 위에서 아래로 실행되는데, 객체 위주로 프로그램을 작성했다.
객체지향의 특징이 4가지가 있음: 상속, 다형성, 추상화, 캡슐화
나중에 코드랑 같이 볼 거임
객체지향언어의 특징
재사용성이 높다 / 관리가 용이하다 / 신뢰성이 높다(=정확성이 높다) 
지금까지도 class를 만들어서 쓰긴 했지만 객체를 만들어서 쓴적은 없음
굳이 나누자면 클래스는 객체랑 다름
클래스를 만들어야 객체를 만들 수 있음
이케아에서 의자를 샀을 때,
의자를 만드는 설명서 = 클래스,
설명서를 이용해서 만든 의자 = 객체
빨간의자, 파란의자 ㅋㅋㅋ 만들 수 있지...
클래스는 뼈대를 만들어 놓는 것
잘 모르겠죠? 헤헷
배열은 지정된 데이터 타입만 보관할 수 있는데, 클래스는 다양한 데이터 타입을 한 번에 보관할 수 있음
오늘 숙제였던 국어, 영어, 수학, 평균, 순위를 이차원 배열로 하면 평균이 double이라 안되는데, 클래스로 만들면 가능하다는 거
class는 각각의 파일에 저장함(왜냐면 java 파일명이 class 명이랑 같은 것이 있으므로, 중복해서 만들면 헷갈리게 됨)
클래스 이름의 첫글자는 대문자로 지정해서 변수랑 구분하자는 선조들의 약속
클래스 이름은 명사로 하자고 하긴 함. 동사 nono
그래야지 클래스가 어떤 걸 보관하는지 명시하기 위해서
여러 개의 단어가 합쳐지면 두번째 단어의 첫글자 대문자로 카멜표기법? eg. mathTotal 
클래스명 객체이름 = new 클래스명(); // Scanner와 동일함
// ====================================================================================================
package N03_클래스;
public class Animal {
	String name; // 클래스 내에 선언된 변수를 멤버변수라고 함
	int age;
	/*
	 * 클래스에 변수만 설정할 수 있는 게 아니라 메서드, 메소드 (다른 언어에서 함수)도 설정할 수 있음
	 * eg. Math.random(), Math.round() : Math라는 클래스에 있는 random, round 메서드
	 * 메서드 만드는 방법이 다양해서 좀 살펴 보겠음
	 * 형식:
	 * 		접근제한자 리턴타입 메서드이름(매개변수){
	 * 			메서드 기능 구현
	 * 		}
	 * 		접근제한자나 리턴타입 모르니까 지금은
	 * 		public void 메서드이름(){
	 * 			메서드 기능 구현
	 * 		}
	 */
	public void showInfo() {
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
	}
}
// ====================================================================================================
package N03_클래스;
public class Sample01 {
	public static void main(String[] args) {
		Animal cat = new Animal();
		/*
		 * Animal : 클래스
		 * cat : 객체
		 * cat객체는 Animal 클래스의 인스턴스
		 * cat은 객체다
		 * Animal 클래싀의 객체는 cat이다라는 표현보다 인스턴스라는 표현을 씀
		 * cat만 만들 수 있는 것이 아니므로...
		 * 근데 인스턴스라는 표현을 잘 쓰지도 않고 그냥 그러려니 하고 넘어가라심 헤헷
		 */
		cat.name = "야옹이"; // xx.yy 는 xx에 소속된 yy를 의미
		System.out.println("cat name : " + cat.name);
		// Animal class만 멤버변수를 추가하게 수정해서 변수를 일괄적으로 만들 수 있음
		cat.age = 5;
		System.out.println("cat age : " + cat.age);
		
		Animal dog = new Animal();
		System.out.println("dog name : " + dog.name); // (cat.)name 값 설정했다고, dog.name 초기화 안 하면 안 나옴
		dog.name = "멍멍이";
		System.out.println("dog name : " + dog.name);
		cat.age = 3;
		System.out.println("dog age : " + dog.age);
		
		cat.showInfo(); // ()괄호가 없으면 변수로 인식함
		dog.showInfo();
		
		// 나중에 되면 main에는 code가 별로 없고 다 각각의 class에 있음
	}
}
// ====================================================================================================
package N03_클래스;
public class Tv {
	String color;
	boolean power;
	int channel;
	public void power() { // public 써야 함! 보통 메서드 이름은 기능이기 때문에 동사형태로 씀. 이런 식으로는 잘 안 씀 
		power = !power;
	}
	public void channelUp() {
		channel++;
	}
	public void channelDown() {
		channel--;
	}
	public void showInfo() {
		if(power)
			System.out.println("전원 : 켜짐");
		else
			System.out.println("전원 : 꺼짐");
		System.out.println("TV 색상 : " + color);
		System.out.println("현재 채널 : " + channel);
	}
}
// ====================================================================================================
package N03_클래스;
public class Tv {
	String color;
	boolean power;
	int channel;
	public void power() { // public 써야 함! 보통 메서드 이름은 기능이기 때문에 동사형태로 씀. 이런 식으로는 잘 안 씀 
		power = !power;
	}
	public void channelUp() {
		channel++;
	}
	public void channelDown() {
		channel--;
	}
	public void showInfo() {
		if(power)
			System.out.println("전원 : 켜짐");
		else
			System.out.println("전원 : 꺼짐");
		System.out.println("TV 색상 : " + color);
		System.out.println("현재 채널 : " + channel);
	}
}
// ====================================================================================================
package N03_클래스;
import java.util.Scanner;
public class TvMain {
	public static void main(String[] args) {
		Tv lgTv = new Tv();
		lgTv.showInfo(); // 초기화 안했을 때 기본값~~
		lgTv.color = "검정색";
		lgTv.channel = 11;
		lgTv.showInfo();
		
		lgTv.power();
		lgTv.showInfo();
		
		Scanner sc = new Scanner(System.in);
		while(true) {
//			System.out.println("TV전원 On/off [버튼은 1번]");
//			if(sc.nextInt() == 1) {
//				lgTv.power();
			System.out.println("1번 : 전원, 2번 : 채널+, 3번 : 채널-");
			int n = sc.nextInt();
			if(n==1)
				lgTv.power();
			else if(n==2)
				lgTv.channelUp();
			else if(n==3)
				lgTv.channelDown();
			lgTv.showInfo();
		}
	}
}
// ====================================================================================================
Day0613
// ====================================================================================================
/*
 * Student 클래스를 완성하시오
 * String 이름, int 나이, String 전화번호 멤버변수를 생성
 * main에서 Student 클래스의 인스턴스를 생성하고,
 * 이름, 나이, 전화번호를 저장한 후 출력
 * 정보를 출력하는 메서드를 생성해서 출력할 것
 * 정보출력 메서드 이름 showInfo()
 */
package N01_복습;
public class Sample01 {
	public static void main(String[] args) {
		Student std = new Student();
		std.showInfo();
		std.name = "김이름";
		std.age = 30;
		std.phone = "010-1234-5678";
		std.showInfo();
	}
}
// ====================================================================================================
package N01_복습;
public class Student {
	String name;
	int age;
	String phone;
	public void showInfo() {
		System.out.println("이름 : " + name + ", 나이 : " + age + ", 전화 : " + phone);
	}
}
// ====================================================================================================
class를 많이 생성하게 되며서 
class 동일명을 생성할 수 없으니까...
패키지 이름도 이제 신경써야 함
패키지는 폴더라고 생각하면 됨 다른 폴더 아래에는 같은 class 이름을 또 사용할 수는 있다
참조는 기본적으로 동일한 패키지에서 class를 검색하는데,
없으면 자동완성 기능으로 패키지 선택을 해서 import! Scanner와 동일한 개념임!
// ====================================================================================================
Student std; 라고 하면 초기화는 안된 그냥 객체만...
이 상태에서도 Student가 지정되었기 때문에, std는 다른 class의 타입을 담을 수 없음
String str = new String("asdf"); 인데, wrapper 클래스라고 지금 배우는 클래스 개념이랑은 또 다르다고 나중에 본다고 하심
멤버변수 필드라고도 하는데 뭐 그건 됐고...라고 하심
// ====================================================================================================
클래스에서 멤버변수에 초기값 설정을 할 수도 있음
인스턴스의 공통적인 값을 관리할 때 eg. 고2학생 관리이면 age가 고정값이니까
초기값을 0이 아닌 다른 기본값으로 설정해두면 main에서 지정하지 않아도 되는 편리함이 있음 
나중에 생성자라는 것을 공부하게 되면 이런 식으로 사용하진 않는데 나중에 본다심
// ====================================================================================================
package N01_복습;
public class StuMain02 {
	public static void main(String[] args) {
		int[] a = new int[5];
		Student[] std = new Student[30];
		/*
		 * 객체를 배열로 생성하면 추가로 신경써야 할 것이
		 * 방은 존재하는데 객체가 생성되지 않음
		 * 아래처럼 각 배열방에 객체를 생성해주세요 해야 함
		 * 배열방만 생성시에는 std[0].name 출력하면 에러 발생됨
		 * 교재로는 169p
		 */
		for(int i=0; i<std.length; i++){
			std[i] = new Student();
			std[i].name = "학생"+(i+1);
			std[i].age = 18;
			std[i].phone = "010-1234-56"+(i+1);
			System.out.print(i+1+" 학생 정보 → ");
			std[i].showInfo();
		}
	}
}
// ====================================================================================================
코드를 분석하는데 있어서는 왔다갔다해야 하니 객체지향 프로그램이 더 복잡하고
코드도 간결해진다고 할 수는 없지만...
코드를 다 이해한다음 유지보수 측면에서는 이득이 있다심...
// ====================================================================================================
package N02_정적변수;
public class Field {
/*
 * 변수 종류 173p
 * static 변수 (정적 변수, 클래스 변수)
 */
	int a; // 멤버 변수
	static int b; // 정적 변수, 모든 인스턴스에서 공유하는 변수, 
	/*
	 * static 변수. 정리하면.
	 * 동일한 클래스의 모든 인스턴스를 공유하는 변수임
	 * 그래서 사용하는 것도 객체이름.변수 형태로 사용도 가능하지만
	 * 클래스이름.변수 형태로 사용할 수 있다.
	 * 클래스이름.변수로 사용 가능하다는 소리는 객체 생성을 안 해도 사용할 수 있다는 소리이다.
	 * 
	 * 정적 변수 용도 대체로 
	 * 1. 상수(대표적인 예가 Math.PI) FieldMain 참조
	 * 2. 공유 횟수 쇼핑몰 상의 - 반팔, 긴팔, 나시, 상의 총 판매량 같은 경우에도 ... 느낌만 보라심?ㅋㅋㅋ
	 * 3. 리소스 나중에 DB 연결할 때 매 객체마다 DB 연결 코드를 매번 불러오기 번거로우니까 한 번만 연결시켜두면 객체가 이미 다 연결된 상태라는 거!
	 * 나중에 이런 거는 static으로 설정하면 더 편리하지 않을까 싶으면 쓰면 되는데...
	 * 쓰라고 하지 않는 이상 잘 안 쓰더라심... 헤헷
	 * static 변수는 객체를 생성하지 않아도 쓸 수 있다.
	 */
	public void method() {
		int c = 0; // 지역 변수, 그냥 우리가 알던 변수 개념
	}
}
// ====================================================================================================
package N02_정적변수;
public class FieldMain {
	public static void main(String[] args) {
		Field f1 = new Field();
		f1.a = 10;
		f1.b = 20;
		Field f2 = new Field();
		f2.a = 100;
		f2.b = 200;
		// f1.c = 50; // 에러 발생
		System.out.println("a : " + f1.a + " b : " + f1.b);
		System.out.println("a : " + f2.a + " b : " + f2.b);
		System.out.println(Math.PI); // Math 클래스 객체 생성도 안했는데 이건 왜 나올까~static 변수이기 때문! 매번 객체 생성하기 귀찮잖아. 그래서 클래스 변수!
		Field.b = 50; // 이런 식으로도 가능, 이게 되는 이유는 클래스는 실행을 하면 자동으로 올라가기 때문에 인식하고 있음
		System.out.println("a : " + f1.a + " b : " + f1.b);
	}
}
// ====================================================================================================
이제 코드를 분석하게 되면 Main을 먼저 보는 게 아니라 클래스를 먼저 보는 거임
메서드는 자주 사용하는 코드들을 일괄적으로 묶어서 사용하려고 하는 거
그러면 반복적인 부분을 매번 쓸 필요가 없는 거
나중에 코드를 수정할 때에도 메서드만 수정하면 되니까!
접근제한자(현단계에서는 public으로 고정하자) 리턴타입 메서드이름(매개 변수) {
	실행 코드
}
*매개변수는 없으면 안 넣어도 되고, 여러개이면 ,로 구분하면 됨
// ====================================================================================================
package N03_메서드;
public class Cal {
	public void hello() {
		System.out.println("계산기 프로그램입니다");
	}
	public void add(int a, int b) { 
		// 매개변수(parameter) 이름을 Main과 같이 할 필요는 없지만, 보통은 맞춰서 쓰는 편이긴 하다심
		// int a, b로 int를 생략할 수 없음!!!
		System.out.println(a+b);
	}
	public void sub(int a, int b) { 
		System.out.println(a-b);
	}
	public void mul(int a, int b) { 
		System.out.println(a*b);
	}
	public void div(int a, int b) { // double a, int b 로 하고 a/b 해도 되는 듯!
		System.out.println((double)a/b);
	}
	public void abs(int a, int b) {
		System.out.println((a>=b)? a-b : b-a);
	}
}
// ====================================================================================================
package N03_메서드;
public class CalMain {
	public static void main(String[] args) {
		Cal c = new Cal();
		c.hello();
		int a = 10, b = 20;
		c.add(a, b); // 인수, argument, 따지고 보면 여기 a, b는 값을 보내는 거임 c.add(10, 20), cal 클래스 add 매서드의 지역 변수는 다름
		c.sub(a, b);
		c.mul(a, b);
		c.div(a, b);
		c.div(a, 0);
		c.abs(a, b);
	}
}
// ====================================================================================================
package N03_메서드;
public class Cal2 {
	int a, b;
	/*
	 * main에 있는 a, b, 메서드의 매개변수 a, b는 서로 다른 거다
	 * 마찬가지로 main에 있는 a, b와 멤버변수 a, b는 전혀 상관 없는 값
	 * 나중에 메서드에서 a, b를 사용하기 위해 this라는 거를 배운다심
	 */
	public int add(int a, int b) { // 자료형을 설정하면 무조건 return이 있어야 함!
		return a+b; // 리턴이 매서드 종료를 의미함. 그래서 리턴문 아래 작성되는 코드는 절대 실행되지 않음
	}
	public int sub(int a, int b) { 
		return a-b;
	}
	public int abs(int a, int b) { 
		int result;
		if(a>b)
			result = a-b;
		else
			result = b-a;
		return result;
	}
	public int mul(int a, int b) { 
		return a*b;
	}
	public double div(int a, int b) {
		return (double)a/b;
	}
	public void showResult(int result) {
		System.out.println("result : " + result);
	}
	public void showResult(double result) { 
		/* 
		 * 매서드는 클래스나 변수와는 달리 동일한 이름 만들 수 있는데! 대신 매개변수 자료형이나 개수가 다른 걸 생성할 수 있음, 이걸 (메서드) 오버로딩이라고 함. 이거는 꽤나 중요한 용어라고 하심
		 * 메서드 오버로딩 (옛날 단골 면접질문 요즘엔 안 물어볼 걸요? 왜냐면 오버로딩이 있고 오버라이딩이 있고 ... 라심)
		 * 동일한 이름을 가진 메서드를 생성할 수 있다.
		 * 이렇게 되는 이유는 파라미터 자료형에 따라 알아서 찾아가기 때문임
		 */
		System.out.println("result : " + result);
	}
}
// ====================================================================================================
package N03_메서드;
public class Cal2Main {
	public static void main(String[] args) {
		Cal2 c = new Cal2();
		int a = 10, b = 20;
		c.add(a, b); // 출력하라는 게 아무것도 없으니 그냥 실행되고 종료됨
		c.showResult(c.add(a, b));
		c.showResult(c.sub(a, b));
		c.showResult(c.mul(a, b));
		c.showResult(c.div(a, b)); // 같은 이름의 매개변수 다른 거는 생성 가능!
		c.a = 1;
		c.b = 5;
		System.out.println("===============");
		System.out.println(c.add(a, b));
	}
}
// ====================================================================================================
/*
 * 구구단을 출력해주는 메서드를 생성
 * 클래스 이름 : Gugu
 * 메서드 이름 : showGugu
 * 메인 클래스 이름 : GuguMain
 * 메인에서 정수를 입력받으면
 * 입력받은 정수에 대한 구구단이 출력되도록 구현
 */
package N03_메서드;
public class Gugu {
	public void showGugu(int n) {
		for(int i=1; i<=9; i++)
			System.out.println(n + " * " + i + " = " + n*i);
	}
}
// ====================================================================================================
package N03_메서드;
import java.util.Scanner;
public class GuguMain {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num = sc.nextInt();
		Gugu g = new Gugu();
		g.showGugu(num);
	}
}
// ====================================================================================================
/*
 * 계산기 정수 두개와 연산기호를 입력받아 두 정수를 연산한 결과를 출력
 * 정수 입력 : 5 10
 * 연산기호 입력 : +, -, *, /, %, 그외 입력은 잘못입력함 안내
 */
package N03_메서드;
public class Cal3 {
	public void showResult(int x, int y, char op) {
		if(op=='+')
			System.out.println(x + " + " + y + " = " + (x+y));
		else if(op=='-')
			System.out.println(x + " - " + y + " = " + (x-y));
		else if(op=='*')
			System.out.println(x + " * " + y + " = " + (x*y));
		else if(op=='/')
			System.out.println(x + " / " + y + " = " + ((double)x/y));
		else if(op=='%')
			System.out.println(x + " % " + y + " = " + (x%y));
		else
			System.out.println("Wrong Operator!");
	}
}
// ====================================================================================================
package N03_메서드;
import java.util.Scanner;
public class Cal3Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("정수 입력 : ");
		int num1 = sc.nextInt();
		int num2 = sc.nextInt();
		System.out.print("연산기호 입력 : ");
		char op = sc.next().charAt(0);
		Cal3 c = new Cal3();
		c.showResult(num1, num2, op);
	}
}
// ====================================================================================================
/*
 * 사각형(Rect) 클래스를 완성하시오
 * 사각형 클래스는 가로 width, 세로 height 멤버 변수를 가지고 있음
 * 넓이를 계산하는 calArea() 메서드 구현
 * 둘레를 계산하는 calPeri() 메서드 구현
 * ============================================================
 * 메인에다 하지 말고 사각형 클래스에 하라고 하는 이유
 * 애초에 클래스는 왜 만들까? 유지보수 뭐 이런 거 다 빼고
 * 한 클래스에 연관된 정보들을 묶어서 사용하기 위함
 * 사각형 클래스라면 사각형이 가지고 있는 요소가 뭐가 있을까?
 * 가로, 세로 같은 게 있는 거지
 * 넓이나 둘레는 필수로 가지고 있을 필요는 없지만 가로 세로가 있으면 구할 수 있으니 메소드로 만들라고 한거라고 하심
 */
package N03_메서드;
public class Rect {
	int width;
	int height;
	public int calArea() {
		return width * height;
	}
	public int calPeri() {
		return 2 * (width + height);
	}
	public void showInfo() {
		System.out.println("width : " + width);
		System.out.println("height : " + height);
		System.out.println("Area : " + calArea());
		System.out.println("Peri : " + calPeri());
	}
}
// ====================================================================================================
package N03_메서드;
import java.util.Scanner;
public class RectMain {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Rect r = new Rect();
		System.out.print("가로 입력 : ");
		r.width = sc.nextInt();
		System.out.print("세로 입력 : ");
		r.height = sc.nextInt();		
		r.showInfo();
	}
}
// ====================================================================================================
/*
 * 영화관
 * 영화 티켓 예매
 * 영화 상영관은 1개! 좌석 10개
 * 영화 가격은 12,000원
 * 예매하면 가격이 나오겠죠
 * 한번에 한 좌석만 예매
 * 예매하기 계속 반복하다 종료하기
 * [1] 예매하기, [2] 종료하기 : 1
 * [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ]
 * 좌석 선택 : 3
 * [1] 예매하기, [2] 종료하기 : 1
 * [ ][ ][V][ ][ ][ ][ ][ ][ ][ ]
 * 좌석 선택 : 3
 * 예매가 불가능한 좌석입니다.
 * [1] 예매하기, [2] 종료하기 : 1
 * [ ][ ][V][ ][ ][ ][ ][ ][ ][ ]
 * 좌석 선택 : 1
 * [1] 예매하기, [2] 종료하기 : 2
 * 총 예매 가격 : 24,000원
 * 그런데 이거 말고도 전매됐을 때! 고려가 필요하지 않을까~~~!!
 */
package N03_메서드;
import java.util.Scanner;
public class Theater {
	final int tkPrice = 12000;
	final int numSeat = 3;
	boolean[] seat = new boolean[numSeat];
	int numTk; // numTk 안쓰고도 가능함~

	Scanner sc = new Scanner(System.in);
	
	public void init() {
		numTk = 0;
		for(int i=0; i<numSeat; i++)
			seat[i] = false;
		System.out.println("=====영화관 예매시스템=====");
	}
	public void ticketing() {
		System.out.print("좌석 선택 : ");
		int selSeat = sc.nextInt();
		if(seat[selSeat-1])
			System.out.println("예매가 불가능한 좌석입니다.");
		else {
			seat[selSeat-1] = true;
			showInfo();
			numTk++;
		}
	}
	public void showInfo() {
		for(int i=0; i<numSeat; i++)
			System.out.print("[" + (seat[i]? "V" : " ") + "] ");
		System.out.println();
	}
	public void totalPrice() {
		System.out.println("총 예매 가격 : " + numTk * tkPrice + "원");
	}
}
// ====================================================================================================
package N03_메서드;
import java.util.Scanner;
public class TheaterMain {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Theater cgv = new Theater();
		
		cgv.init();
		while(true) {
			if(cgv.numTk >= cgv.numSeat) {
				System.out.println("만석입니다. 추가로 예매할 수 없습니다.");
				break;
			}
			System.out.print("[1] 예매하기, [2] 종료하기 : ");
			if(sc.nextInt()==2)
				break;
			cgv.showInfo();
			cgv.ticketing();
		}
		System.out.println("=====영화관 종료=====");
		cgv.showInfo();
		cgv.totalPrice();
	}
}
// ====================================================================================================
Day0614
// ====================================================================================================
클래스의 구현 이것저것을 배울 텐데 첫시간부터 복잡한 거 하면 집에 가고 싶을 테니
하나 진도 나가고 완전 간단한 거부터 합시다.
this 아직까지는 왜 쓰는지 잘 감이 안 올 수도 있는데...
// ====================================================================================================
/*
 * s 객체를 생성
 * name, age에 값을 넣어주고 싶음
 * s.name, s.age에 넣어 주면 됐징
 * 그런데, 메인에서 이름, 나이를 입력받고 이름과 나이를 멤버변수에 저장하는 메서드를 만들고 싶으면?
 * → setName, this 설명!
 * 이름을 main으로 가져오는 메서드는 어떻게 만들까?
 * → getName
 * 나중에 이런 함수, 게터랑 세터 메소드라고 하는데 이런 걸 종강때까지 계속 자주 만든다심... 으어 이거 생각나려고 해 으어 ㅡ_ㅡ 
 * 이걸 이클립스가 자동으로 만들어 주는 것도 있음! 지금은 그것까지 볼 필요는 없다심 ... 
 * 클래스에서 멤버변수 다 설정해놓은 다음 빈공간 우클릭한 다음 거기에서 Source 선택 → 옆에서 Generate Getters and Setters로 창이 생성되면 거기서 클릭!
 * 지금은 this가 왜 필요한지가 중요한 게 아니라 어떤 역할을 하는구나 이해만 하라심
 */
package N01_this;
public class S01_sample {
	String name;
	int age;
	public void setName(String name) {
		this.name = name; // this는 자기 자신(클래스)를 의미
						  // 매개변수와 멤버변수가 구분이 안될 때 사용
						  // 접근제한자 + 캡슐화 배울 때 왜 이렇게 쓰는지 배울 예정이라심
	}
	public String getName() {
		return name;
	}
}
// ====================================================================================================
package N01_this;
public class S01_sampleMain {
	public static void main(String[] args) {
		S01_sample s = new S01_sample();
		s.setName("홍길동");
		System.out.println(s.name);
		System.out.println(s.getName());
	}
}
// ====================================================================================================
/* 
 * Car클래스 brand, model, maxSpeed를 가지고 있음
 * Car클래스를 이용해서 기능 수행
 * 1. setBrand(String brand) : 자동차 브랜드 설정
 * 2. setModel(String model) : 자동차 모델 설정
 * 3. setMaxSpeed(int maxSpeed) : 자동차 최고 속도 설정
 * 4. printInfo(): 자동차 정보를 출력
 * <결과 화면>
 * Brand: Tesla
 * Model: Model S
 * Max Speed: 250 km/h
 */
package N01_this;
public class S02_Car {
	String brand, model;
	int maxSpeed;
	public void setBrand(String brand) {
		this.brand = brand;
	}
	public void setModel(String model) {
		this.model = model;
	}
	public void setMaxSpeed(int maxSpeed) {
		this.maxSpeed = maxSpeed;
	}
	public void printInfo() {
		System.out.println("Brand: " + brand);
		System.out.println("Model: " + model);
		System.out.println("Max Speed: " + maxSpeed + " km/h");
	}
}
// ====================================================================================================
package N01_this;
public class S02_CarMain {
	public static void main(String[] args) {
		S02_Car car = new S02_Car();
		car.setBrand("Tesla");
		car.setModel("Model S");
		car.setMaxSpeed(250);
		car.printInfo();
	}
}
// ====================================================================================================
/*
 * Employee클래스는 name, salary, department를 가지고 있음
 * 1. setSalary(int salary): 연봉을 설정함, 단, 연봉은 음수 안됨
 * 2. getSalary(): 연봉을 반환함
 * 3. setDepartment(String department): 부서를 설정함
 * 4. getDepartment(): 부서를 반환함
 * 5. applyBonus(double percent): 주어진 퍼센트만큼 보너스를 직원 연봉에 적용시킴
 * 6. printInfo(): 직원의 정보를 출력
 * <실행 화면>
 * Name: John Doe
 * Salary: $55000
 * Department: IT
 */
package N01_this;
public class S03_Employee {
	String name;
	int salary;
	String department;
	public void setSalary(int salary) {
		if(salary>=0)
			this.salary = salary;
		else
			System.out.println("연봉 음수 안됨!");
	}
	public int getSalary() {
		return salary;
	}
	public void setDepartment(String department) {
		this.department = department;
	}
	public String getDepartment() {
		return department;
	}
	public void applyBonus(double percent) {
		salary = (int)(salary*(100+percent)/100);
	}
	public void printInfo() {
		System.out.println("Name: " + name);
		System.out.println("Salary: $" + salary);
		System.out.println("Department: " + department);
	}
}
// ====================================================================================================
package N01_this;
public class S03_EmployeeMain {
	public static void main(String[] args) {
		S03_Employee employee = new S03_Employee();
		employee.name = "John Doe";
		employee.setSalary(50000);
		employee.setDepartment("IT");
		employee.applyBonus(10);
		employee.printInfo();
	}
}
// ====================================================================================================
교재 185p! 정신 똑띠 차리고 들으쇼 ㄷㄷ
Call By Value: 내용에 의한 참조
Call By Reference: 주소에 의한 참조
Call By Value는 지금껏 우리가 사용해왔던 거 값을 그냥 보내서 하는 거
주소에 의한 참조를 활용하면 좀더 다양하게 프로그램을 작성할 수 있다고 하심
작동방식을 잘 이용해야 수월하게 사용할 수 있을 거라심
// ====================================================================================================
package N02_CallByValue;
public class S01_Data {
	int num;
	public void change(int num) {
		num = 1000;
		System.out.println("change메서드 호출 num : " + num);
	}
}
// ====================================================================================================
package N02_CallByValue;
public class S01_DataMain {
	public static void main(String[] args) {
		S01_Data d = new S01_Data();
		d.num = 5;
		System.out.println("num : " + d.num);
		d.change(d.num);
		System.out.println("change 호출 후 num : " + d.num); // 변동 없음!
		// 값(내용)을 보낸 거니까 자체 변수 값이 변동이 생길 일은 없음
	}
}
// ====================================================================================================
메서드의 매개변수에 일반 변수만 아니라 배열, 객체, collection 같은 것도 보낼 수 있음
// ====================================================================================================
package N03_CallByReference;
public class S01_Data {
	int num;
	public void change(S01_Data data) {
		data.num = 1000;
		System.out.println("change메서드 호출 num : " + data.num);
	}
	public S01_Data copy(S01_Data data) { // 리턴도 배열, 객체 다 가능!
		S01_Data d = data;
		
		S01_Data d2 = new S01_Data();
		d2.num = data.num;
		return d; // return d2;
	}
}
// ====================================================================================================
package N03_CallByReference;
public class S01_DataMain {
	public static void main(String[] args) {
		S01_Data data = new S01_Data();
		data.num = 5;
		System.out.println("num : " + data.num);
		data.change(data); // 아까처럼 d.num을 넣을 수 없음!
		System.out.println("change 호출 후 num : " + data.num); // 변동 있음!
		// new Data()를 실행하면 data에 주소값이 들어가는 거임 (메모리 어느 한 구석에 저장공간을 할당하는 거)
		S01_Data data2 = data; // 이렇게 하면 같은 주소값이 들어가는거지 인스턴스가 새로 생성되는 것은 아님
		System.out.println("data2.num : " + data2.num);
		S01_Data data3 = data.copy(data);
		System.out.println("data3.num : " + data3.num);
	}
}
// ====================================================================================================
일반 변수는 그안에 그냥 값이 저장되는 거 eg. int a=5;
배열, 객체 같은 거는 int[] arr, Data d는 모두 주소값이 저장되는 거임
이런 게 callbyreference인데... 이런 걸 정확히 이해하고 쓰는 사람은 많이 없는데, 신기하게 쓰기는 쓴다고 하심 ㄷㄷ
// ====================================================================================================
package N03_CallByReference;
public class S02_Student {
	int[] score = new int[3];
	public int add(int[] s) {
		return s[0]+s[1]+s[2]; 
	}
}
// ====================================================================================================
package N03_CallByReference;
public class S02_StudentMain {
	public static void main(String[] args) {
		S02_Student stu = new S02_Student();
		stu.score[0] = 80;
		stu.score[1] = 90;
		stu.score[2] = 70;
		int sum = stu.add(stu.score); // 80, 90, 70을 각각 보내주는 게 아니라 배열의 주소를 보내면 한 번에 보낼 수 있음!
		System.out.println("sum : " + sum);
	}
}
// ====================================================================================================
근데, 주소를 보내서 직접적으로 데이터를 변경하려고 사용하는 게 아니라
그냥 수많은 데이터를 한 번에 묶어서 보내는 게 편하기 때문에 사용하는 거.
그런데 하다보면 값을 변경되는 문제가 생기니까 그거를 방지하려고 개념 설명을 했던 거라심...
// ====================================================================================================
/*
 * 이름, 국어, 영어, 수학, 총점, 평균, 순위
 * 3사람의 이름~수학점수를 입력 받아~~~
 * 총점 계산 메서드
 * 평균 계산 메서드
 * 순위 계산 메서드
 * 과목별 총합계 메서드
 * 성적표 출력
 */
package N03_CallByReference;
public class S03_Person {
	String name;
	int kor, eng, math;
	int sum, rank;
	double avg;
	public void setSum() {
		sum = kor + eng + math;
	}
	public void setAvg() {
		setSum();
		avg = sum/3.0;
	}
	public void setRank(S03_Person[] people) {
		rank = 1;
		for(int i=0; i<people.length; i++) {
			if(avg < people[i].avg) {
				rank++;
			}
		}
	}
	public void showInfo() {
		System.out.printf("%s\t%3d %3d %3d %3d %.1f %3d\n", name, kor, eng, math, sum, avg, rank);
	}
}
// ====================================================================================================
package N03_CallByReference;
import java.util.Scanner;
public class S03_PersonMain {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		S03_Person[] people = new S03_Person[3];
		for(int i=0; i<people.length; i++) {
			people[i] = new S03_Person();
			System.out.print((i+1)+"번째 학생 이름 입력 : ");
			people[i].name = sc.next();
			System.out.print((i+1)+"번째 국어 점수 입력 : ");
			people[i].kor = sc.nextInt();
			System.out.print((i+1)+"번째 영어 점수 입력 : ");
			people[i].eng = sc.nextInt();
			System.out.print((i+1)+"번째 수학 점수 입력 : ");
			people[i].math = sc.nextInt();
			people[i].setSum();
			people[i].setAvg();
		}
		System.out.println("===============성적표===============");
		int korSum = 0, engSum = 0, mathSum = 0;
		for(int i=0; i<people.length; i++) {
			people[i].setRank(people);
			people[i].showInfo();
			korSum += people[i].kor;
			engSum += people[i].eng;
			mathSum += people[i].math;
		}
		System.out.println("===============과목합===============");
		System.out.printf("\t%3d %3d %3d", korSum, engSum, mathSum);
	}
}
// ====================================================================================================
지금은 클래스 1개에 Main 클래스가 있는데 나중에 되면 두개가 되고 세개가 되고 네개가 된다심 헤헷
// ====================================================================================================
/*
 * 점수들의 합계를 계산해 반환시켜주는 메서드
 * 점수들의 평균을 계산해서 반환해주는 메서드
 * 점수들의 최대값을 계산해서 반환해주는 메서드
 * 점수들의 최소값을 계산해서 반환해주는 메서드
 * 점수들을 내림차순정렬해서 반환시켜주는 메서드(원본 변형 x)
 */
package N03_CallByReference;
public class S04_Calc {
	public int calSum(int[] arr) {
		int sum = 0;
		for(int i=0; i<arr.length; i++)
			sum += arr[i];
		return sum;
	}
	public double calAvg(int[] arr) { // (int[] arr, int cnt)로도, (int sum, int cnt) 할 수 있음 
		return (double)calSum(arr)/arr.length; // 메서드에서 메서드는 자유롭게 호출 가능, Main에서 호출할 때는 인스턴스 생성 후에 호출 가능하고 인스턴스.메서드로 호출하는데 비해 같은 클래스에 있으면 인스턴스 생성 없이 그냥 메서드 이름으로만 호출가능함 
	}
	public int calMax(int[] arr) {
		int max = arr[0];
		for(int i=1; i<arr.length; i++)
			if(max < arr[i])
				max = arr[i]; 
		return max;
	}
	public int calMin(int[] arr) {
		int min = arr[0];
		for(int i=1; i<arr.length; i++)
			if(min > arr[i])
				min = arr[i]; 
		return min;
	}
	public int[] sortDec(int[] arr) {
		int[] dec = new int[arr.length];
		int tmp;
		for(int i=0; i<arr.length; i++) {
			dec[i] = arr[i]; // 초기화할 때 그냥 Arrays.copyOf(arr, arr.length) 사용할 수도 있음
			for(int j=0; j<i; j++) {
				if(dec[i]>dec[j]) {
					tmp = dec[i]; 
					dec[i] = dec[j];
					dec[j] = tmp;
				}
			}
		}
		return dec;
	}
}
// ====================================================================================================
/*
 * Main
 * 인원수를 입력받은 후
 * 인원수만큼 점수를 입력해서 저장하는 배열 생성
 */
package N03_CallByReference;
import java.util.Arrays;
import java.util.Scanner;
public class S04_CalcMain {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		S04_Calc c = new S04_Calc();
		System.out.print("인원 수 : ");
		int[] score = new int[sc.nextInt()];
		for(int i=0; i<score.length; i++) {
			System.out.print((i+1)+"번째 점수 입력 : ");
			score[i]=sc.nextInt();
		}
		System.out.println("=====결과 출력=====");
		System.out.println("Sum : " + c.calSum(score));
		System.out.printf("Avg : %.1f\n", c.calAvg(score));
		System.out.println("Max : " + c.calMax(score));
		System.out.println("Min : " + c.calMin(score));
		System.out.println("Score : " + Arrays.toString(score));
		System.out.println("ScoreDec : " + Arrays.toString(c.sortDec(score)));
	}
}
// ====================================================================================================
Day0615
// ====================================================================================================
static 이라는 거 기억하는지?
static 변수는 정적변수, 클래스변수라고 했었음
공용으로 쓰는 거...
근데 이 static이라는 게 메서드 앞에도 붙을 수 있음!!!
클래스 변수도 객체가 없이 호출가능 했듯이 static 메서드도 객체 없이 호출 가능함! 오오오오!
대표적인 것이 Arrays.toString, Arrays.copyOf (이런 거 ctrl 누르고 클릭하면 메서드 내용 확인할 수 있음!, 나중에 왔다갔다 하기 귀찮을 때 자주 사용하게 될 것임!)
자주 사용할 거 같은 거는 static으로 사용하면 편하긴 함
나중에 데이터베이스랑 자바랑 연동할 때 좀 자주 쓰게 될 거라심
// ====================================================================================================
package N01_static메서드;

public class S01_StaticMethod {
	int x;
	static int y ;
	public static void method(int a) { // static public 이런 순도 가능한데, 일반적으로 public을 더 앞에 씀
//		x = x + a; // static 메서드는 멤버변수 사용 못함
		y = y + a; // static 메서드는 static변수는 사용 가능!
		System.out.println("출력 : " + a);
	}
}
// ====================================================================================================
package N01_static메서드;

public class S01_StaticMethodMain {

	public static void main(String[] args) { // main은 JVM이 자동으로 호출해주는 거라서 우리가 만드는 메서드랑은 조금 다르다심.
		S01_StaticMethod s = new S01_StaticMethod();
		s.method(10); // 이렇게 인스턴스 메서드처럼 객체이름.메서드이름()으로 호출도 가능하지만~
		S01_StaticMethod.method(20); // 객체생성 없이 클래스이름.메서드이름()로 호출도 가능!
		// 일반 메서드(인스턴스 메서드라고 함)는 꼭 객체 생성이 필요함, 당장 눈에 보이는 차이점은 이거.
		// 상속을 배우고 오버라이딩(메서드 재정의) 개념이 나오면 또 차이가 있는데, static 메서드는 오버라이딩이 안된다고 하심
		// 눈에는 보이지 않지만 메모리 쪽에서도 클래스의 모든 인스턴스들이 메모리를 공유
		/*
		 * static메서드
		 * 클래스이름.메서드이름()
		 * 클래스의 모든 인스턴스들이 메모리를 공유
		 * 인스턴스 변수 사용 불가능, static 변수만 사용 가능
		 * 인스턴스 메서드 접근(사용) 불가
		 * 오버라이딩 불가
		 * 
		 * 인스턴스 메서드
		 * 객체이름.메서드이름()
		 * 클래스의 모든 인스턴스들이 각각 따로 할당
		 */
	}
}
// ====================================================================================================
package N02_메서드호출;

public class Sample01 {
	public void method1() {
		System.out.println("메서드1 호출");
	}
	public void method2() {
		System.out.println("메서드2 호출");
	}
	public void method3() {
		System.out.println("메서드3 호출");
	}
	public void allMethod() {
		method1();
		method2();
		method3();
	}
	// 클래스에서 객체를 생성해서 사용할 수 있을까? 당연 가능, 메인에서 사용하는 거랑 별반 다르지 않음
	
}
// ====================================================================================================
package N02_메서드호출;

public class Sample01Main {

	public static void main(String[] args) {
		Sample01 s = new Sample01();

		s.method1();
		s.method2();
		s.method3();
		
		// 1, 2, 3을 한번에 호출할 일이 반복적으로 생기면 묶어서 하나의 메서드로 생성할 수 있지 않을까 생각하는 거임
		s.allMethod();
		// 지금까지 연습한 메서드들은 여러가지 기능을 한 번에 때려넣은 것들이 많았음
		// 메서드 간 호출이 되면 메서드를 조금 더 세분화(이런 걸 모듈화 시킨다고 표현함)시켜서
		// 메서드 하나에는 하나의 기능만 할 수 있도록 하면
		// 코드를 재사용하기 편해져서 생산성이 올라간다심
	}

}
// ====================================================================================================
오버로딩 재설명, 교재 192p
오버로딩의 가장 대표적인 예는 print
매개변수가 달라져도 사용할 때 함수명을 똑같이 쓰면 함수명을 다 기억할 필요가 없으니까 편하다 
근본적인 기능은 똑같아야 함, 안 그러면 의미가 없음
// ====================================================================================================
package N03_오버로딩;

public class S01_Calc {
	public void add(int a, int b) {
		System.out.println(a+b);
	}
	public void addDouble(double a, double b) {
		System.out.println(a+b);
	}
	public void add(double a, double b) {
		System.out.println(a+b);
	}
}
// ====================================================================================================
package N03_오버로딩;

public class S01_CalcMain {

	public static void main(String[] args) {
		S01_Calc c = new S01_Calc();
		c.add(10, 20);
		c.addDouble(123.444, 555.33); // 이러면 귀찮다는 거!
		c.add(123.444, 555.33);
		// 오버로딩이 메서드 뿐만 아니라 뒤에 배울 생성자에서도 똑같다고 하심 ??? 으으으으으 
	}

}
// ====================================================================================================
생성자 교재 195p
객체를 new로 하면 알아서 만들어졌는데
생성자 때문에 그랬다는 거였음. 그래서 우리는 알 게 모르게 써왔던 거였음
생성자 이름은 클래스이름과 동일
리턴타입X
(클래스 이름과 동일한 메서드를 생성하려면 안 되는 이유가 생성자로 인식하기 때문임)
결국엔 메서드를 만드는 데 이름은 클래스이름과 동일하게 만들고 리턴타입이 없이 만들면 생성자를 만드는 거라고 생각하면 됨(리턴타입이 없는게 void가 아니라 아예 안 쓰는 거임!)
클래스가 메모리에 올라가는 순간 생성자가 없으면 java가 알아서 자동으로 생성됨
새로운 객체를 생성하는 순간 1번만 실행됨 (new)
생성자는 결국 멤버변수를 초기화할 때 사용함
// ====================================================================================================
package N04_생성자;

public class S01_Constructor {
	String name;
	int age;
	public S01_Constructor() { // 이런 게 없으면 Java가 알아서 만들어줌
		System.out.println("객체 생성");
	}
	public S01_Constructor(String name) { // 생성자의 매개변수가 있는 형태
		this.name = name;
		this.age = 18; // age = 18; 해도 되는데 명시를 해주는 편을 선호하는 듯한 분위기로 말씀하심
	}
	/*
	 * 매개변수가 있는 생성자를 만들 경우 기본 생성자가 사라지기 때문에 Java가 알아서 만들어주지 않음
	 * 필요할 경우 기본 생성자를 생성하는 코드를 작성해야 함
	 * 그렇다는 말은 생성자도 오버로딩이 됨!
	 */
	public S01_Constructor(String name, int age) { // 생성자의 매개변수가 있는 형태
		this.name = name;
		this.age = age; 
	}
	/*
	 * getter setter처럼 생성자도 자동으로 생성 가능함
	 * Generate Constructor using Fields
	 * 추가 설정이 필요한 경우는 직접 수정해야 함 eg. 출력, 지정, 계산 등
	 * 생성자는 사용하는 건 메서드랑 동일함
	 */
}
// ====================================================================================================
package N04_생성자;

public class S01_ConstructorMain {

	public static void main(String[] args) {
		S01_Constructor c = new S01_Constructor();
		S01_Constructor c1 = new S01_Constructor("홍길동");
		System.out.println(c1.name + " " + c1.age);
		S01_Constructor c2 = new S01_Constructor("복학생", 19);
		System.out.println(c2.name + " " + c2.age);
	}

}
// ====================================================================================================
// 교재 207p 연습문제 6-1, 6-2 (세트) 
package N04_생성자;

public class Test01_Student {
	String name;
	int ban, no, kor, eng, math;
	public Test01_Student(String name, int ban, int no, int kor, int eng, int math) {
		this.name = name;
		this.ban = ban;
		this.no = no;
		this.kor = kor;
		this.eng = eng;
		this.math = math;
	}
	public String info() {
		int sum = kor + eng + math;
		double avg = Math.round(sum*10/3.0)/10.0;
		String str = name + "," + ban + "," + no + "," + kor + "," + eng + "," + math + "," + sum + "," + avg; 
		return str;
	}
}
// ====================================================================================================
package N04_생성자;

public class Test01_StudentMain {

	public static void main(String[] args) {
		Test01_Student s = new Test01_Student("홍길동", 1, 1, 100, 60, 76);
		String str = s.info();
		System.out.println(str);
	}

}
// ====================================================================================================
// 교재 207p 연습문제 6-1, 6-2, 6-3 (세트) 
package N04_생성자;

public class Test01_Student {
	String name;
	int ban, no, kor, eng, math;
	public Test01_Student() {
		
	}
	public Test01_Student(String name, int ban, int no, int kor, int eng, int math) {
		this.name = name;
		this.ban = ban;
		this.no = no;
		this.kor = kor;
		this.eng = eng;
		this.math = math;
	}
	public String info() {
		int sum = kor + eng + math;
		double avg = Math.round(sum/3.0*10)/10.0;
		String str = name + "," + ban + "," + no + "," + kor + "," + eng + "," + math + "," + sum + "," + avg; 
		return str;
	}
	public int getTotal() {
		return kor + eng + math;
	}
	public float getAverage() {
		return (float) (Math.round(getTotal()/3.0*10)/10.0);
	}
}
// ====================================================================================================
package N04_생성자;

public class Test01_StudentMain {

	public static void main(String[] args) {
		Test01_Student s = new Test01_Student("홍길동", 1, 1, 100, 60, 76);
		String str = s.info();
		System.out.println(str);
	}

}
// ====================================================================================================
package N04_생성자;

public class Test02_StudentMain {

	public static void main(String[] args) {
		Test01_Student s = new Test01_Student();
		s.name = "홍길동";
		s.ban = 1;
		s.no = 1;
		s.kor = 100;
		s.eng = 60;
		s.math = 76;
		
		System.out.println("이름:" + s.name);
		System.out.println("총점:" + s.getTotal());
		System.out.println("평균:" + s.getAverage());
	}
}
// ====================================================================================================
교재 211p 연습문제 6-7: weapon, armor 설명함.
// ====================================================================================================
아이패드 주문 프로그램
1. 사용자가 공홈을 통해서 제품 구매를 한다.
2. 화면 크기 11인치와 12.9인치
3. 컬러는 스페이스그레이와 실버
4. 저장 용량은 128GB, 256GB, 512GB, 1TB
5. 네트워크는 Wi-Fi 모델과 Cellular 모델
6. 각인 서비스지원으로 이름을 입력할 수 있음
7. 일련번호는 iPad+인치+메모리+W/C+제조일+생산댓수
예) iPad11256W2201061
오늘날짜, 중간지연(쓰레드) 이런 거 할거라심
// ====================================================================================================
package N05_아이패드;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class IPad {
	int screen; // 화면 크기
	int color; // 색상, 컬러 종류가 많으면 보통은 배열로 만들고 인덱스로 뽑아오기도 한다심
	int memory; // 용량
	int network; // 네트워크
	String name; // 각인 설정 시 이름 저장
	String productDate; // 생산 일자, 객체 생성될 때 1번만 
	String serialNum; // 일련번호
	static int cnt = 0; // 생산 대수
	
	Scanner sc = new Scanner(System.in);
	
	public IPad(String name) {
		this.name = name;
		Date now = new Date(); // java.util.Date 사용
		SimpleDateFormat sdf = new SimpleDateFormat("yyMMdd");
		/*
		 * System.out.println(now); // → Thu Jun 15 14:33:40 KST 2023
		 * yyMMdd로 변경하려고 할 때 SimpleDateFormat 사용, 생성할 때 이미 형식을 지정해주넹
		 * 위의 MM의 M은 대문자인데, 분과 구분되기 위함임
		 * 둘다 import 해야 함
		 */
		productDate = sdf.format(now);
		cnt++;
	}
	
	// 제품 구입 여부 선택 메서드
	// iPad 제품 구입하기: Yes or No 선택 기능(반복구매 가능, while문 처리)
	public boolean continueOrder() {
		System.out.print("구매하시려면 yes, 아니면 no를 입력 : ");
		String isOrder = sc.next();
		if(isOrder.equalsIgnoreCase("yes")) // YES, yEs 같은 거 처리해주기 위한 메서드
			return true;
		else
			return false;
	}
	public void setScreen() {
		while(true) { // while 대신 setScreen() 재귀함수처럼 사용가능하긴 한데, return type이 void라... 보통은 return setScreen(); 그치만 재귀함수는 반복문이라는 대체제가 있기도 해서 사용빈도가 그렇게 높지 않음, 나중에 한 번 보긴 할거라심
			System.out.print("디스플레이 선텍 [1]11인치 [2]12.9인치 : ");
			screen = sc.nextInt();
			if(screen == 1 || screen == 2)
				return; // break;도 가능한데 그냥 메서드 종료해도 되니까~
			System.out.println("잘못 입력하셨습니다.");
		}
	}
	public void setColor() {
		while(true) {
			System.out.print("색상 선텍 [1]스페이스그레이 [2]실버 : ");
			color = sc.nextInt();
			if(color == 1 || color == 2)
				return;
			System.out.println("잘못 입력하셨습니다.");
		}
	}
	public void setMemory() {
		while(true) {
			System.out.print("용량 선텍 [1]128GB [2]256GB [3]512GB [4]1TB : ");
			memory = sc.nextInt();
			if(memory >= 1 && memory <= 4)
				return;
			System.out.println("잘못 입력하셨습니다.");
		}
	}
	public void setNetwork() {
		while(true) {
			System.out.print("네트워크 선텍 [1]WIFI [2]Wifi + Cellular : ");
			network = sc.nextInt();
			if(network == 1 || network == 2)
				return;
			System.out.println("잘못 입력하셨습니다.");
		}
	}
	public void setName() {
		System.out.print("각인 서비스 하시겠습니까 ? [yes/no] : ");
		String isService = sc.next(); // yes/no, on/off 같은 거 변수명을 보통 is붙여서 사용하기도 한다심
		if(isService.equalsIgnoreCase("yes")) {
			System.out.print("이름 입력 : ");
			name = sc.next();
		}
	}
	// iPad + 인치 + 메모리 + W/C + 제조일 + 생산댓수
	public void setSerialNum() {
		String screenStr = (screen == 1)? "11" : "13";
		String[] memStr = { "128", "256", "512", "1024" }; // -1 대신에 0번방에 ""를 추가해서 쓰는 거는 취향차이
		String netStr = (network == 1)? "W" : "C";
		serialNum = "iPad" + screenStr + memStr[memory-1] + netStr + productDate + cnt;
	}
	public void progress() throws Exception{
		int cnt = 0;
		while(true) {
			Thread.sleep(300); // millisecond 일시 정지 기능 메서드, 예외처리를 강요하는 놈이기 때문에 throws Exception을 넣어야 하는데 나중에 다 배울 거임 
			cnt++;
			System.out.println("제작중 입니다. [" + cnt + "%]"); // 이클립스에서는 캐리지리턴을 줄바꿈으로 처리되기 때문에 IDE의 한계로 계속 증가되는 것처럼은 못하고 계속 출력되게끔까지만 할 수 있음...
			if(cnt>=100)
				break;
		}
	}
	public void printOrder() {
		String[] scrType = { "11인치", "12.9인치" };
		String[] colType = { "스페이스그레이", "실버" };
		String[] memType = { "128GB", "256GB", "512GB", "1TB" };
		String[] netType = { "Wifi", "Wifi + Cellular" };
		System.out.println("====주문 정보 출력====");
		System.out.println("화면 크기 : " + scrType[screen-1]);
		System.out.println("제품 색상 : " + colType[color-1]);
		System.out.println("제품 용량 : " + memType[memory-1]);
		System.out.println("네트워크 : "+ netType[network-1]);
		System.out.println("이름 : " + name);
		System.out.println("일련번호 : " + serialNum);
	}
}
// ====================================================================================================
package N05_아이패드;

public class IPadMain {

	public static void main(String[] args) throws Exception {
		while(true) {
			IPad ipad = new IPad("ipad");
			if(!ipad.continueOrder())
				break;
			ipad.setScreen();
			ipad.setColor();
			ipad.setMemory();
			ipad.setNetwork();
			ipad.setName();
			ipad.setSerialNum();
			ipad.progress();
			ipad.printOrder();
		}
	}

}
// ====================================================================================================
재미있는지 ㄷㄷ 
상품 판매 라든가 계좌 관리라든가 몇 개 더 할 거라심
// ====================================================================================================
상품 판매 (관리자) 프로그램
Product (상품 클래스, 상품 정보를 나타내는 클래스)
name, price, stock
생성자를 이용해서 상품정보를 초기화
getXXX, setXXX

Inventory (상품목록들을 관리 클래스)
관리자가 판매를 하려는 상품들을 저장 (배열 이용)
판매 상품 추가 메서드
판매 상품 제거 메서드
판매중인 상품들 조회 메서드

Main
상품 판매 프로그램
장바구니에 상품추가, 상품제거, 목록 조회
// ====================================================================================================
내일 이어서
// ====================================================================================================
Day0616
// ====================================================================================================
상품판매 메서드(sellProduct)
판매된 상품 id, 수량
입력된 상품id가 어디있는지 검색 → 몇 번 배열방에 있는지
해당 배열방에 수량을 감소
<예외> 
입력된 상품이 존재하지 않음
재고보다 수량이 더 클 경우
// 예외적인 경우는 구상하면서 안 떠오를 확률이 높은데 그러면 실행시키면서 발견할 확률이 높음, 발견하는대로 고치면 됨
// ====================================================================================================
package N06_상품관리;

public class Product {
	String productId; // 나중에 DB할 때 할 건데, 바지 12,000원과 바지 8,000원을 구분하기 위해서 ItemNo 같은 거 있으면 편함
	String name;
	int price;
	int stock;
	
	public Product(String productId, String name, int price, int stock) {
		this.productId = productId;
		this.name = name;
		this.price = price;
		this.stock = stock;
	}
	public String getProductId() {
		return productId;
	}
	public String getName() {
		return name;
	}
	public int getPrice() {
		return price;
	}
	public int getStock() {
		return stock;
	}
	public void sellStock(int stock) {
		if(this.stock < stock) {
			System.out.println("*상품 재고 부족, 판매 불가");
			return;
		}
		this.stock = this.stock - stock;
		System.out.println("→ " + this.name + " " + stock + "개 판매, 판매 금액 : " + this.price*stock + "원, 남은 재고 : " + this.stock + "개");
	}
}
// ====================================================================================================
package N06_상품관리;

public class Inventory {
	Product[] products;
	int numProducts; // 상품 수, 배열을 10칸짜리를 만들었다고 해서 10개가 판매중인 건 아니기 때문에 만드는 변수
	public Inventory(int maxSize) {
		numProducts = 0;
		products = new Product[maxSize];
	}
	public boolean addPossible() {
		return (numProducts < products.length);
	}
	public void addProduct(Product p) {
		products[numProducts] = p;
		numProducts++;
		System.out.println("→ 상품 추가 완료");
	}
	public int findProductIndex(String productId) {
		for(int i=0; i<numProducts; i++) {
			if(productId.equalsIgnoreCase(products[i].getProductId())) // String도 주소값을 담고 있기 때문에 equals 사용해야 함!
				return i;
		}
		return -1;
	}
	public void sellProduct(String productId, int stock) {
		int index = findProductIndex(productId);
		if(index == -1) {
			System.out.println("*등록된 상품이 아닙니다.");
			return;
		}
		Product p = products[index];
//		if(p.stock<stock) {
//			System.out.println("*상품 재고 부족, 판매 불가");
//			return;
//		}
//		p.stock = p.stock - stock; // 이거 이렇게는 안 하고 별도로 작업이 되도록 하게 할 거라고 하심... 
//		System.out.println("→ " + p.getName() + " " + stock + "개 판매 완료, " + p.getPrice()*stock + "원");
		// 왜냐하면 이거는 인벤토리에서 구현시킬 내용이 아니라 프로덕트에서 구현할 내용이기 때문임
		// 나중에 실무하면 팀장급들이 만든 가이드라인이 있음, 틀이 갖춰져 있기 때문에 고민할 필요가 없어지는데...아무튼...
		p.sellStock(stock);
	}
	public void getAllProducts() {
		if(numProducts==0) {
			System.out.println("*현재 등록된 상품이 없습니다.");
			return;
		}
		System.out.println("[3]전체조회===============================");
		for(int i=0; i<numProducts; i++) {
			Product p = products[i];
			// 나중에는 멤버변수를 직접 호출할 수 없는 경우가 생기는데 지금은 설명하기 어렵다심...지금은 그냥 써도 되는 거고... get으로 써도 된다고 하심
			System.out.println("[" + p.productId + "] 상품명 : " + p.name + ", 가격 : " + p.price + "원, 재고 : " + p.stock + "개");
		}
		System.out.println("========================================");
	}
}
// ====================================================================================================
package N06_상품관리;

import java.util.Scanner;

public class PMain {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int maxSize = 10;
		Inventory inven = new Inventory(maxSize); // 바꾸고 싶으면 scanner 쓰면 됑, 지금은 넘어갈 거라심
		String productId;
		String name;
		int price;
		int stock;
		
		while(true) {
			System.out.print("[1]상품추가 [2]상품판매 [3]전체조회 [0]종료 : ");
			int choice = sc.nextInt();
			if(choice == 0)
				break;
			switch(choice) {
				case 1: // 판매할 상품정보 추가
					if(!inven.addPossible()) {
						System.out.println("상품을 더 이상 추가 등록할 수 없네요!");
						break;
					}
					System.out.print("추가 상품 아이디 : ");
					productId = sc.next();
					System.out.print("추가 상품명 : ");
					name = sc.next();
					System.out.print("추가 상품 가격 : ");
					price = sc.nextInt();
					System.out.print("추가 상품 재고 : ");
					stock = sc.nextInt();
					Product p = new Product(productId, name, price, stock);
					inven.addProduct(p);
					break;
				case 2:
					System.out.print("판매 상품 아이디 : ");
					productId = sc.next();
					System.out.print("판매 상품 수량 : ");
					stock = sc.nextInt();
//					Product p = new Product(productId, "", 0, stock);
//					inven.sellProduct(p);
					inven.sellProduct(productId, stock);
					
					break;
				case 3:
					inven.getAllProducts();
					break;
			}
		}
	}

}
// ====================================================================================================
나중에 이것저것 공부하고 나서 보면 굳이 이렇게 작성할 필요가 있었나 싶은 것도 있을 것임
데이터베이스 연동하고 나면 코드 좀더 간결해진다심
VO (Value Object)라는 객체는 순수 값만 가지고 있는 객체
필요한 영역동안에 값만 저장하는 용도로 사용하는 클래스들 객체들을 VO라고 하는데 위에 Product 같은 거...
뭔가 값을 보내주거나 할 때 변수의 개수가 조금 될 때 한 번에 보내기 위해 사용
// ====================================================================================================
성적관리 프로그램
*Student 클래스
studentId, name, scores
성적은 사람마다 가지고 있는 개수가 다름
생성자는 학번, 이름, 성적 개수를 초기화
성적들을 입력(추가) 메서드 - addScore
성적들의 평균을 계산하는 메서드 - avgScore
*Grade 클래스, 학생들을 관리하는 클래스
학생들을 저장하는 배열 - students
학생 수도 정해져있지 않음 - 생성자로 초기화
학생을 추가하는 +메서드 - addStudent
학생 전체 목록(학번, 이름, 평균점수) 조회하는 메서드 - getAllStudents
학번을 기준으로 검색이 되어 특정 학생을 조회 후 학번, 이름, 평균점수 출력하는 메서드 - searchStudent
학번을 입력받아 해당 학생을 삭제하는 메서드 - removeStudent
// ====================================================================================================
/*
 * Student 클래스
 * studentId, name, scores
 * 성적은 사람마다 가지고 있는 개수가 다름
 * → 몇 개의 성적을 입력? // 이거 메인에서 작업
 * 1번 방식 : 생성자는 학번, 이름, 성적 개수를 초기화
 * 2번 방식 : 학생 추가 시도할 경우 학번, 이름, 성적들을 입력받고 생성자에서는 학번, 이름, 성적 초기화 
 *    // 생성자는 학번, 이름, 성적 개수를 초기화
 * 성적들을 입력(추가) 메서드 - addScore (2번 방식이면 꼭 필요한 건 아님)
 * 성적들의 평균을 계산하는 메서드 - avgScore
 */
package N01_성적관리;

import java.util.Arrays;

public class Student {
	String studentId;
	String name;
	int[] scores;
	public Student(String studentId, String name, int[] scores) {
		this.studentId = studentId;
		this.name = name;
		this.scores = scores;
	}
	public int sumScore() {
		int sum = 0;
		for(int i=0; i<scores.length; i++) {
			sum += scores[i];
		}
		return sum;
	}
	public double avgScore() {
		return (double)sumScore()/scores.length;
	}
	public void printStudent() {
		System.out.printf("%s %s	%.1f\n", studentId, name, avgScore());
	}
}
// ====================================================================================================
/*
 * Grade 클래스, 학생들을 관리하는 클래스
 * 학생들을 저장하는 배열 - students
 * 학생 수도 정해져있지 않음 - 생성자로 초기화
 * 학생을 추가하는 메서드 - addStudent
 * 학생 전체 목록(학번, 이름, 평균점수) 조회하는 메서드 - getAllStudents
 * 학번을 기준으로 검색이 되어 특정 학생을 조회 후 학번, 이름, 평균점수 출력하는 메서드 - searchStudent
 * 학번을 입력받아 해당 학생을 삭제하는 메서드 - removeStudent
 */
package N01_성적관리;

public class Grade {
	int numStudents;
	Student[] students;
	public Grade() {
		int maxStudents = 30;
		numStudents = 0;
		students = new Student[maxStudents];
	}
	public Grade(int maxStudents) {
		numStudents = 0;
		students = new Student[maxStudents];
	}
	public boolean addPossible() {
		if(students.length <= numStudents)
			return false;
		return true;
	}
	public void addStudent(Student s) {
		if(!addPossible()) {
			System.out.println("정원 초과, 현재 학생을 추가 등록할 수 없습니다.");
			return;
		}
		students[numStudents] = s;
		numStudents++;
	}
	public void getAllStudents() {
		if(numStudents==0) {
			System.out.println("현재 등록된 학생이 없습니다.");
			return;
		}
		System.out.println("학번	 이름	평점");
		for(int i=0; i<numStudents; i++) {
			students[i].printStudent();
		}
	}
	public int searchStudentIndex(String studentId) {
		for(int i=0; i<numStudents; i++) {
			if(studentId.equalsIgnoreCase(students[i].studentId)) {
				return i;
			}
		}
		System.out.println("해당 학생이 존재하지 않습니다.");
		return -1;
	}
	public void searchStudent(String studentId) {
		int index = searchStudentIndex(studentId);
		if(index == -1)
			return;
		System.out.println("학번	 이름	평점");
		students[index].printStudent();
	}
	public void removeStudent(String studentId) {
		int index = searchStudentIndex(studentId);
		if(index == -1)
			return;
		for(int i=index; i<numStudents-1; i++)
			students[i] = students[i+1]; 
		numStudents--;
	}
}
// ====================================================================================================
package N01_성적관리;

import java.util.Scanner;

public class SMain {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("학생 성적 관리 프로그램");
		System.out.print("정원 입력 : ");
		Grade g = new Grade(sc.nextInt());
		String studentId;
		String name;
		int[] scores;
		int choice;
		
		while(true) {
			System.out.print("[1]학생추가 [2]전체조회 [3]학생조회 [4]학생제거 [0]종료 : ");
			choice = sc.nextInt();
			if(choice == 0)
				break;
			switch(choice) {
				case 1:
					if(!g.addPossible()) {
						System.out.println("정원 초과, 현재 학생을 추가 등록할 수 없습니다.");
						break;
					}
					System.out.print("학번 : ");
					studentId = sc.next();
					System.out.print("학생 이름 : ");
					name = sc.next();
					System.out.print("성적수 : ");
					scores = new int[sc.nextInt()];
					for(int i=0; i<scores.length; i++) {
						System.out.print((i+1)+"번째 과목 성적 : ");
						scores[i] = sc.nextInt();
					}
					Student s = new Student(studentId, name, scores);
					g.addStudent(s);
					break;
				case 2:
					g.getAllStudents();
					break;
				case 3:
					System.out.print("조회할 학번 : ");
					g.searchStudent(sc.next());
					break;
				case 4:
					System.out.print("제거할 학번 : ");
					g.removeStudent(sc.next());
					break;
				default:
					System.out.println("잘못 입력하셨습니다.");
			}
		}
	}
}
// ====================================================================================================
Day0619
// ====================================================================================================
성적관리 과제(특정 학생 조회 및 삭제) 지난주 이어서 설명
// ====================================================================================================
은행 계좌관리 프로그램
// ====================================================================================================
/*
 * BankAccount 계좌클래스
 * accountNumber : 계좌번호
 * ownerName : 예금주명
 * money : 잔액
 * 생성자 구현 알아서
 * 계좌에서 입금 메서드 : deposit
 * 계좌에서 출금 메서드 : withdraw
 * 비밀번호 할래? ㄴㄴ 했다 결국 ㅡㅡ
 */
package N01_은행관리;

public class BankAccount {
	String accountNumber;
	String ownerName;
	int money;
	int password;
	int numPwError;
	public BankAccount() {
		accountNumber = "";
		ownerName = "";
		money = 0;
		password = 0;
		numPwError = 0;
	}
	public BankAccount(String accountNumber, String ownerName, int money, int password) {
		this.accountNumber = accountNumber;
		this.ownerName = ownerName;
		this.money = money;
		this.password = password;
		numPwError = 0;
	}
	public String getAccountNumber() {
		return accountNumber;
	}
	public String getOwnerName() {
		return ownerName;
	}
	public int getMoney() {
		return money;
	}
	public int getPassword() {
		return password;
	}
	public void deposit(int money) {
		this.money += money;
		System.out.println(money + "원 입금완료");
	}
	public void deposit2(int money) {
		this.money += money;
	}
	public void withdraw(int money, int password) {
		if(!validPassword(password))
			return;
		if(this.money < money) {
			System.out.println("잔액부족, 출금불가");
			return;
		}
		this.money -= money;
		System.out.println(money + "원 출금완료");
	}
	public boolean withdraw2(int money, int password) {
		if(!validPassword(password))
			return false;
		if(this.money < money) {
			System.out.println("출금계좌 잔액부족, 출금불가");
			return false;
		}
		this.money -= money;
//		System.out.println(money + "원 출금완료");
		return true;
	}
	public void printAccount() {
		System.out.printf("%s  %s  %,7d원   %04d   (%d)\n", accountNumber, ownerName, money, password, numPwError);
	}
	public boolean validPassword(int password) {
		if(this.password != password) {
			System.out.println("비밀번호 오류");
			numPwError++;
			return false;
		}
		return true;
	}
	public boolean validAccount() {
		if(numPwError >= 5) {
			System.out.println("비밀번호 오류 5회이상, 은행을 방문하세요.");
			return false;
		}
		return true;
	}
}
// ====================================================================================================
/*
 * Bank 은행클래스
 * accounts 배열 : 가입된 계좌들을 저장
 * numAccounts : 가입된 전체 계좌수
 * 최대 관리 계좌수는 정해져있지 않음
 * createAccount : 신규 계좌 생성(추가)
 * closeAccount : 계좌 폐쇄(삭제)
 * deposit : 선택한 계좌에서 입금하는 메서드
 * withdraw : 선택한 계좌에서 출금하는 메서드
 * getAccountInfo : 선택한 계좌 정보 조회
 * getAllAccounts : 전체 계좌 정보 조회
 * 계좌간 송금 할래? ㄴㄴ 했다 결국 ㅡㅡ
 */
package N01_은행관리;

import java.util.Scanner;

public class Bank {
	BankAccount[] accounts;
	int numAccounts;
	Scanner sc = new Scanner(System.in);
	
	public Bank(int maxSize) {
		accounts = new BankAccount[maxSize];
		numAccounts = 0;
	}
	public boolean createPossible() {
		if(numAccounts < accounts.length)
			return true;
		return false;
	}
	public void createAccount(BankAccount account) {
//		if(!createPossible()) {
//			System.out.println("신규계좌 생성불가");
//			return;
//		}
//		int index = findAccount(account.getAccountNumber());
//		if(index != -1) {
//			System.out.println("해당 계좌번호 사용중, 신규 생성불가");
//			return;
//		}
		accounts[numAccounts++] = account;
		System.out.println("신규계좌 생성완료");
	}
	public int findAccount(String accountNumber) {
		for(int i=0; i<numAccounts; i++) {
			if(accountNumber.equalsIgnoreCase(accounts[i].getAccountNumber())) {
				return i;
			}
		}
//		System.out.println("해당입력 계좌없음");
		return -1;
	}
	public void closeAccount(String accountNumber) {
		int index = findAccount(accountNumber);
//		if(index == -1)
//			return;
		for(int i=index; i<numAccounts-1; i++)
			accounts[i] = accounts[i+1];
		numAccounts--;
		System.out.println("해당계좌 삭제완료");
	}
	public void deposit(String accountNumber, int money) {
		int index = findAccount(accountNumber);
//		if(index == -1)
//			return;
		System.out.print(accountNumber + " 계좌 ");
		accounts[index].deposit(money);
	}
	public void withdraw(String accountNumber, int money, int password) {
		int index = findAccount(accountNumber);
		if(index == -1)
			return;
		if(!accounts[index].validAccount())
			return;
		System.out.print(accountNumber + " 계좌 ");
		accounts[index].withdraw(money, password);
	}
	public void transfer(String fromAccount, String toAccount, int money, int password) {
		int indexFromAccount = findAccount(fromAccount);
		if(indexFromAccount == -1)
			return;
		if(!accounts[indexFromAccount].validAccount())
			return;
		int indexToAccount = findAccount(toAccount);
		if(indexToAccount == -1)
			return;
		if(!accounts[indexFromAccount].withdraw2(money, password))
			return;
		accounts[indexToAccount].deposit2(money);
		System.out.println("송금완료");
	}
	public void getAccountInfo(String accountNumber) {
		int index = findAccount(accountNumber);
		if(index == -1)
			return;
		accounts[index].printAccount();
	}
	public void getAllAccounts() {
		if(numAccounts == 0) {
			System.out.println("현재 등록계좌 없음");
			return;
		}
		System.out.println("===================================");
		System.out.println("no  예금주  잔액       비밀번호(오류횟수)");
		for(int i=0; i<numAccounts; i++) {
			accounts[i].printAccount();
		}
		System.out.println("===================================");
	}
	public String setAccountNumber(Boolean isNew, String msg1, String msg2) {
		String accountNumber;
		Boolean checkNew;
		while(true) {
			System.out.print(msg1 + "계좌번호 : ");
			accountNumber = sc.next();
			checkNew = (findAccount(accountNumber)==-1);
			if(checkNew == isNew)
				break;
			System.out.println(msg2);
		}
		return accountNumber;
	}
	public String setAccountNumber(String msg) {
		return setAccountNumber(false, msg, "해당입력 계좌없음, 다시 입력하세요.");
	}
	public int checkPassword(String accountNumber) {
		int password;
		int index = findAccount(accountNumber);
		while(accounts[index].validAccount()) {
			System.out.print("비밀번호 : ");
			password = sc.nextInt();
			if(accounts[index].validPassword(password))
				return password;
		}
		return -1;
	}
}
// ====================================================================================================
package N01_은행관리;

import java.util.Scanner;

public class BankMain {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
//		System.out.println("최대 계좌 수량 입력 : ");
//		int maxSize = sc.nextInt();
		int maxSize = 4; 						// 테스트용 초기 입력
		String[] fName = {"김", "이", "박"};		// 테스트용 초기 입력
		String[] Name = {"현", "수", "찬"};		// 테스트용 초기 입력
		Bank b = new Bank(maxSize);
		b.numAccounts = 3;						// 테스트용 초기 입력
		for(int i=0; i<b.numAccounts; i++) {	// 테스트용 초기 입력
			b.accounts[i] = new BankAccount();
			b.accounts[i].accountNumber = "a" + i; // 입력 귀찮 "1002-980-898-00" + i;
			b.accounts[i].ownerName = fName[(int)(Math.random()*3)] + Name[i%3] + Name[(i+1)%3];
			b.accounts[i].money = (int)(Math.random()*100)*10000;
			b.accounts[i].password = (int)(Math.random()*10000);
		}
		b.accounts[0].numPwError=4;
		System.out.println("**테스트용 초기입력");
		b.getAllAccounts();
		
		int choice = 1;
		String accountNumber, fromAccount, toAccount;
		String ownerName;
		int money;
		int password;
		while(choice != 0) { // true
			System.out.print("1.계좌생성 2.계좌삭제 3.입금 4.출금 5.계좌조회 6.전체조회 7.송금 0.종료 : ");
			choice = sc.nextInt();
			if(choice == 0) {
				break;
			}
			switch(choice) {
				case 1: // 1.계좌생성
					if(!b.createPossible()) {
						System.out.println("신규계좌 생성불가");
						break;
					}
//					System.out.print("계좌번호 : ");
//					accountNumber = sc.next(); 
					accountNumber = b.setAccountNumber(true, "신규 ", "해당 계좌번호 사용중, 신규 생성불가");
					System.out.print("예금주명 : ");
					ownerName = sc.next();
					System.out.print("password : ");
					password = sc.nextInt();
					System.out.print("money : ");
					money = sc.nextInt();
					BankAccount account = new BankAccount(accountNumber, ownerName, money, password);
					b.createAccount(account);
					break;
				case 2: // 2.계좌삭제
					accountNumber = b.setAccountNumber("삭제할 ");
					b.closeAccount(accountNumber);
					break;
				case 3: // 3.입금
					accountNumber = b.setAccountNumber("입금할 ");
					System.out.print("money : ");
					money = sc.nextInt();
					b.deposit(accountNumber, money);
					break;
				case 4: // 4.출금
					accountNumber = b.setAccountNumber("출금할 ");
//					System.out.print("password : ");
//					password = sc.nextInt();
					password = b.checkPassword(accountNumber);
					if(password == -1) {
						choice = 0;
						break;
					}
					System.out.print("money : ");
					money = sc.nextInt();
					b.withdraw(accountNumber, money, password);
					break;
				case 5: // 5.계좌조회
					accountNumber = b.setAccountNumber("조회할 ");
					b.getAccountInfo(accountNumber);
					break;
				case 6: // 6.전체조회
					b.getAllAccounts();
					break;
				case 7: // 7.송금
					fromAccount = b.setAccountNumber("송금할 ");
//					System.out.print("password : ");
//					password = sc.nextInt();
					password = b.checkPassword(fromAccount);
					if(password == -1) {
						choice = 0;
						break;
					}
					toAccount = b.setAccountNumber("송금받을 ");
					System.out.print("money : ");
					money = sc.nextInt();
					b.transfer(fromAccount, toAccount, money, password);
					break;
				default:
					System.out.println("잘못 입력하셨습니다.");
			}
		}
	}
}
// ====================================================================================================
Day0620
// ====================================================================================================
package 게임;

public class Character {

	int hp, mp;
	int x, y;
	int job;
//	int attack, defense;
//	String weapon;
//	int numHP, numMP;
	
	public Character() {
		hp = 100;
		mp = 50;
	}
	public Character(int job) {
		this.job = job;
		if(job == 1) {
			hp = 100;
			mp = 20;
		} else if(job == 2) {
			hp = 50;
			mp = 100;
		} else if(job == 3) {
			hp = 80;
			mp = 40;
		} else if(job == 4) {
			hp = 90;
			mp = 40;
		} else if(job == 5) {
			hp = 30;
			mp = 90;
		}
	}
	public Character(int hp, int mp) {
		this.hp = hp;
		this.mp = mp;
	}
	public void move(int dx, int dy) {
		x = dx;
		y = dy;
	}
}
// ====================================================================================================
package 게임;

import java.util.Arrays;

public class EnemyMap {
	int[][] isEnemy; 		// 적이 있으면 1로 만들고, 없으면 초기값 0
	Character[][] enemys; 	// isEnemy가 1이면 직업을 랜덤하게 캐릭터를 생성
	int numEnemy; 			// 현재 적의 수를 나타내는 변수, 해당 변수는 현재 사용하지는 않았지만 나중에 적의 수를 나타내주면 좋을 것 같아서 만들어둠
	
	public EnemyMap() { 	// 5-by-5에 랜덤하게 적을 분포시키는 메서드, 랜덤함수를 사용하여 0.1보다 작으면 적을 생성
		isEnemy = new int[5][5]; 		// 배열 크기 설정, 5-by-5로 초기 설정
		enemys = new Character[5][5];   // 배열 크기 설정, 5-by-5로 초기 설정
		for(int i=0; i<5; i++) {
			for(int j=0; j<5; j++) {
				if(Math.random() < 0.1) { // 10% 정도 확률로 적이 출현하도록 0.1 지정
					// if((int)(Math.random*10) == 0) 
					isEnemy[i][j] = 1;
					enemys[i][j] = new Character((int)(Math.random()*5)+1); // 직업 1~5를 선택하여 캐릭터를 생성
					numEnemy++;
				}
			}
		}
	}
	public void showEnemyMap() { // 적의 위치를 출력해주는 메서드, 테스트를 위한 히든 메뉴
		System.out.println(Arrays.deepToString(isEnemy));
	}
}
// ====================================================================================================
package 게임;

import java.util.Scanner;

public class Behavior {
	Character[] cs;
	int numChar;
	EnemyMap em;
	String[] jobArr = {"전사", "마법사", "도적", "드루이드", "치유사"};
	
	Scanner sc = new Scanner(System.in);
	public Behavior(int maxSize) {
		cs = new Character[maxSize];
		em = new EnemyMap();
	}
	public void mkChar(int job) {
		
		cs[numChar] = new Character(job);
		numChar = numChar+1;
	}
	public void mkChar(int hp, int mp) {
		cs[numChar] = new Character(hp, mp); 
		numChar = numChar+1;
	}
	
//	public void moveCharater(Character c, int x, int y) {
//		c.move(x, y);
//	}
	public void moveCharater(int index, int x, int y) {
		if(x>=0 && x<=4 && y>=0 && y<=4) {
//			cs[index].x = x;
//			cs[index].y = y;
//			Character c = cs[index];
			cs[index].move(x, y);
		}
		else {
			System.out.println("위치를 잘못 입력하셨습니다.");
		}
	}
	public void CharInfo(int index) {
		System.out.println("=========================");
		System.out.println(jobArr[cs[index].job-1] + "의 HP는 " + cs[index].hp + "이며, MP는 " + cs[index].mp + "입니다.");
		System.out.println(jobArr[cs[index].job-1] + "의 현재 위치는 " + cs[index].x + ", " + cs[index].y + "입니다.");
		System.out.println("=========================");
	}
	public void allCharInfo() {
//		System.out.println("0번 캐릭터 조회" + cs[0].hp);
//		System.out.println("1번 캐릭터 조회" + cs[1].hp);
		System.out.println("=========================");
		for(int i=0; i<numChar; i++) {
//			cs[i].charInfo();
			System.out.println(jobArr[cs[i].job-1]+ "의 HP는 " + cs[i].hp + "이며, MP는 " + cs[i].mp + "입니다.");
			System.out.println(jobArr[cs[i].job-1]+ "의 현재 위치는 " + cs[i].x + ", " + cs[i].y + "입니다.");
			System.out.println("=========================");
			
		}
	}
	public void allJobInfo() {
		System.out.println("=========================");
		for(int i=0; i<numChar; i++) {
			System.out.println(i + ". " + jobArr[cs[i].job-1] + "의 HP는 " + cs[i].hp + "이며, MP는 " + cs[i].mp + "입니다.");
		}
		System.out.println("=========================");
	}
	public int allJobInfo(String str) {
		int index;
		System.out.println("=========================");
		for(int i=0; i<numChar; i++) {
			System.out.println(i + ". " + jobArr[cs[i].job-1] + "의 HP는 " + cs[i].hp + "이며, MP는 " + cs[i].mp + "입니다.");
		}
		System.out.println("=========================");
		System.out.print(str + "캐릭터를 선택해주세요. : ");
		index = sc.nextInt();
		return index;
	}
	public void rmChar(int index) {
		if(index>=0 && index < numChar) {
			for(int i=index; i<numChar-1; i++) {
				cs[i] = cs[i+1];
			}
			numChar--;
			System.out.println("해당 캐릭터가 삭제되었습니다.");
		} else
			System.out.println("캐릭터를 잘못 선택하셨습니다.");
	}
	public void attack(int index) throws Exception{  
		if(em.isEnemy[cs[index].x][cs[index].y]==1) { // 이동했을 때 해당 위치에 적이 있는지 확인 
			System.out.print("적이 있습니다. 공격하시겠습니까? (y/n) : "); // 적이 있으면 우선 공격할 것인지 물어봐서 선택하게 함
			if(sc.next().equals("y")) { // 메서드 체이닝, 메서드가 .으로 연결되어 있을 때는 앞에서부터 시작함. sum(abs()) 이럴 때는 abs가 먼저 호출되고 sum 호출, 괄호 안쪽부터 호출됨
				Character e = em.enemys[cs[index].x][cs[index].y];
				Character c = cs[index]; 
				if(e.hp >= c.hp) { // 해당 캐릭터와 적의 hp를 비교하여 적의 hp가 높으면 캐삭, 패널티 3초 대기
					System.out.println("적이 너무 강해서 캐릭터가 죽고 말았습니다.");
					System.out.println("패널티는 3초 대기입니다.");
					Thread.sleep(3000);
					rmChar(index);
				}
				else { // 해당 캐릭터가 hp가 더 크면 적을 없앰
					System.out.println("약한 적은 제거되었습니다.");
					em.isEnemy[cs[index].x][cs[index].y] = 0;
					em.numEnemy--;
				}
			}
		}
	}
}
// ====================================================================================================
package 게임;

import java.util.Scanner;

public class CharMain {

	public static void main(String[] args) throws Exception {
		
		Scanner sc = new Scanner(System.in);
		System.out.println("소환사의 협곡에 오신 여러분을 진심으로 환영합니다.");
		
		System.out.print("캐릭터 최대 수 입력 : ");
		int maxSize = sc.nextInt();
		
		Behavior b = new Behavior(maxSize);
		
		
		while(true) {
			System.out.print("1. 캐릭터생성 2. 캐릭터이동 3. 특정 캐릭터 조회 4. 전체조회 5. 캐릭터삭제 0. 게임종료 : ");
			int menu = sc.nextInt();
			if(menu == 0)
				break;
			else if(menu == 1){
				if(b.numChar == maxSize) {
					System.out.println("★★생성하실 수 있는 캐릭터 수가 초과되었습니다. 다음에 다시 이용해주세요.★★");
					continue;
				}
				System.out.println("생성하실 캐릭터의 직업을 선택해주세요. ");
				System.out.print("1. 전사 2. 마법사 3. 도적 4. 드루이드 5. 치유사 : ");
				int job = sc.nextInt();
				b.mkChar(job); 
			}else if(menu == 2){
//				b.allJobInfo();
//				System.out.print("캐릭터를 선택해주세요. : ");
//				int index = sc.nextInt();
				int index = b.allJobInfo("");
				System.out.print("X 위치를 입력해주세요. : ");
				int x = sc.nextInt();
				System.out.print("Y 위치를 입력해주세요. : ");
				int y = sc.nextInt();
				b.moveCharater(index, x, y);
				b.attack(index);		// 이동 후 적이 있으면 공격하게 함, 적이 없으면 자동적으로 실행되는 내용이 없음.
			} else if(menu == 3){
//				System.out.print("확인 하실 캐릭터를 입력해주세요 : ");
//				b.CharInfo(sc.nextInt());
				int index = b.allJobInfo("확인하실 ");
				b.CharInfo(index);
			}else if(menu == 4){
				b.allCharInfo();
			}else if(menu == 5){
				if(b.numChar == 0) {
					System.out.println("생성된 캐릭터가 존재하지 않습니다.");
					continue;
				}
				
//				b.allJobInfo();
//				System.out.print("삭제하실 캐릭터를 선택해주세요 : ");
//				int index = sc.nextInt();
				int index = b.allJobInfo("삭제하실 "); // 같은문장임
				b.rmChar(index);
			}else if(menu == 6){
				b.em.showEnemyMap();
			}
			
		}
	}
}
// ====================================================================================================
Day0621
// ====================================================================================================
상수 변수사용할 때 변수명은 all UPPERCASE로 설정하자. final int cost = 1900; 보다는 final int COST = 1900; 흠. 이거 아무리 들어도 익숙해지지 않는군. 볼 땐 아... 하는데ㅋㅋㅋ
// ====================================================================================================
/*
 * 변수
 * int a;
 * 정수 1개만 담을 수 있다.
 * 여럭 개의 값을 담도록 한 것이 배열
 * int[] a = new int[6];
 * 배열은 1가지 자료형으로 고정된다.
 * 여러 가지 자료형과 여러 개의 값을 담도록 한 것이 클래스
 * 해당 클래스에 관련된 값만 모아두는 게 관리에 수월함
 */
package N01_복습;

public class Sample01 {
	int a;
	double b;
	boolean c;
	String d;
	int[] arr = new int[5];
//	Student a = new Student(); // Student라는 클래스가 있다고 가정하자
	static int e; // 클래스변수, 모든 객체가 동일한 값을 공유해서 가지면서, 객체 생성 없이도 클래스명으로 호출할 수 있는 변수
	
	public Sample01() {
		/*
		 * 기본생성자, 없어도 자바가 알아서 만들어준다.
		 * 생성자 오버로딩 가능
		 * 생성할 때 한 번만 딱 실행
		 */
	}
	public Sample01(int a) {
		this.a = a;
	}
	public int 메서드이름() {
		return 10;
	}
	public int 메서드이름1() {
		return 메서드이름();
	}
	// 재귀함수
	public int fact(int n) {
		if(n==1)
			return 1;
		return n*fact(n-1);
	}
}
// ====================================================================================================
package N01_복습;

//import java.util.Arrays;

public class Sample02 {

	public static void main(String[] args) {
		int[] arr = {1, 2, 3};
//		System.out.println(arr + " : " + Arrays.toString(arr));
//		arr = new int[]{4, 5, 6};
//		System.out.println(arr + " : " + Arrays.toString(arr));
		/*
		 * 레퍼런스 변수
		 * 배열, 객체 주소값을 가리키고 있는 상태 
		 * 얕은 복사 vs 깊은 복사 // 배열이나 객체를 사용할 때는 연결시켜서 사용할 것인지 내용이 독립적으로 포함되어야 하는지 염두 필요
		 */
		Sample01[] s = new Sample01[6];
		for(int i=0; i<s.length; i++) {
			s[i] = new Sample01();
		}
	}
}
// ====================================================================================================
드디어 진도...
222p 상속
부모클래스가 자식클래스한테 상속, 변수나 메서드나 생성자...
Child → Parent
화살표 방향에 대하여...
계속 작업을 하다가 비슷한 클래스를 여러개 생성
공통적으로 하나를 묶어서 관리하려다 보니

전자제품

TV  컴퓨터 냉장고 전자렌지 에어컨
전원 전원	  전원  전원    전원
채널 인터넷  냉동  타이머  온도
전원은 동일함 (부모, 조상)
각각 클래스는 (자식, 자손)
// ====================================================================================================
package N02_상속;

public class S01_Parent {
	String firstName;
	int money = 100;
	public S01_Parent() {
		System.out.println("부모 생성자 생성");
		firstName = "이";
	}
	public S01_Parent(int money) {
		System.out.println("부모 생성자 생성1");
		firstName = "이";
	}
	public void method() {
		System.out.println("hello" + firstName);
	}
}
// ====================================================================================================
package N02_상속;

public class S01_Child extends S01_Parent{ // 자식클래스 이름 뒤에 extends 부모클래스이름 자식 클래스가 부모 클래스에 있는 것을 상속받을 거다라고 알려줌!
//	String firstName;
//	int money;
	int age; // 상속 받은 거 외에 추가로 구현할 수 있다. 당연히
	public S01_Child() {
//		S01_Parent(100);
		super(100);
		System.out.println("자식 생성자 생성");
		firstName = "김";
	}
	public void method2() {
		method();
	}
}
// ====================================================================================================
package N02_상속;

public class S01_Main {
	public static void main(String[] args) {
		S01_Parent p = new S01_Parent();
		System.out.println("1");
		S01_Child c = new S01_Child();
		System.out.println("2");
//		p.firstName = "김";
//		System.out.println(p.firstName);
//		c.firstName = "박";
//		System.out.println(c.firstName);
//		c.age = 10; // p.age는 사용 불가, 물려받는 것은 일방적인 것임!
//		p.method();
//		c.method();
//		c.method2();
		// 결론적으로 부모클래스보다 자식클래스의 기능이 무조건 같거나 많다!
		System.out.println(c.firstName); // 생성자도 상속이 되기 때문에 부모에서 값을 지정해줬으면 자식에서도 동일한 값으로 지정됨
		// 생성자도 물려준다!
		// 부모생성자를 먼저 실행시킨 다음 자식생성자를 실행시킴(눈에 안 보이지만 내부적으로는 부모클래스의 기본생성자로 부모 인스턴스가 만들어진 것임)
		// 부모클래스의 생성자는 상속되지 않음. 나중에는 따로 호출하는 방법을 쓸 거라고 하심??? super 봤던 거 같기도 하다 ㅡㅡ
		// 부모클래스에 생성자를 추가 했을 때 기본생성자가 없으면?? 에러 나온다. 추가된 부모클래스의 생성자를 호출하려면 super(parameter);
		System.out.println(c.money);
	}
}
// ====================================================================================================
java.lang.Object  228p
모든 클래스는 Object 클래스를 상속받음
java에 있는 최상위 클래스
equals 같은 거 구현되어 있음
엄밀히 말하면 클래스명 뒤에 extends Object가 생략되어 있는 것임
// ====================================================================================================
// 224p 예제
package N02_상속;

public class S02_Tv {
	boolean power;
	int channel;
	public void power() {
		power = !power;
	}
	public void channelUp() {
		channel++;
	}
	public void channelDown() {
		channel--;
	}
}
// ====================================================================================================
package N02_상속;

public class S02_SmartTv extends S02_Tv{
	boolean caption;
	public void displayCaption(String text) {
		if(caption)
			System.out.println(text);
	}
}
// ====================================================================================================
package N02_상속;

public class S02_TvMain {

	public static void main(String[] args) {
		S02_SmartTv stv = new S02_SmartTv();
		stv.channel = 10;
		stv.channelUp();
		System.out.println(stv.channel);
		stv.displayCaption("hello1");
		stv.caption = true;
		stv.displayCaption("hello2");
	}

}
// ====================================================================================================
자바는 다중상속 안됨! 부모는 오로지 1클래스!!!
왜 막아놨느냐면은...

학생
이름
성별
나이

고등학생	대학생	학생 클래스를 상속받는 두 클래스
교복여부	학점
수능

직장인(직원)
고등학교 졸업하고 취업한 직원과 대학교 졸업하고 취업한 직원을 관리하고 싶을 때
둘다 상속이 가능하게 한다고 하면
직장인.이름
어떤 이름을 쓸 건지 다 설정해줘야 함. 다중상속에서 C++에서는 그렇게 해야 하나봄
아무튼 에러가 심하니까 다 필요없고 자바에서는 다중상속이 안된다(extends 고등학생, 대학생 ㄴㄴ라는 거!)만 기억하면 됨!

그래도 다중상속 기능을 보완해주기 위해서 추가 기능이 있음 인터페이스라든가...
// ====================================================================================================
Day0622
// ====================================================================================================
오전 평가부터 시작
// ====================================================================================================
package 평가;

import java.util.Scanner;

public class Mon1 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("점수를 입력하시오 : ");
		int score = sc.nextInt();
		
		System.out.println();
		System.out.println("[ 연산 결과 ]");
		if(score>=90)
			System.out.println("당신의 점수는 " + score + "점이며, A학점입니다.");
		else if(score>=80)
			System.out.println("당신의 점수는 " + score + "점이며, B학점입니다.");
		else if(score>=70)
			System.out.println("당신의 점수는 " + score + "점이며, C학점입니다.");
		else if(score>=60)
			System.out.println("당신의 점수는 " + score + "점이며, D학점입니다.");
		else
			System.out.println("당신의 점수는 " + score + "점이며, F학점입니다.");
		
	}

}
// ====================================================================================================
package 평가;

public class MathEx {
	// 점수 range 0~100점 전제함
	// max==-1 이거나 min==101이면 전달해준 배열의 길이가 0이거나 점수가 잘못 입력된 상황임
	public int max(int[] arr) {
		int max = -1;
		for(int i=0; i<arr.length; i++) {
			if(max < arr[i])
				max = arr[i];
		}
		return max;
	}
	public int min(int[] arr) {
		int min = 101;
		for(int i=0; i<arr.length; i++) {
			if(min > arr[i])
				min = arr[i];
		}
		return min;
	}
}
// ====================================================================================================
package 평가;

public class Mon2 {

	public static void main(String[] args) {
		
		int[] scores = {90, 80, 67, 100, 89, 76, 56, 78, 88, 95}; // 훈련생의 점수를 기억하는 배열 
		MathEx m = new MathEx();		// MathEx 객체 생성
		int max = m.max(scores);		// 최고점수 구하는 메서드 호출 
		int min = m.min(scores);		// 최저점수 구하는 메서드 호출
		
		System.out.println("[실행 결과]\n");
		System.out.println("최대값 : "+max);
		System.out.println("최소값 : "+min);
	}

}
// ====================================================================================================
232p
자바에서 this는 나자신이었다면 super는 부모를 가르키는 거다.
Child class 만들때 창에서 Parent 입력해주면 extends 안 써줘도 됨
당연히 상속을 받아야 super 쓸 수 있는 거.
this든 super든 멤버변수뿐만 아니라 메서드 호출도 가능
사용할 일은 흔치 않지만 된다는 것정도는 알아둬야 함.
this()도 생각해보니 생성자 ㄷㄷ super()도 생성자(of 부모)
// ====================================================================================================
package N01_super;

public class Parent {
	int a = 20;
	public Parent() {
		System.out.println("Parent Cons!");
	}
	public void show() {
		System.out.println("Parent class!");
	}
}
// ====================================================================================================
package N01_super;

public class Child extends Parent {
	int a = 10;
	
	public Child() {
		// super(); 직접 기입하지 않아도, 자동으로 생성
		System.out.println("Child Cons!");
	}
	public void show() {
		System.out.println("Child class!");
	}
	public void show(int a) {
		System.out.println("parameter a : " + a);
		System.out.println("child     a : " + this.a);
		System.out.println("parent    a : " + super.a);
	}
	public void re() {
		System.out.println("===구분선1===");
		this.show();
		System.out.println("===구분선2===");
		super.show();
		System.out.println("===구분선3===");
		show(); // 동일 클래스는 this. 생략 가능
	}
}
// ====================================================================================================
package N01_super;

public class Main {

	public static void main(String[] args) {
		Child c = new Child();
		c.show(0);
		c.re();
	}

}
// ====================================================================================================
package N01_super;

public class Parent {
	String name;
	int age;
	
	public Parent(String name, int age) {
		this.name = name;
		this.age = age;
	}
}
// ====================================================================================================
package N01_super;

public class Child extends Parent {
	String gender;
	public Child(String name, int age, String gender) {
//		super();
//		this.name = name;
//		this.age = age;
		super(name, age);
		this.gender = gender;
	}
}
// ====================================================================================================
229p 오버라이딩 - 메서드 재정의
새롭게 정의한다~
cf. 오버로딩: 동일 클래스에서 같은 이름을 가졌지만 매개변수가 다른 메서드, 보통 기능을 같이 함
오버라이딩 // 주로 상속 상황에서 발생
- 상속을 받은 부모/자식 클래스에 같은 이름을 가진 메서드
(- 매개변수까지 같은데, 클래스가 다른 거지...//리턴타입은 달라도 처리는 가능합니다만... 일단은 리턴타입이 같은 걸로 기억하자고 하심. 자동형변환되는 범주까지 가능한 가봄)
- 처리하는 코드가 다름
하나의 메서드 명으로 객체에 따라 사용하는 거로 생각하면 됨
지금은 메서드 명을 달리해서 그냥 쓰면 되는 거 아니냐 생각할 수도 있지만
나중에 배울 다형성, 인터페이스나 추상 메서드 쪽으로 넘어가면 또 의미가 있다심
말보다는 만들면서 구경!
오버라이딩도 자동 생성 기능이 있음
우클릭 source Override method ㅋㅋㅋㅋ
Object에 있는 메서드도 가능함~~ 지금은 그럴 단계는 아니지만 훗
이클립스에서 자동으로 생성하면 @Override Annotation이 생김
코드에 영향을 주지는 않고, 실행시켰을 때 
체크하는 과정이 있는데 어노테이션 붙여놓은 게 있으면 자바가 체크 안하고 그냥 실행시킨다는 거.
어노테이션 공부할 때 다시 보도록 합시다.
주석이랑은 다름. 주석은 개발자들이 이해를 위한 메세지, 어노테이션은 컴퓨터(자바)를 위한 메세지
230p의 내용은... 
(선언부가 조상 클래스의 메서드와 일치해야 한다. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.)
지금 봐도 뭔 내용인지 모를거.
접근제한자 공부하고 나서 정리할 거.

final이라는 키워드가 바꿀 수 없게 막아놓은 거
변수에도 붙일 수 있지만 메서드에도 붙일 수 없다.
변경이 불가능한 메서드!
final 메서드도 오버라이딩 불가!!!
static도 마찬가지로 클래스 자체에 대한 것이므로 오버라이딩 불가!!!

Object클래스의 toString()은 패키지,클래스 이름@16진수 주소
이거를 오버라이딩해서 자동 생성시키면, 멤버변수를 줄줄이 출력시켜주는 메서드 생성해줌
우왕 굳!
// ====================================================================================================
package N02_overriding;

public class Parent {
	int age;
	public void showInfo(int age) {
		System.out.println("부모 나이 : " + age);
	}

}
// ====================================================================================================
package N02_overriding;

public class Child extends Parent {

	@Override
	public void showInfo(int age) {
		System.out.println("자식 나이 : " + age);
	}
	
}
// ====================================================================================================
package N02_overriding;

public class Main {

	public static void main(String[] args) {
		Parent p = new Parent();
		Child c = new Child();
		p.showInfo(30);
		c.showInfo(10); // 
	}

}
// ====================================================================================================
package N02_overriding;

public class S02_Book {
	String title;
	String author;
	int price;
	
	public S02_Book(String title, String author) {
		this.title = title;
		this.author = author;
		this.price = 10000;
	}
	public void showInfo() {
		System.out.println("책이름 : " + title + "\n저자 : " + author);
	}
	// showInfo() 대신에 멤버변수 출력 메서드 자동 생성!
	@Override
	public String toString() {
		return "Book [title=" + title + ", author=" + author + "]";
	}
	public void showPrice() {
		System.out.println("책이름 : " + title + "\n가격 : " + price);
	}
}
// ====================================================================================================
package N02_overriding;

public class S02_Novel extends S02_Book {
	String genre;

	public S02_Novel(String title, String author, String genre) {
		super(title, author);
		this.genre = genre;
	}

	@Override
	public void showInfo() {
		System.out.println("Novel showInfo");
		super.showInfo();
		System.out.println("장르 : " + genre);
	}

	@Override
	public String toString() {
		return "Novel [title=" + title + ", author=" + author + ", genre=" + genre + "]";
	}

	@Override
	public void showPrice() {
		System.out.println("책이름 : " + title + "\n가격 : " + (int)(price*0.9));
	}
	
}
// ====================================================================================================
package N02_overriding;

public class S02_Cartoon extends S02_Book {
	int pages;

	public S02_Cartoon(String title, String author, int page) {
		super(title, author);
		this.pages = pages;
	}

	@Override
	public void showInfo() {
		System.out.println("Cartoon showInfo");
		super.showInfo();
		System.out.println("페이지수 : " + pages);
	}

	@Override
	public String toString() {
		return "Cartoon [title=" + title + ", author=" + author + ", pages=" + pages + "]";
	}

	@Override
	public void showPrice() {
		System.out.println("책이름 : " + title + "\n가격 : " + (int)(price*0.8));
	}
	
}
// ====================================================================================================
package N02_overriding;

public class S02_BookMain {

	public static void main(String[] args) {
		S02_Book b = new S02_Book("Java의 정석", "남궁성");
		S02_Novel n = new S02_Novel("홍길동전", "허균", "고전소설");
		S02_Cartoon c = new S02_Cartoon("원피스", "오다 에이치로", 350);
		System.out.println("구분선 0 ========================================");
		System.out.println(b.title + "	" + b.author);
		System.out.println(n.title + "		" + n.author + "		" + n.genre);
		System.out.println(c.title + "		" + c.author + "	" + c.pages);
		System.out.println("구분선 1 ========================================");
		b.showInfo();
		n.showInfo();
		c.showInfo();
		System.out.println("구분선 2 ========================================");
		System.out.println(b.toString());
		System.out.println(n.toString());
		System.out.println(c.toString());
		System.out.println("구분선 3 ========================================");
		b.showPrice();
		n.showPrice();
		c.showPrice(); // 그러면 c에서 Book의 showPrice는 아예 못 호출하게 되는 ... ???
		System.out.println("구분선 4 ========================================");
		
	}

}
// ====================================================================================================
코딩테스트 연습할 수 있는 사이트 프로그래머스, 백준??
백준은 로그인해야 할껄? 여긴 패스ㅋㅋ 예전에 오일러 프로젝트...보다는 수준이 많이 올라갔겠지?
근데 알고보니 프로그래머스도 가입해야 했음 ㅡ_ㅡ
// ====================================================================================================
/*
 * Animal 클래스
 * 생성자로 name을 초기화할 수 있도록 구현
 */
package N02_overriding;

public class S03_Animal {
	String name;
	int age;
	
	public S03_Animal(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public int getAge() {
		return age;
	}
	
}
// ====================================================================================================
package N02_overriding;

public class S03_Dog extends S03_Animal {
	String breed;

	public S03_Dog(String name, String breed) {
		super(name);
		this.breed = breed;
	}
	
	public void showBreed() {
		System.out.println(name + " " + breed);
	}

	@Override
	public int getAge() {
//		return 5*age;
		return 31 + (int) (16*Math.log(age));
	}

}
// ====================================================================================================
package N02_overriding;

public class S03_Cat extends S03_Animal {
	String color;
	
	public S03_Cat(String name, String color) {
		super(name);
		this.color = color;
	}

	public void showColor() {
		System.out.println(name + " " + color);
	}
	
	@Override
	public int getAge() {
//		return 6*age;
		if(age==1)
			return 15;
		else
			return 16+4*age;
	}
}
// ====================================================================================================
package N02_overriding;

import java.util.Scanner;

public class S03_AnimalMain {

	public static void main(String[] args) {
		S03_Dog d = new S03_Dog("멍멍이", "잡스");
		S03_Cat c = new S03_Cat("냐옹이", "고등어");
		d.showBreed();
		c.showColor();
		
		Scanner sc = new Scanner(System.in);
		System.out.print(d.name + " 나이 입력 : ");
		d.setAge(sc.nextInt());
		System.out.print(c.name + " 나이 입력 : ");
		c.setAge(sc.nextInt());
		System.out.println("Dog : " + d.age);
		System.out.println("Cat : " + c.age);
		
		System.out.println(d.name + " 나이 " + d.age + "는 사람 나이로 "+ d.getAge() + "입니다.");
		System.out.println(c.name + " 나이 " + c.age + "는 사람 나이로 "+ c.getAge() + "입니다.");
	}

}
// ====================================================================================================
/*
 * 게임 상 존재하는 여러 직업들(기사, 법사, 힐러)
 * GameJob 클래스
 * int hp; 체력
 * int mp; 마나
 * 체력과 마나를 초기화시켜주는 생성자
 * attack 메서드
 * "기본 공격 시도"라는 문구를 출력
 */
package N02_overriding;

public class S04_GameJob {
	int hp, mp;

	public S04_GameJob(int hp, int mp) {
		this.hp = hp;
		this.mp = mp;
	}
	
	public void attack() {
		System.out.println("기본 공격 시도");
	}
	
	public void showInfo() {
		System.out.print("hp : " + hp + " / mp : " + mp);
	}
}
// ====================================================================================================
/*
 * Knight 클래스 (GameJob 클래스를 상속받음)
 * int armor (방어력)
 * 방어력까지 초기화 시켜주는 생성자
 * attack 메서드
 * "방패 후리기 공격" 문구 출력
 */
package N02_overriding;

public class S04_Knight extends S04_GameJob {
	int armor;

	public S04_Knight(int hp, int mp, int armor) {
		super(hp, mp);
		this.armor = armor;
	}
	public void attack() {
		System.out.println("방패 후리기 공격");
	}
	public void showInfo() {
		System.out.print("showInfo() : Knight / ");
		super.showInfo();
		System.out.println(" / armor : " + armor);
	}
}
// ====================================================================================================
/*
 * Mage 클래스 (GameJob 클래스를 상속받음)
 * String skill (스킬)
 * 스킬까지 초기화 시켜주는 생성자
 * attack 메서드
 * "xxx 스킬 공격" 문구 출력
 */
package N02_overriding;

public class S04_Mage extends S04_GameJob {
	String skill;
	public S04_Mage(int hp, int mp, String skill) {
		super(hp, mp);
		this.skill = skill;
	}
	public void attack() {
		System.out.println(skill + " 스킬 공격");
	}
	public void showInfo() {
		System.out.print("showInfo() : Mage / ");
		super.showInfo();
		System.out.println(" / skill : " + skill);
	}
}
// ====================================================================================================
/*
 * Main 클래스
 * Knight 객체, Mage 객체 생성
 * 각각 정보 출력, attack 호출
 */
package N02_overriding;

public class S04_GameMain {

	public static void main(String[] args) {
		S04_Knight k = new S04_Knight(100, 50, 200);
		S04_Mage m = new S04_Mage(50, 100, "스톤");
		System.out.println("Knight hp/mp/armor : " + k.hp + "/" + k.mp + "/" + k.armor);
		k.showInfo();
		k.attack();
		System.out.println("Mage   hp/mp/skill : " + m.hp + "/" + m.mp + "/" + m.skill);
		m.showInfo();
		m.attack();
	}

}
// ====================================================================================================
243p 접근제어자
우리가 계속 뭔지 모르고 썼던 public
메서드, 생성자, 클래스, 멤버 변수에 붙일 수 있음
종류는 4가지! public, private, default, protected
어디서는 쓸 수 있고 어디서는 쓸 수 없게 제한을 거는...
패키지도 같냐 다르냐도 영향이 있기 때문에...패키지도 우선 2개 생성함 
지역변수는 못 붙임!
클래스변수에서 아무것도 안 썼으면 default라고 생각하면 됨!
public : 어디서든 다 접근 가능
private : 동일 클래스 내에서만 접근 가능
protected : 
default : (friendly라고도 함)
private으로 설정된 클래스변수는 직접적으로 접근할 수는 없지만

private이랑 protected는 클래스에는 지정하지 못함.

// 게터와 세터를 호출하는 사람이 다르면 목적 달성 가능할지도...
// 근데 private 생성자가 의미가 있나???
// ====================================================================================================
package N03_접근제어자01;

public class Animal {
	private String name;
	int age;
	Animal() {
		this.name = "나비";
		this.age = 5;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
}
// ====================================================================================================
package N03_접근제어자01;

public class Main {

	public static void main(String[] args) {
		Animal a = new Animal();
//		System.out.println(a.name); // name을 private으로 설정했기 때문에 에러!
		System.out.println(a.age);
		System.out.println(a.getName()); // 캡슐화의 기본 형태, 지금 뭐 캡슐화까지는 됐고, private이 어떻게 막아버렸는지만 기억하라심
//		a.name = "야옹이"; // 이것도 못해!
		a.setName("야옹이"); // setName은 public으로 설정되어 있기 때문에 접근 가능
		/*
		 * 게터와 세터는 왜 쓸까?
		 * 직빵으로 a.name
		 * 보안! 정보 은닉 목적
		 * 캡슐화 - 정보 은닉
		 * 알약에서 껍데기는 약이 아니잖아요 ㄷㄷ 껍데기가 메서드가 된거고 실제 내용물, 이게 변수명이 뭐고 등등은 모른다는 거
		 * 별 특별한 이유 없으면 클래스 변수는 다 private으로 작업한다. 
		 */
	}

}
// ====================================================================================================
Day0623
// ====================================================================================================
접근제한자 : 클래스, 메서드, 멤버변수, 생성자에 넣을 수 있음
*클래스에는 private랑 protected는 못 넣음!
public : 어디서든 다 접근 가능
private : 동일 클래스 내에서만 접근 가능
protected : 동일한 패키지, 자식클래스 접근 가능
default : 동일한 패키지에서 접근 가능 (friendly라고도 함) 아무것도 안쓰면 default임.

어제만든 0622 package N03_접근제어자01;에서 이어서 설명
일반적으로는 public이나 private 정도만... protected나 default를 의식적으로 쓰는 일은 드물다심
// ====================================================================================================
package N03_접근제어자01;

public class Animal {
//	private String name;
	protected String name;
//	int age;
	protected int age;
//	Animal(){ // Animal(), public 안 붙이면 default로 설정된 거라 다른 패키지에서 설정이 안됨.
	public Animal() { 
		this.name = "나비";
		this.age = 5;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
}
// ====================================================================================================
package N04_접근제어자02;

import N03_접근제어자01.Animal; // 다른 패키지에 있는 클래스 가져올 때는 Scanner처럼 import 해줘야 함!

public class Main {

	public static void main(String[] args) {
//		Animal a = new Animal(); // 생성자가 default로 설정되어 있어서 new Animal();은 다른 패키지에서 사용 못함. 사용하려면 생성자를 public으로 설정해야 함.
	}

}
// ====================================================================================================
package N04_접근제어자02;

import N03_접근제어자01.Animal;

public class ProtectedTest extends Animal {
	public void test() {
		name = "멍멍이"; // 다른 패키지의 protected 변수도 상속하면 사용 가능  
	}
}
// ====================================================================================================
244p
객체지향의 4가지 특성
상속
캡슐화 - 객체의 상태랑 동작을 묶어서 관리함, 재사용성, 유지보수에 효율이 높아짐
다형성
추상화
캡슐화의 대표적인 예 setter
접근 제어 : 멤버변수를 private으로 설정, 외부에서 접근을 못하도록 제한(사전 차단)
		  수정이나 접근을 하도록 메서드로 구현(제한된 방법으로 사용) 잘못된 조작을 방지 (유효성 검사)
정보 은닉 : 데이터(멤버 변수) 숨김
모듈화(코드 재사용성), 유지보수 효율 : 그냥 공통적인 특징
		  
private로 설정한 변수는 set, get 메서드는 세트로 생각하는 게 좋다심. 구현하는 거에 따라서는 set이 없거나 get이 없을 수는 있음
set, get이 없는 private 변수는 아예 사용할 수 없는 거라... 굳이 있어야 하는 이유가 없다.
세터, 게터는 관습...안 지키면 뭐라하거나 의도를 물어볼 거라심... 걍 지키라심ㅋㅋㅋ
세터가 필요 없는 경우는 생성자로 값을 지정한 다음, 값을 고정시키고 싶을 때임
게터의 경우는 설정은 해도 되지만 현재값을 보여주고 싶지 않을 때겠지?ㅎ
// ====================================================================================================
package N01_캡슐화;

import java.util.Scanner;

public class S01_Person {
	String name;
	private int age; // 변수는 어지간하면 private으로 설정해둠
	Scanner sc = new Scanner(System.in);
	
	public void setAge() {
		System.out.print("나이 입력 : ");
		int age = sc.nextInt();
		setAge(age);
	}
	public void setAge(int age) {
		if(age>=1 && age<=100)
			this.age = age;
		else
			System.out.println("잘못 입력하셨습니다.");
		
//		System.out.println(this.age); 기능별로 나눠서 하는 것을 권장, 하나의 메서드에는 하나의 기능만 담자!
	}
	public int getAge() {
		return age;
	}
	
//	public void getSum(Person p1, Person p2, Person p3) {
//		System.out.println(p1.age+p2.age+p3.age);
//	}
}
// ====================================================================================================
package N01_캡슐화;

import java.util.Scanner;

public class S01_Main {

	public static void main(String[] args) {
		S01_Person p = new S01_Person();
		p.name = "홍길동";
		Scanner sc = new Scanner(System.in);
		System.out.print("나이 입력 : ");
		int age = sc.nextInt();
//		if(age>=1 && age<=100)
//			p.age = age;
//		else
//			System.out.println("잘못 입력하셨습니다.");
		
//		p.age = 200; 	// 이런 걸 입력 받을 때와 같이 제한을 적용할 수 없음...setAge(age)
		// 접근제한자 private를 통해서 직접 입력할 수 없게 제한시킴!
		p.setAge(age); 	// 어지간하면 입력값은 메인에서 받고 남겨둠, 좋은 습관!
//		p.setAge(); 	// 메인에서 받는 것을 권장
		
		S01_Person p1 = new S01_Person();
		S01_Person p2 = new S01_Person();
		S01_Person p3 = new S01_Person();
		p1.setAge(20);
		p2.setAge(30);
		p3.setAge(50);
		int sum = p1.getAge() + p2.getAge() + p3.getAge();
//		p1.getSum(p1, p2, p3); 뭐 굳이 하자면 이렇게 가능하긴 함. 그런데 Person에 구현하는 걸 하는 사람은 Main 유저가 아니잖아.
		
	}

}
// ====================================================================================================
package N01_캡슐화;

public class S02_BankAccount {
	
	private String accountNumber;
	private int money;
	
//	// 정기예금이라고 가정하면 set가 있으면 문제를 유발할 가능성이 높으므로 세터를 사용하지 못하게 미생성
//	public BankAccount(String accountNumber, int money) {
//		this.accountNumber = accountNumber;
//		this.money = money;
//	}
//	public int getMoney() {
//		return money;
//	}
	
	public S02_BankAccount(String accountNumber) {
		this.accountNumber = accountNumber;
		this.money = 0;
	}
	
	public String getAccountNumber() {
		return accountNumber;
	}
	public void setAccountNumber(String accountNumber) {
		this.accountNumber = accountNumber;
	}
	public int getMoney() {
		return money;
	}
	public void setMoney(int money) {
		this.money = money;
	}
	
	public void deposit(int money) {
		if(money < 0) {
			System.out.println("입금액이 잘못되었습니다.");
//			return;
		} else {
			this.money += money;
			System.out.println(money + "원 입금했습니다.");
		}
	}
	public void withdraw(int money) {
		if(money > this.money || money < 0) {
			System.out.println("잔액이 부족하거나 출금액이 잘못되었습니다. 출금할 수 없습니다.");
//			return;
		} else {
			this.money -= money;
			System.out.println(money + "원 출금했습니다.");
		}
	}
}

// ====================================================================================================
package N01_캡슐화;

import java.util.Scanner;

public class S02_BankMain {

	public static void main(String[] args) {
		S02_BankAccount a = new S02_BankAccount("3333");
		Scanner sc = new Scanner(System.in);
		while(true) {
			System.out.print("1. 입금 2. 출금 3. 잔액조회 4. 종료 : ");
			int choice = sc.nextInt();
			if(choice==4)
				break;
			switch(choice) {
				case 1:
					System.out.print("입금액 입력 : ");
					a.deposit(sc.nextInt());
					break;
				case 2:
					System.out.print("출금액 입력 : ");
					a.withdraw(sc.nextInt());
					break;
				case 3:
					System.out.println("잔액 : " + a.getMoney() + "원입니다.");
					break;
			}
			
		}
	}

}
// ====================================================================================================
246p 다형성
// ====================================================================================================
package N02_다형성;

public class S01_Sample01 {

	public static void main(String[] args) {
		int a = 10;
		long b; // 좀더 큰 범위의 정수형 데이터타입
		b = a;
		double c = 3.14;
//		a = c; // (int) 명시적 형변환을 쓰지 않는 이상 안됨.
		c = a; // 이건 됨, 자동형변환, 묵시적 형변환
		/*
		 * 데이터타입이 담을 수 있는 크기가 기준
		 * 작은 걸 큰거로 변환(업캐스팅)할 경우에는 알아서 자동형변환
		 */
	}

}
// ====================================================================================================
package N02_다형성;

class A{} 			// 할머니
class B extends A{} // 장남
class C extends A{} // 차남
class D extends B{} // 장손
class E extends C{} // 차남 아들

public class S02_Sample {

	public static void main(String[] args) {
		/*
		 * 객체끼리도 형변환이 이루어지는데
		 * 전혀 관련 없는 객체끼리는 안되고
		 * 상속받은 클래스끼리만 가능
		 */
		
		B b = new B();
		C c = new C();
		D d = new D();
		E e = new E();
		
		A ab; // A클래스의 인스턴스 주소값을 가지는 ab라는 참조변수(애초에 값이라는 것을 가지지 못하고 주소값만 가지고 있다는 의미)
		ab = b; // 이건 가능한데, b=ab;가 안 되는구나. 이거 처음 들을 때도 헷갈리더니 ㅡㅡ
		A ae = e; // 손주도 가능! 상속 관계가 연결되어있으면 가능함
		// 이런 걸 다형성이라고 함. B도 담을 수 있고, C도 담을 수 있는... // 포용성(?)
//		b = e; 이건 안 돼! 아무리 할머니가 같다고 해도... 이거 유산이랑 같은 개념이 되는 건가? 점점점점 복잡해질 거니까
		// 247p 교재에서 "자손타입의 참조변수로 조상타입의 인스털스를 참조할 수는 없다"는 반만 맞는 얘기라고 정정.
		b = (B)ab; // (int)처럼 가능하긴 함
		// 작은 쪽으로 가는(다운캐스팅) 조건은 명시하는 것뿐만 아니라, 업캐스팅한 것만 다운캐스팅이 가능함.
		b = (B)ae; // 이건 된다는 거! 그런데 나중에 문제는 생길 거라는 거지... 나중에 단계별로 본다고 하심	
	}
}
// ====================================================================================================
package N02_다형성;

public class S03_Parent {
	public void method1() {
		System.out.println("부모 1번 메서드");
	}
	public void method2() {
		System.out.println("부모 2번 메서드");
	}

}
// ====================================================================================================
package N02_다형성;

public class S03_Child extends S03_Parent {

	@Override
	public void method2() {
		System.out.println("자식 2번 메서드");
	}
	public void method3() {
		System.out.println("자식 3번 메서드");
	}

}
// ====================================================================================================
package N02_다형성;

public class S03_Child2 extends S03_Parent {

	@Override
	public void method2() {
		System.out.println("두번째 자식 2번 메서드");
	}

}
// ====================================================================================================
package N02_다형성;

public class S03_Main {

	public static void main(String[] args) {
		S03_Parent p = new S03_Child();
		p.method1();
		p.method2(); // 자식클래스의 메서드가 실행됨!!!
//		p.method3(); // 이건 안됨, 없는 건 날라감. 정보의 개념으로는 (int), (double)이랑 반대 
		/*
		 * 필드를 어떻게 쓰느냐에 따라서...
		 * 다형성을 활용하는 거임.
		 */
		
		p = new S03_Child2();
		p.method2(); // 같은 참조변수명에 같은 메서드명을 호출했지만 기능은 상황에 따라 달라짐!
	}

}
// ====================================================================================================
package N02_다형성;

public class S04_Tire {
	int maxRotation;
	int acRotation;
	String location;
	
	public S04_Tire(int maxRotation, String location) {
		this.maxRotation = maxRotation;
		this.location = location;
	}
	
	// 바퀴 회전시키는 메서드
	public boolean roll() {
		acRotation++;
		if(acRotation < maxRotation) {
			System.out.println(location + "의 수명 : " + (maxRotation-acRotation) + " 남음");
			return true;
		} else {
			System.out.println(location + " 타이어 터짐");
			return false;
		}
	}
}
// ====================================================================================================
package N02_다형성;

public class S04_HankookTire extends S04_Tire {

	public S04_HankookTire(int maxRotation, String location) {
		super(maxRotation, location);
	}

	@Override
	public boolean roll() {
		acRotation++;
		if(acRotation < maxRotation) {
			System.out.println(location + " 한국타이어의 수명 : " + (maxRotation-acRotation) + " 남음");
			return true;
		} else {
			System.out.println(location + " 한국타이어 터짐");
			return false;
		}
	}
	
}
// ====================================================================================================
package N02_다형성;

public class S04_NexenTire extends S04_Tire {
	public S04_NexenTire(int maxRotation, String location) {
		super(maxRotation, location);
	}

	@Override
	public boolean roll() {
		acRotation++;
		if(acRotation < maxRotation) {
			System.out.println(location + " 넥센타이어의 수명 : " + (maxRotation-acRotation) + " 남음");
			return true;
		} else {
			System.out.println(location + " 넥센타이어 터짐");
			return false;
		}
	}
}
// ====================================================================================================
package N02_다형성;

public class S04_Car {
	
//	Tire fLTire = new Tire(6, "앞왼쪽"); // 여기에 한국타이어를 넣든, 넥센을 넣든 상관 없는데 선언을 할 때 Tire로 해놔야 가능하다는 거!
//	Tire fRTire = new Tire(3, "앞오른쪽");
//	Tire bLTire = new Tire(8, "뒤왼쪽");
//	Tire bRTire = new Tire(10, "뒤오른쪽");
	
	S04_Tire[] tires = {
			new S04_Tire(6, "앞왼쪽"),
			new S04_Tire(3, "앞오른쪽"),
			new S04_Tire(8, "뒤왼쪽"),
			new S04_Tire(10, "뒤오른쪽")
	};
	
	public void stop() {
		System.out.println("자동차 멈춤");
	}
	
	public int run() {
		System.out.println("자동차 주행 시작");
		
//		if(!fLTire.roll()) {
//			stop();
//			return 1;
//		}
//		if(!fRTire.roll()) {
//			stop();
//			return 2;
//		}
//		if(!bLTire.roll()) {
//			stop();
//			return 3;
//		}
//		if(!bRTire.roll()) {
//			stop();
//			return 4;
//		}
		
		for(int i=0; i<tires.length; i++) {
			if(!tires[i].roll()) {
				stop();
				return i+1;
			}
		}
		
		return 0;
	}
}
// ====================================================================================================
package N02_다형성;

public class S04_TireMain {

	public static void main(String[] args) throws InterruptedException {
		S04_Car c = new S04_Car();
		for(int i=0; i<15; i++) {
			int num = c.run();
//			switch(num) {
//				case 1:
//					System.out.println("앞왼쪽 타이어를 한국타이어로 교체");
//					c.fLTire = new HankookTire(15, "앞왼쪽");
//					break;
//				case 2:
//					System.out.println("앞오른쪽 타이어를 한국타이어로 교체");
//					c.fRTire = new HankookTire(20, "앞오른쪽");
//					break;
//				case 3:
//					System.out.println("뒤왼쪽 타이어를 넥센타이어로 교체");
//					c.bLTire = new NexenTire(17, "뒤왼쪽");
//					break;
//				case 4:
//					System.out.println("뒤오른쪽 타이어를 넥센타이어로 교체");
//					c.bRTire = new NexenTire(13, "뒤오른쪽");
//					break;
//			}
			if(num == 1 || num == 2) {
				System.out.println(c.tires[num-1].location + " 타이어를 한국타이어로 교체");
				c.tires[num-1] = new S04_HankookTire(20, c.tires[num-1].location);
			}
			if(num == 3 || num == 4) {
				System.out.println(c.tires[num-1].location + " 타이어를 넥센타이어로 교체");
				c.tires[num-1] = new S04_NexenTire(17, c.tires[num-1].location);
			}
			System.out.println("==============================");
			Thread.sleep(3000);
		}
	}

}
// ====================================================================================================
더 간단한 예제...
// ====================================================================================================
package N02_다형성;

public class S05_Player {
	int hp;
	int mp;
	int id;
	
	public void attack() {
		System.out.println("기본 공격");
	}

}
// ====================================================================================================
package N02_다형성;

public class S05_Knight extends S05_Player {
	
	public void attack() {
		System.out.println("검으로 공격");
	}
	
}
// ====================================================================================================
package N02_다형성;

public class S05_Mage extends S05_Player {
	
	public void attack() {
		System.out.println("마법 공격");
	}
	
}
// ====================================================================================================
package N02_다형성;

public class S05_Main {

	public static void main(String[] args) {
		
		S05_Player p = new S05_Player();
		
		p.attack();
		System.out.println("===플레이어 공격");
		
		System.out.println("기사로 전직했음");
		p = new S05_Knight();
		p.attack();
		System.out.println("===플레이어 공격");
		
		System.out.println("법사로 전직했음");
		p = new S05_Mage();
		p.attack();
		System.out.println("===플레이어 공격");
	}

}
// ====================================================================================================
참조변수 자동형변환
매개변수 자동형변환도 가능하다는 거
eg. public void aaa(student s)... 이런 거!
// ====================================================================================================
package N02_다형성;

public class S06_Vehicle {
	
	public void run() {
		System.out.println("차량 운행");
	}

}
// ====================================================================================================
package N02_다형성;

public class S06_Bus extends S06_Vehicle {

	public void run() {
		System.out.println("버스 운행");
	}
	
}
// ====================================================================================================
package N02_다형성;

public class S06_Taxi extends S06_Vehicle {
	public void run() {
		System.out.println("택시 운행");
	}
}
// ====================================================================================================
package N02_다형성;

public class S06_Driver {
	String name;

	public S06_Driver(String name) {
		this.name = name;
	}
	
	public void drive(S06_Vehicle v) {
		System.out.print(name + "님은 ");
		v.run();
	}
}
// ====================================================================================================
package N02_다형성;

import java.util.Scanner;

public class S06_Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		S06_Driver d = new S06_Driver("홍길동");
		System.out.print("어떤 거 운행하심? [1] 버스 [2] 택시 : ");
		int ch = sc.nextInt();
		if(ch == 1)
			d.drive(new S06_Bus());
		else
			d.drive(new S06_Taxi());
	}

}
// ====================================================================================================
// 253p 다형성 예제
package N02_다형성;

public class S07_Product {
	int price;
	int bonusPoint;
	public S07_Product(int price) {
		this.price = price;
		this.bonusPoint = price/10;
	}
	
}
// ====================================================================================================
package N02_다형성;

public class S07_Tv extends S07_Product {

	public S07_Tv() {
		super(100);
	}
	public String toString() {
		return "Tv";
	}
}
// ====================================================================================================
package N02_다형성;

public class S07_Computer extends S07_Product {

	public S07_Computer() {
		super(200);
	}
	public String toString() {
		return "Computer";
	}
}
// ====================================================================================================
package N02_다형성;

public class S07_Buyer {
	
	int money = 1000; // 원래 이런 건 생성자로 하는 게 낫습니다~ 근데 뭐 그냥 합시다~ㅋㅋㅋ
	int bonusPoint = 0;
	
	public void buy(S07_Product p) {
		if(money < p.price) {
			System.out.println("비싸 못사");
			return;
		}
		money -= p.price;
		bonusPoint += p.bonusPoint;
		System.out.println(p + " 구매 완료");// 참조변수명만 쓰면 toString이 호출됨
	}
}
// ====================================================================================================
package N02_다형성;

public class S07_BuyMain {

	public static void main(String[] args) {
		
		S07_Buyer b = new S07_Buyer();
		b.buy(new S07_Tv());
		b.buy(new S07_Computer());
		System.out.println("잔액 : " + b.money + "만원, 적립금 : " + b.bonusPoint +"점");
		
		System.out.println(b.toString()); 	// 이건 오버라이딩이 없으니 그냥 주소값이 나옴
		System.out.println(b);				// b라고만 써도 b.toString()과 동일한 값 출력함!
	}

}
// ====================================================================================================
Day0626
// ====================================================================================================
/*
 * Animal 클래스
 * name 멤버변수
 * makeSound() 메서드 - "동물소리 출력" 이라는 출력문이 나오는 메서드
 */

package N01_복습;

public class S01_Animal {
	private String name;
	public S01_Animal(String name) {
		this.name = name;
	}
	public String getName() {
		return name;
	}
//	public void setName(String name) {
//		this.name = name;
//	}
	@Override
	public String toString() {
		return "S01_Animal [name=" + name + "]";
	}
	public void makeSound() {
		System.out.println("동물소리 출력");
	}
}
// ====================================================================================================
/*
 * Dog 클래스 Animal 클래스 상속
 * breed 멤버변수
 * 생성자를 통해 이름과 견종을 초기화
 * makeSound() 메서드를 오버라이딩해 "멍멍"이라는 출력문이 나오는 메서드
 */
package N01_복습;

public class S01_Dog extends S01_Animal {
	private String breed;
	public S01_Dog(String name, String breed) {
		super(name);
		this.breed = breed;
	}
	
	@Override
	public String toString() {
		return "S01_Dog [toString()=" + super.toString() + ", breed=" + breed + "]";
	}

	@Override
	public void makeSound() {
		System.out.println("멍멍");
	}
}
// ====================================================================================================
/*
 * Cat 클래스 Animal 클래스 상속
 * color 멤버변수
 * 생성자를 통해 이름과 색상을 초기화
 * makeSound() 메서드를 오버라이딩해 "냐옹"이라는 출력문이 나오는 메서드
 */
package N01_복습;

public class S01_Cat extends S01_Animal {
	private String color;
	public S01_Cat(String name, String color) {
		super(name);
		this.color = color;
	}
	
	@Override
	public String toString() {
		return "S01_Cat [toString()=" + super.toString() + ", color=" + color + "]";
	}

	@Override
	public void makeSound() {
		System.out.println("냐옹");
	}
}
// ====================================================================================================
/*
 * 동물들을 저장할 수 있는 배열을 만들어서 원하는 만큼 배열에 동물들을 저장(강아지, 고양이)
 * 배열에 저장된 동물들의 이름과 동물별 소리가 출현되도록 구현
 */
package N01_복습;

import java.util.Scanner;

public class S01_AnimalMain {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("동물배열 크기 : ");
		int size = sc.nextInt();
		S01_Animal[] arr = new S01_Animal[size];
		
		for(int i=0; i<arr.length; i++) {
			if(Math.random()<0.5)
				arr[i] = new S01_Dog("멍멍이"+(i+1),"견종"+(i+1));
			else
				arr[i] = new S01_Cat("냐옹이"+(i+1),"색상"+(i+1));
		}
		for(int i=0; i<arr.length; i++) {
			System.out.print(arr[i] +" ");//.getName() + " : "); // 여기서 견종이나 색상을 출력할 수 있을까? 직접적인 호출은 안되지만 오버라이딩 메서드를 이용하면 가능하다는 거지.
			arr[i].makeSound();
		}
	}
}
// ====================================================================================================
/*
 * Employee 클래스
 * 이름 name, 급여 salary
 * 생성자로 이름과 급여를 초기화
 * calcBonus() 메서드: 기본 급여에 5%를 보너스로 처리해서 리턴시킴
 */
package N01_복습;

public class S02_Employee {
	String name;
	int salary;
	public S02_Employee(String name, int salary) {
		this.name = name;
		this.salary = salary;
	}
	
	@Override
	public String toString() {
		return "Employee [name=" + name + ", salary=" + salary + "]";
	}

	public int calcBonus() {
		return (int) (salary*0.05);
	}
}
// ====================================================================================================
/*
 * Manager 클래스 - Employee 클래스를 상속
 * calcBonus 메서드를 오버라이딩 구현, 기본 급여에 20%를 보너스로 처리해서 리턴시킴
 */
package N01_복습;

public class S02_Manager extends S02_Employee {
	public S02_Manager(String name, int salary) {
		super(name, salary);
	}

	@Override
	public String toString() {
		return "Manager  [name=" + name + ", salary=" + salary + ", calcBonus()=" + calcBonus() + "]";
	}

	@Override
	public int calcBonus() {
		return (int) (salary*0.20);
	}
	
}
// ====================================================================================================
/*
 * Engineer 클래스 - Employee 클래스를 상속
 * calcBonus 메서드를 오버라이딩 구현, 기본 급여에 10%를 보너스로 처리해서 리턴시킴
 */
package N01_복습;

public class S02_Engineer extends S02_Employee {
	public S02_Engineer(String name, int salary) {
		super(name, salary);
	}

	@Override
	public String toString() {
		return "Engineer [name=" + name + ", salary=" + salary + ", calcBonus()=" + calcBonus() + "]";
	}

	@Override
	public int calcBonus() {
		return (int) (salary*0.10);
	}
}
// ====================================================================================================
/*
 * SalesMan 클래스 - Employee 클래스를 상속
 * calcBonus 메서드를 오버라이딩 구현, 기본 급여에 15%를 보너스로 처리해서 리턴시킴
 */
package N01_복습;

public class S02_SalesMan extends S02_Employee {
	public S02_SalesMan(String name, int salary) {
		super(name, salary);
	}

	@Override
	public String toString() {
		return "SalesMan [name=" + name + ", salary=" + salary + ", calcBonus()=" + calcBonus() + "]";
	}

	@Override
	public int calcBonus() {
		return (int) (salary*0.15);
	}
}
// ====================================================================================================
/*
 * Management 클래스
 * 직원들을 배열로 관리
 * totalBonus 메서드 : 직원들의 보너스 총합계를 계산해서 출력
 */
package N01_복습;

public class S02_Management {
	S02_Employee[] employees;
	public void totalBonus() {
		int totalBonus = 0;
		for(int i=0; i<employees.length; i++)
			totalBonus += employees[i].calcBonus();
		System.out.println("totalBonus : " + totalBonus);
	}
}
// ====================================================================================================
package N01_복습;

public class S02_EmployeeMain {

	public static void main(String[] args) {
		S02_Management m = new S02_Management();
		m.employees = new S02_Employee[3];
		m.employees[0] = new S02_Manager("김점장", 150);
		m.employees[1] = new S02_Engineer("이연구", 200);
		m.employees[2] = new S02_SalesMan("나영업", 300);

		for(int i=0; i<m.employees.length; i++)
			System.out.println(m.employees[i]);
		m.totalBonus();
	}
}
// ====================================================================================================
싱글톤( Singleton ) // 책에 없다네...?? 디자인 패턴의 여러 종류 중 하나
객체는 하나 // 단 하나의 객체만 생성해서 공유해서 사용하는 구조, 굳이 여러 번 안 만들어도 되는 거. 
하나만 만들어서 돌려쓰니까 메모리 절약됨. 낭비를 막아줌! 
전역으로 접근 가능
// 나중에 서버 구현할 때, java랑 DB랑 연동하는 거를 한번만 호출해놓으면 어떤 클래스에서든 매번 객체 생성 없이 사용할 수 있도록 사용한다심
예를 들어 Test 클래스
Test t1 = new Test();
Test t2 = new Test();
이렇게 못한다는 거.. new를 통한 객체 생성이 안됨?!?!?!
// ====================================================================================================
/*
 * 싱글톤의 기본 형식
 */
package N02_싱글톤;

public class Singleton {// class 이름은 상관 없음
	
	String name;		// 멤버변수도 이제껏 해온 것처럼 제약 없이 구현하면 됨 
	int no;
	
	private static Singleton singleton = new Singleton(); // 참조변수 선언할 때 여기서 바로 초기화해버림, private static은 꼭 붙어 있어야 함
	
	private Singleton() {
		/* 
		 * 생성자를 private으로 만듦!!! 다른 class에서 객체 절대 생성 불가함
		 * 초기화구현
		 */
		name = "홍길동";
		no = 10;
	}
	
	public static Singleton getInstance() { 
		/*
		 * private static Singleton을 수정은 못하게 하고 사용은 할 수 있도록 하기 위해서 만든 메서드
		 * public static으로 설정
		 * 이름은 상관 없지만 관용적으로 getInstance로 붙이긴 함
		 */
		return singleton;
	}
}
// ====================================================================================================
package N02_싱글톤;

public class Main {

	public static void main(String[] args) {
		
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();
		System.out.println("s1 : "+s1+"\ns2 : "+s2); // s1과 s2 같다!!! 객체를 생성한 게 아니라(new를 사용한 게 아니잖슴) 이미 최초에 생성한 애를 가져온 거라는 거! 
	}

}
// ====================================================================================================
추상화 257p
추상 클래스
객체 생성 불가 // 일반 클래스와의 차이점
public abstract class 클래스이름{
}
public abstract void 메서드이름(매개변수); // 구현부가 없이 ;로 끝남
상속받는 클래스들에 강제성을 주기 위해서 추상메서드들을 포함시킴 (일반 메서드도 그냥 추가 가능함)
상속받은 자식클래스에서 추상메서드의 오버라이딩을 무조건 구현해야 함! 이런 강제성을 준다는 거.
실제로 추상클래스는 잘 안 쓰고 추상화 끝나고 바로 배울 인터페이스를 쓰긴 함.
생각해보면 지금까지 부모클래스를 직접적으로 사용한 적은 없음
이런 것처럼 큰틀만 마련해놓고 자식클래스에서 구현해서 쓰려면 부모클래스를 추상화 클래스, 추상화 메서드로 구현하면 됨.   
// ====================================================================================================
package N03_추상화;

public abstract class Shape {
	public abstract double calcArea(); // 도형 넓이 계산해주는 메서드, 상속받은 메서드에서 무조건 오버라이딩 해야 됨
	public void hello() { // 오버라이딩 안 해도 됨
		System.out.println("hello");
	}
}
// ====================================================================================================
package N03_추상화;

public class Rectangle extends Shape {
	
	private double width, height;
	
	public Rectangle(double width, double height) {
		this.width = width;
		this.height = height;
	}

	@Override
	public double calcArea() {
		return width * height;
	}
}
// ====================================================================================================
package N03_추상화;

public class ShapeMain {

	public static void main(String[] args) {
		
//		Shape s = new Shape(); // 추상클래스는 인스턴스 생성 불가
		Rectangle r = new Rectangle(5, 10);
		Shape s = new Rectangle(8, 9); // 형변환은 됨~
		r.hello();
		s.hello();
		System.out.println("넓이 : " + r.calcArea());
		System.out.println("넓이2 : " + s.calcArea()); // 오버라이딩 메서드 호출은 문제없이 잘됨
		
	}

}
// ====================================================================================================
인터페이스 263p 완전 껍데기
인터페이스는 일반 메서드를 가질 수 없고 오직 추상메서드만 가짐
멤버변수는 오로지 상수로만 가짐
인터페이스를 활용하면 다중상속처럼 쓸 수 있음
인터페이스는 정확하게는 상속이라기보다 구현이라는 표현을 씀 extends가 아닌 implement를 씀!
추상메서드를 이용하기 때문에 표준화를 시킬 수 있고 개발시간을 단축시킬수 있음
일반적으로는 추상클래스보다는 인터페이스를 만든다심
형식
접근제한자 interface 인터페이스이름{
}
인터페이스는 만들 때 이클립스에서 클래스로 만드는 게 아니라 interface로 생성
클래스명처럼 대문자로 시작하는 것은 동일
클래스처럼 인터페이스는 인터페이스끼리 상속이 가능함, 클래스와는 달리 다중상속도 가능!
인터페이스끼리 상속한다고 해서 오버라이딩 메서드를 구현하거나 그런 거는 아님
예를 들어 전기차를 만드는데
Sample01은 자동차의 기본 특성에 관한 것, Sample02는 전기차의 특성, 충전 같은 것을 구현했다고 하면
전기차는 Sample01과 Sample02를 합친 것을 사용했으면 할때 사용한다심
인터페이스
상수
추상메서드
default 메서드
static 메서드
이렇게 4개만 넣을 수 있음, default 메서드, static 메서드는 나중에 생겼는데, 얘네가 생기면서 추상클래스와 경계가 모호해졌다심
267p 인터페이스 장점
개발시간을 단축 : 이거는 뭐...어떤 걸 설명할 때나 다 나오는 거라... 패스
포준화가 가능 : 이거는 기능이 틀로 정해졌다는 의미, 에어컨이면 이걸 작동하는 기능은 무조건 있어야 된다는 걸 정해놓은 표준이 있음. 그런 것처럼 인터페이스를 표준화할 때 가져다 쓰도록.
서로 관계없는 클래스들에게 관계를 맺어줄 수 있다. : 인터페이스를 통해서도 다형성을 적용시킬 수 있다. 
독립적인 프로그래밍 가능 : 메서드 이름만 같을 뿐 구현은 각각의 클래스에서 하는 거기 때문에 달라도 된다는 의미
// ====================================================================================================
package N03_추상화;

public interface S02_Sample {
	int a = 10; // public static final 생략된 거!
	int A=10;   // 상수니까 변수명은 대문자로 저장하자!
	public void 메서드이름(); // abstract 생략된 거!
}
// ====================================================================================================
package N03_추상화;

public class S02_SampleMain extends Shape implements S02_Sample { // 상속은 상속대로 되고, 인터페이스 구현은 구현대로 되는 거임

	@Override
	public double calcArea() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void 메서드이름() {
		// TODO Auto-generated method stub

	}



	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
	}
	
}
// ====================================================================================================
package N04_인터페이스;

public interface S01_Animal {
	public void sound();
	public static void method() {
		System.out.println("당연히 구현이 되어 있어야 함");
	}
}
// ====================================================================================================
package N04_인터페이스;

public interface S01_Flyable {
	public void fly();
}
// ====================================================================================================
package N04_인터페이스;

public class S01_Dog implements S01_Animal {

	@Override
	public void sound() {
		System.out.println("멍멍");
	}

}
// ====================================================================================================
package N04_인터페이스;

public class S01_Bird implements S01_Animal, S01_Flyable {

	@Override
	public void fly() {
		System.out.println("새가 날아다님");
	}

	@Override
	public void sound() {
		System.out.println("짹짹");
	}

}
// ====================================================================================================
package N04_인터페이스;

public class S01_Main {

	public static void main(String[] args) {
		S01_Dog d = new S01_Dog();
		d.sound();
		
		S01_Bird b = new S01_Bird();
		b.sound();
		b.fly();
		
		S01_Animal a; // 다형성 적용도 된다는 거
		a = new S01_Dog();
		a.sound();
		a = new S01_Bird();
		a.sound();
//		a.fly(); // animal에 들어있는 건 아니기 때문에 직접적인 호출은 불가 
		S01_Flyable a2 = new S01_Bird();
		a2.fly();
		S01_Animal.method();
	}

}
// ====================================================================================================
인터페이스 268p
default 메서드 : 구현 가능, 구현하는 클래스에서 오버라이딩 가능 // 이런 거 왜 쓰나? 10에 8개는 동일한 기능을 사용하고 2개만 다를 경우 default로 공통적인 기능을 구현한 다음 2개만 구현하면 용이함.
static 메서드 : 인터페이스 자체로 호출 가능한 메서드(상속, 구현과 상관없음)
인터페이스 내부에서도 메서드 구현을 할 수 있게 하는 것이 default 메서드
// ====================================================================================================
package N04_인터페이스;

public interface S02_Calculator {
	
	public int add(int a, int b);
	public default int sub(int a, int b) {
		return a-b;
	}
	public static int mul(int a, int b) {
		return a*b;
	}
}
// ====================================================================================================
package N04_인터페이스;

public class S02_NormalCalc implements S02_Calculator {

	@Override
	public int add(int a, int b) {
		return a+b;
	}

}
// ====================================================================================================
package N04_인터페이스;

public class S02_CalcMain {

	public static void main(String[] args) {
		S02_NormalCalc c = new S02_NormalCalc();
		System.out.println("5 + 10 = " + c.add(5, 10));
		System.out.println("20 - 10 = " + c.add(20, 10));
//		System.out.println("5 * 3 = " + c.mul(5, 3)); // static 메서드는 상속과 상관 없음
		System.out.println("5 * 3 = " + S02_Calculator.mul(5, 3));
	}

}
// ====================================================================================================
내부 클래스 270p
클래스 안에 클래스 있는 거 (이게 다임...)
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근
- 관련있는 클래스를 묶어서 표현 - 캡슐화
- 외부에서 내부 클래스 접근 불가능 → 코드 복잡성을 줄임
내부 클래스의 종류 271p
인스턴스 (멤버) 클래스
class A{
    class B{ // B 클래스가 인스턴스 멤버 클래스
    
    }
}
스태틱(정적) 멤버 클래스
class A{
    static class B{ // B 클래스가 스태틱 멤버 클래스, 인스턴스랑 모양은 동일한데, static이 붙은 거
    
    }
}
지역 클래스
class A{
    public void method(){
        class B{} // B 클래스가 로컬클래스, 메서드 안에 있는 클래스 
    }
}
익명 클래스
class A { }
--- 메인
A a = new A(){
	int a;
	void method() {}
};  // 일회용 변수, 일회용 메서드, 인스턴스 처음 생성할 때 포함해서 생성함.
// ====================================================================================================
package N05_내부클래스;

public class S01_A {
	class B {
		int ba;
//		static int bb; // 인스턴스 클래스에서는 static 변수나 메서드 안됨!, A객체가 없으면 B.b를 호출할 수 없음. 그러니까 안되는 이유는 간단한 거지. 
		B(){
			// 생성자 가능
			System.out.println("B 클래스 생성자");
		}
		void method() {
			System.out.println("B 클래스 메서드");
		}
//		static void method2() {} // 안됨!
	}
	
	static class C{
		int ca;
		static int cb; // 인스턴스 클래스와 달리 static 변수, 메서드 가능!
		C(){
			// 생성자 가능
			System.out.println("C 클래스 생성자");
		}
		void method() {
			System.out.println("C 클래스 메서드");
		}
		static void method2() {
			System.out.println("C 클래스 static 메서드");
		}
	}
	
	public int aMethod() {//void aMethod() {
		System.out.println("A 클래스 메서드");
		class D{ // aMethod()가 작동되어야 D class가 생성되는 것이기 때문에, class 앞에 접근제한자라든지 static도 못 붙임
			int da;
//			static int db; // 안됨
			D(){
				System.out.println("D 클래스 생성자");
			}
			void method() {
				System.out.println("D 클래스 메서드");
			}
//			static void method2() {} // 안됨!
		}
		D d = new D(); // 지역클래스는 메서드 내부에서 인스턴스 생성해서 사용하기 위함
		d.method();
		d.da = 10;
		return d.da;
	}
}
// ====================================================================================================
package N05_내부클래스;

public class S01_Main {
	public static void main(String[] args) {
//		A.B b = new B(); // A객체가 없으면 생성 불가
		S01_A a = new S01_A();
		S01_A.B b = a.new B(); 
		/* 
		 * 이런 거 어디에 쓰나? 우리가 쓸일은 많이 없지만 모바일 쪽에서 쓴다심
		 * 버튼을 눌렀을 때 어떤 행동을 하는지 설정하기 등등..... 
		 */
		
		S01_A.C c = new S01_A.C(); // A 인스턴스 생성 없이 C 인스턴스 생성 가능
		c.method();
		c.method2();
		int cb = S01_A.C.cb; // 이런 거도 가능하다는 거
		S01_A.C.method2();
		
		/*
		 * 지역 클래스(D 클래스)는 Main에서 생성 불가
		 * 메서드에서만 사용하는 클래스이기 때문에 메서드 호출된 생성되나 메서드 내부에서만 접근가능하기 때문에...
		 */
		a.aMethod(); // 할 수 있는 건 이것뿐...
		System.out.println(a.aMethod());
	}

}
// ====================================================================================================
내부 클래스만 되는 게 아니라 내부 인터페이스도 가능함!
// ====================================================================================================
package N05_내부클래스;

public class S02_Button {
	private OnClick listener; // OnClick은 인터페이스이기 때문에 인스턴스 생성불가, 인터페이스와 관련된 인스턴스만 담을 수 있음, 여기서는 Call과 Message
	/*
	 * 화면을 클릭하거나 키보드를 누르거나 하는 거를 이벤트라고 하는데,
	 * 특정 이벤트가 작동되었을 때 기능을 하는 것을 이벤트리스너라고 함
	 * interface와 변수 순서가 상관 없는 것은 class가 이미 메모리에 올라가있기 때...문
	 */
	public void setListener(OnClick listener) {
		this.listener = listener;
	}
	public void touch() {
		listener.click(); // listener의 형태가 뭐가 됐든, 거기에 맞는 click() 메서드를 호출함!
	}
	interface OnClick{
		public void click(); // OnClick을 구현한 클래스들은 무조건 click() 메서드를 포함하고 있음!
	}

}
// ====================================================================================================
package N05_내부클래스;

import N05_내부클래스.S02_Button.OnClick;

public class S02_Call implements OnClick {

	@Override
	public void click() {
		System.out.println("전화 연결");
	}

}
// ====================================================================================================
package N05_내부클래스;

import N05_내부클래스.S02_Button.OnClick;

public class S02_Message implements OnClick {

	@Override
	public void click() {
		System.out.println("문자 전송");
	}

}
// ====================================================================================================
package N05_내부클래스;

public class S02_BtnMain {

	public static void main(String[] args) {
		S02_Button btn = new S02_Button();
		btn.setListener(new S02_Call()); // Call implements Button.OnClick으로 다형성 적용이 되었기 때문에, 자동형변환 됨~ 
		btn.touch();
		btn.setListener(new S02_Message());
		btn.touch();
	}
}
// ====================================================================================================
package N05_내부클래스;

public class S03_Parent {
	public void wake() {
		System.out.println("기상");
	}

}
// ====================================================================================================
package N05_내부클래스;

public class S03_ParentMain {

	public static void main(String[] args) {
		S03_Parent p = new S03_Parent();
		S03_Parent anonymous = new S03_Parent() {
			/*
			 * 익명클래스 영역
			 * 메소드 오버라이딩도 가능하다!
			 */
			public void work() {
				System.out.println("익명 노동 중");
			}

			@Override
			public void wake() {
				System.out.println("익명 10시 기상");
				work();
			}
		};
		
		anonymous.wake();
//		anonymous.work(); // Parent 형변환되었기 때문에, 내부 메서드는 독립적으로 호출은 못함!
	}
}
// ====================================================================================================
활용하기 나름이기도 하지만, 주로 쓰게 될 것은 인터페이스와 기본 상속 정도... 그리고 싱글톤! 정도일 듯.
// ====================================================================================================
예외 처리 292p
오류랑 예외는 다르다!
오류는 코드가 잘못된 거, 코드를 수정해야 함
예외는 특수한 경우에 발생이 되어 나타나는 것으로 코드로 처리를 해주는 것
예외는 빨간줄 노란줄 안 뜸. 실행을 시켰을 때 빨간 글씨 뜨면서 안 되는 거를 처리해주는 거임
실행도 안 되는 거는 오류임
try ~ catch
if
예외가 발생될지 안될지는 모르겠지만 예외가 발생되면 어떻게 처리해주세요 설정해줄 수 있음
예외라는 것은 종류가 다양함
java.lang.ArithmeticException: / by zero 이거... 클래스
Exception 클래스가 예외의 대빵 클래스
물론 디테일하게 처리해주려면, 코더가 발생될 수 있는 모든 예외를 다 알고 있어야 함!
형식
try {
    예외 발생될 것 같은 코드들
} catch( Exception1 e1 ){
    Exception1 예외 발생 시 처리할 코드 
} catch( Exception2 e2 ){ // Exception1처럼 숫자가 들어가는 건 아니고, 예외명이 들어가는 거임, catch는 else if 처럼 뒤에 계속 쓸 수 있음
    Exception2 예외 발생 시 처리할 코드 
}
세분화 시키면 좋지만... 나중에는 귀찮아서 대빵인 Exception으로 그냥 다 처리하기도 한다심
// ====================================================================================================
package N06_예외처리;

import java.util.Scanner;

public class S01_Sample {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		System.out.print("두 수 입력 : ");
		int a = sc.nextInt();
		int b = sc.nextInt();
		System.out.println(a/b); // b=0 입력될 경우 java.lang.ArithmeticException: / by zero
		
		int[] arr = {1, 2, 3};
		System.out.println(arr[4]); // java.lang.ArrayIndexOutOfBoundsException
	}

}
// ====================================================================================================
package N06_예외처리;

public class S02_Main {

	public static void main(String[] args) {
//		System.out.println(1);
//		try {
//			System.out.println(2);
//			System.out.println(3);
//		} catch(Exception e) {
//			System.out.println(4); // 예외 발생됐을 때만 작동되는 코드이기 때문에 예외발생이 되지 않으면 작동되지 않음
//		}
//		System.out.println(5);
//		
////		System.out.println(1);
////		System.out.println(2);
////		System.out.println(3/0); // 예외발생 시 프로그램 중지
////		System.out.println(4);
////		System.out.println(5);
//		
//		System.out.println(1);
//		try {
//			System.out.println(2);
//			System.out.println(3/0);
//		} catch(Exception e) { // e는 매개변수명이기 때문에 아무렇게나 써도 되지만 보통은 e로 함 // e로 뭐 하는 게 있었던 거 같은데 기억이 ㅡ_ㅡ
//			System.out.println(4); // 예외발생시 catch 실행 후 프로그램 중지가 아니라 코드 다음줄 실행됨
//		}
//		System.out.println(5);
//		
//		
//		System.out.println(1);
//		try {
//			System.out.println(2);
//			System.out.println(3/0);
//		} catch(ArithmeticException e) { // 예외 클래스를 콕찝어서 지정해주는 것이 좋음
//			System.out.println(4);
//		}
//		System.out.println(5);
//		
//		System.out.println(1);
//		try {
//			System.out.println(2);
//			System.out.println(3/0);
//		} catch(ArrayIndexOutOfBoundsException e) { // 상관 없는 예외 클래스를 지정하면 에러 발생됨
//			System.out.println(4);
//		}
//		System.out.println(5);
//		
//		System.out.println(1);
//		try {
//			System.out.println(3/0);
//			System.out.println(2); // 예외가 발생되면 catch로 바로 넘어가기 때문에 실행되지 않음
//		} catch(Exception e) {
//			System.out.println(4);
//		}
//		System.out.println(5);
		
		/*
		 * 예외는 먼저 발생되는 걸로 catch 됨
		 */
		String str = null;
		int[] arr = {1, 2, 3};
		int a = 5;
		try {
			System.out.println(2);
		} catch(ArithmeticException e) { // 예외 클래스를 콕찝어서 지정해주는 것이 좋음
			System.out.println("0으로 나눔");
		} catch(IndexOutOfBoundsException e) { // 상관 없는 예외 클래스를 지정하면 에러 발생됨
			System.out.println("배열범위초과");
		} catch(Exception e) { // 최상위 예외클래스는 제일 나중에 써야 실행됨 아니면 실행 안됨
			System.out.println("걍 예외 발생");
		}
		System.out.println("끝");
	}

}
// ====================================================================================================
Day0627
// ====================================================================================================
예외처리, 어제 작성한 파일 이어서 설명
예외가 발생되면 인스턴스가 발생됨
그래서 그것을 매개변수처럼 받아주는 변수명 e를 사용하는 거
그러니까 (Exception e) 는 (클래스명 참조변수명) 쓰는 거임
// ====================================================================================================
package N01_예외처리;

public class S01_Main {

	public static void main(String[] args) {
		
		System.out.println(1);
		try {
			System.out.println(2);
//			System.out.println(3/0);
			throw new Exception("예외 강제 발생"); // 301p 강제로 발생시키는 거, 사용 목적: 테스트할 때 확인용으로 사용
//			System.out.println("bbbbb"); // 예외 강제 발생 이후 코드는 실행이 되지 않기 때문에 이클립스 자동 에러로 실행 안됨 
		} catch(ArithmeticException | IndexOutOfBoundsException  e) { // bit "|" OR연산
		}
		catch(Exception e) {
			System.out.println("걍 예외 발생");
			/*
			 * 299p
			 * 예외처리가 발생되었을 때 메세지 출력해주는 메서드
			 */
			System.out.println("0 ====================");
			e.printStackTrace(); // 얘가 제일 길게 나오네. 예외처리 안하면 출력하고 종료되는 문구 그대로 출력되는 듯.
			/*
			 * Console eg.
			 * java.lang.Exception: 예외 강제 발생
			 * at N01_예외처리.S01_Main.main(S01_Main.java:11)
			 */
			System.out.println("1 ====================");
			System.out.println(e.getMessage()); // 이건 toString처럼 조금 간단하게 나옴
			// Console eg. : 예외 강제 발생
			System.out.println("2 ====================");
			System.out.println(e.toString()); // 언제 예외가 발생했는지 모를 경우 try catch로 해둔다음 로그 찍는 거...
			// Console eg. : java.lang.Exception: 예외 강제 발생
			System.out.println("3 ====================");
			/*
			 * catch에 꼭 뭐를 넣어야 할 필요가 없고 테스트할 때는 
			 * 일반 유저들한테 이런 걸 보여줄 필요는 없고 안내 문구 같은 거 쓰는 거니까... 
			 */
		}
		System.out.println("끝");
		/*
		 * 예외 떠넘기기
		 * 이런 거 어디다 쓰냐?
		 * 나중에 데이터베이스랑 연관이 있긴 함 
		 * 트랜잭션 (하나의 작업단위)
		 * 예를 들어 쇼핑몰에서 1. 주문 → 2. 입금 → 3. 택배 발송 3단계로 작업을 나눴다고 생각해보면,
		 * 상품 발송(){
		 * 	주문();
		 *  입금();
		 *  택배 발송():
		 * }
		 * 주문, 입금, 택배 발송 예외가 발생했다고 할 때, 주문 취소를 위해서 try~catch로 묶어줘야 할 것임.
		 * 상품 발송(){
		 * 	try{
		 *   주문();
		 *   입금();
		 *   택배 발송():
		 *  } catch() {
		 *   어디서 예외가 발생하든 전부 취소();
		 *  }
		 * }
		 * 주문, 입금, 택배 발송(){
		 *  try{
		 *   기능 구현
		 *  } catch() {
		 *   예외처리
		 *  }
		 * }
		 * 주문, 입금, 택배 발송 예외처리에서만 예외가 처리되고 나머지 트랜잭션은 실행이 되기 때문에
		 * 예외 떠넘기를 사용하여 나머지 트랜잭션이 실행되지 않도록 한 거임
		 * 사실상 여러 작업한 거를 하나로 묶은 거임. 
		 * 데이터베이스할 때 예외 발생 시 롤백되어야 하기 때문에 중요한 개념이라 다시 얘기하신다심 
		 */
		try {
			div(5,0); // 메서드 호출에는 문제가 없고 메서드 내부에서만 예외가 발생해서 메서드 catch만 작동하는데, 이거를 호출한 위치에서도 예외를 발생하게 하도록
		} catch (Exception e) {
			System.out.println("메서드 에러 : " + e.getMessage());
		}
	}
	
	public static void div(int a, int b) throws Exception { // main 바깥에 메서드, static 붙여야 함
		try {
			System.out.println(a/b);
		} catch (Exception e) {
			System.out.println("div메서드 예외 발생");
			throw new Exception("0으로 못 나눔"); // 예외발생을 강제로 시켰다는 의미는...원래는 try문 안에 있어야 하는 거 넘길 곳을 메서드 명에 "throws 예외클래스명"(throw 아님 s 붙어야 함, 생성한 예외와 동일클래스)
		} finally {
			/*
			 * 원래 try-catch finally가 한 세트인데 뭐 사실 별로 쓸일은 없을 듯
			 * 그냥 예외가 발생하든 발생하지 않든 언제든 실행되는 코드를 작성하는 곳
			 * if-else 여서 else??? 같은 느낌이라시는데 그건 좀 이상한 비유...그그 필요 없으면 안 써도 된다는 의미에서 사용하신 듯.
			 */
			System.out.println("마지막에 실행~");
		}
		// 예외처리 클래서 상속받아서 직접 만들어서 쓸 수 있음
	}
}
// ====================================================================================================
/*
 * 사용자 정의 예외 만들기 307p
 * Exception class를 상속받아서 만듬
 */
package N01_예외처리;

public class S02_CustomException extends Exception {// 기존에 있었던 것을 만들 때 보통 기존 명칭에 custom을 붙임 

	public S02_CustomException(String message) {
		super(message);
	} 
	
}
// ====================================================================================================
package N01_예외처리;

public class S02_Main {

	public static void main(String[] args) {
		try{
			int age = -10;
			setAge(age);
		} catch (S02_CustomException e){
			e.printStackTrace();
			System.out.println("끝");
		}
	}
	
	public static void setAge (int age) throws S02_CustomException { // 그냥 Exception 써도 되긴 한다심
		if(age<0) // 이런 건 try catch로 처리하지 못함
			throw new S02_CustomException("나이는 음수 안됨");
	}

}
// ====================================================================================================
연결된 예외 312p
// ====================================================================================================
/*
 * 사용자 정의 예외 만들기 307p
 * Exception class를 상속받아서 만듬
 */
package N01_예외처리;

public class S02_CustomException extends Exception {// 기존에 있었던 것을 만들 때 보통 기존 명칭에 custom을 붙임 

	public S02_CustomException(String message, Throwable cause) {
		super(message, cause);
	}
}
// ====================================================================================================
package N01_예외처리;

public class S02_Main2 {

	public static void main(String[] args) {
		try {
			try {
				int result = 10/0;
			} catch(ArithmeticException e) {
				throw new S02_CustomException("강제 발생", e);
			}
		} catch(S02_CustomException e) {
			System.out.println("예외 발생 : " + e.getMessage());
			System.out.println("예외 원인 : " + e.getCause().getMessage());
//			e.printStackTrace();
		}
	}
}
/*
 * 예외 발생 : 강제 발생
 * 예외 원인 : / by zero
 * 그냥 StackTrace하면...Stack에 쌓여 있는데 굳이...getCause를...?
 * N01_예외처리.S02_CustomException: 강제 발생
 * 	at N01_예외처리.S02_Main2.main(S02_Main2.java:10)
 * Caused by: java.lang.ArithmeticException: / by zero
 * 	at N01_예외처리.S02_Main2.main(S02_Main2.java:8)
 */
// ====================================================================================================
자바 API 324p
라이브러리라고 생각하면 됨. 정식 용어는 따로 있는데...라심
1. java.lang 패키지 안에 Math 같은거, import 안해도 쓸 수 있었음!
2. java.util 패키지 : 이건 나중에 컬렉션 프레임? 할 때 쓴다심
기본 제공하는 메서드, 클래스들
// ====================================================================================================
334p String 메소드 종류들 설명
str.join("-", arr);
338p
String 처럼 int도 Integer라는 클래스가 있어서 인스턴스 생성 가능, 각 데이터타입마다 다 클래스는 있음
Wrapper 클래스라고 뒤에 한다심 (int 랑 char 빼고는 다똑같고 앞에만 대문자로 하면 클래스명이 됨!)
int → Integer, char → Character, double → Double, long → Long, short → Short, ...
.valueOf가 있고 parseXXX가 있는데 일반적으로 parseXX를 많이 쓴다심 
데이터를 전송할 수 있는 거는 문자열만 전송이 가능하기 때문에 나중에 문자열을 숫자로 변경하는 거는 종종 쓸거라심
// ====================================================================================================
package N02_API;

public class S01_Main {

	public static void main(String[] args) {
		String str1 = "abc";
		String str2 = "abc";
		String str3 = new String("abc");
		System.out.println(str1 == str2); // true
		System.out.println(str1 == str3); // false
		System.out.println(str1.equals(str2)); // true
		System.out.println(str1.hashCode() == str2.hashCode()); // true 메모리 heap에 쌓아놓는 거라 중복저장하지 않음?? 자료구조를 공부하면 나오는 내용이라심. 기억 저편에 있는 hashtable... 
		
		// (1)
		StringBuffer sb = new StringBuffer();
		sb.append("hi");
		sb.append(" ");
		sb.append("java");
		
		// (2)
		String s = "";
		s += "hi";
		s += " ";
		s += "java";
		
		/*
		 * (1), (2)는 눈에 보이진 않지만 메모리 구조 자체에서 다른 점이 있음
		 * String은 연산할 때마다 매번 새로운 객체를 생성해서 작업 
		 * String은 불변 객체, 한 번 생성하면 못 바꾸기 때문에 String 클래스 
		 * 기본적으로 사용량은 StringBuffer가 메모리 사용량도 많고 속도도 느린 편이라서
		 * 일반적으로는 String 써서 그냥 한다심
		 * 문자열에 내용이 자주 변경된다하면 StringBuffer, 많이 변경되지 않으면 String쓴다심
		 * 지금 당장에는 String 쓰라심
		 */
		
		StringBuilder sbd = new StringBuilder();
		sb.append("hi");
		sb.append(" ");
		sb.append("java");
		// StringBuffer와 거의 비슷한 기능을 하는데, 쓰레드 배우면 차이가 조금 생긴다심. 걍 넘어감.
	}

}
// ====================================================================================================
Wrapper 클래스는 어떨 때 쓰는지? 
(1) 제너릭, 컬렉션 ... 
(2) int나 double 같은 거는 null 값을 가지지 못하는데, 가지게 하고 싶을 때...
박싱과 언박싱이라는 게 있다심 (356p)
박싱 eg. 정수형 숫자를 객체에 담는 거. eg. Integer num = new Integer(20);
버전이 올라가면서 자동 박싱, 언박싱으로 해줌 오토박싱  Integer num = 20; (Wrapper 클래스랑 데이터 타입 동일할 때 알아서 해주는 거)
언박싱 eg. 값을 가져오는 거. eg. int n = num.intValue();
오토 언박싱 eg. int n = num;
매번 System.out.println(n+num); 이거 변환해서 하고 싶지 않아서 버전 업되면서 자동박싱, 자동언박싱 지원...
자바 버전이 올라가면서 기존기능이 업그레이드가 된다든지, 기존버전...어느정도 허용을 해줌,
버전 올라가서 이제 이런 식으로 안 써를 취소선으로 알려준다심
// ====================================================================================================
package N02_API;

public class S02_Main {

	public static void main(String[] args) {
		Integer num1 = new Integer(10);
		Integer num2 = new Integer(20);
		Integer num3 = new Integer(10);
		int n1 = num1.intValue();
		int n2 = num2.intValue();
		
		int r1 = n1 + n2;
		int r2 = num1 + num2;
		int r3 = n1 + num1; // 다 연산된다는 거~~
	}
}
// ====================================================================================================
이제 2권!!!
날짜 시간 366p
Calender 클래스 : 추상클래스인데, 내부에 static 메서드가 있음. 메서드를 호출해서 가져다 씀.
Date 클래스
// ====================================================================================================
379p SimpleDateFormat
yyyy, yy: 년도
M, MM, MMM : 월 (대문자)
dd : 일
e : 요일
// ====================================================================================================
package N02_API;

import java.util.Calendar;
import java.util.Date;
import java.text.SimpleDateFormat;

public class S03_Main {

	public static void main(String[] args) {
		
		Calendar today = Calendar.getInstance(); // 우리가 배웠던 싱글톤과 유사한 구조, Calendar는 import해야 함
		System.out.println(today); // 1970년 1월 1일부터 흐른 mSec 단위
		System.out.println("년도 : " + today.get(Calendar.YEAR));
		System.out.println("월  : " + (today.get(Calendar.MONTH) + 1)); // Month는 0~11로 출력되어서 +1 해야 함!
		String[] arr = {"1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"};// 이건 열거형 나중에 배우면 이거보다 간단하게 한다심
		System.out.println("일 : " + today.get(Calendar.DATE)); // Day가 아니고 DATE임!
		// 요일은 1~7, 일~토 임!
		String[] warr = {"", "일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"}; // 형태라는 거지
		
		Date now = new Date();
		System.out.println(now);
		SimpleDateFormat f;
		f = new SimpleDateFormat("yyyy-MM-dd a hh:mm:ss");
		System.out.println("yyyyy-MM-dd a hh:mm:ss : " + f.format(now)); // 2023-06-27 오후 01:20:25
		f = new SimpleDateFormat("yy-MM-dd HH:m:s");
		System.out.println("yy-MM-dd HH:m:s	: " + f.format(now)); // 23-06-27 13:21:32
		f = new SimpleDateFormat("yy-M-d");
		System.out.println("yy-M-d	: " + f.format(now)); // 23-6-27
		f = new SimpleDateFormat("yy-MMM-d");
		System.out.println("yy-MMM-d	: " + f.format(now)); // 23-6월-27, 설정 언어에 따라가나봄
	}

}
// ====================================================================================================
package N02_API;

import java.text.DecimalFormat; // import 해야 함!

public class S04_Main {

	public static void main(String[] args) {
		int num = 1234567;
		System.out.println(num);
		DecimalFormat df = new DecimalFormat("#,###"); // ,는 자리수 구분기호, 0이나 #은 숫자임 
		System.out.println(df.format(num));
		
		double num2 = 1234567.897;
		df = new DecimalFormat("#,##0.000"); // 0은 자리수 채워줌, 일의자리 0은 0.12 같은 게 .12처럼 나오는 거 방지
		System.out.println(df.format(num2)); // 변환된 데이터는 결과값은 문자열이기 때문에 연산은 안됨... 걍 눈으로 볼 때 예쁘게 보는 용도 
	}

}
// ====================================================================================================
컬렉션 프레임워크 388p
이제 드디어 배열따위 필요없어진다고 하심
배열의 단점을 보완하기 위해서 만들어진 여러 가지 종류가 있다심
종류 크게 3가지
(1) List : 순서가 있음, 데이터 중복 허용(중복된 데이터 넣을 수 있다는 의미)
           (ArrayList, Vector, LinkedList, Stack, Queue) 제일 많이 쓰는 건 ArrayList 나머지는 잘 안 쓸 거라심.
(2) Set : 순서가 없음, 데이터 중복 불가
          (HashSet, TreeSet) 
(3) Map : key와 value 한쌍으로 이루어진 데이터의 집합, key는 중복 불가, value는 중복 가능, 순서 없음 (쉽게 생각하려면 key는 한칸한칸의 이름, value는 그칸에 있는 데이터)
          (HashMap, TreeMap, Hashtable, Properties) HashMap이랑 TreeMap 정도 쓴다심. Hashtable을 많이 안 쓰다니ㅜㅋㅋ
일반적으로 배열을 대체해서 쓰는 거는 List를 쓴다심
그 외에 상황에 따라서 Set, Map 쓰는데 옛날 거는 많이 안 쓴다심
// ====================================================================================================
List // 리스트는 인터페이스라서 인스턴스 생성하는 건 아니고 
크기가 고정되어 있지 않음(동적 할당) // 배열처럼 크기를 지정할 필요 없음
// ====================================================================================================
package N03_컬렉션;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class S01_Sample {

	public static void main(String[] args) {
		
		ArrayList user = new ArrayList();// <E> 제너릭이라는 건 나중에 설명한다심
		user.add("홍길동");
		user.add(123);
		user.add("abc");
		user.add("qwer");
		user.add("abc");
		System.out.println(user); // toString 호출 [홍길동, abc, qwer]
		
		for(int i=0; i<user.size(); i++) { // 배열의 length가 아니라 .size() 임!
			System.out.print(user.get(i) + " "); // 배열이랑 유사한데 조금조금 다른 거임!
		}
		System.out.println();
		
		user.add(2, "asdf"); // 중간에 껴넣고 싶을 때
		System.out.println(user);
		
		// 오버로딩된 remove는 서로 리턴타입이 다름!
		
		System.out.println(user.remove("abc")); // 내용으로 삭제 public boolean remove(Object o)
		System.out.println(user);
		System.out.println(user.remove(3)); // 인덱스로 삭제 public E remove(int index) 인덱스로 삭제하면, 삭제한 방의 데이터를 출력해줌
		System.out.println(user);
		
//		ArrayList user = new ArrayList(); <E> 제너릭이라는 거 설명하시려는 듯
//		String name = user.get(0); 타입 지정 안 하면, 이런 게 안되는데, 무조건 모든 클래스에 상속되는 Object로 인식함.
		String name = (String) user.get(0); // 업캐스팅은 자동으로 됐지만, 다운캐스팅은 형변환 해야 한다는 거!
		// 이럴 거면 걍 처음에 ArrayList 만들 때 형식을 지정해서 알려주겠다고 하는 거
//		ArrayList<String> aList = new ArrayList<String>(); // 뒤에 <> 사이에 String은 안 써도 됨
		ArrayList<String> aList = new ArrayList<>(); // 일반적으로는 안 쓰는 걸 더 권장!
		aList.add("haha");
		String str = aList.get(0); // 형변환 없이 가능하다는 거!
		
		String[] data = {"123", "456", "789"};
		ArrayList<String> al2 = new ArrayList<>(Arrays.asList(data)); // 일반적으로는 안 쓰는 걸 더 권장!
		System.out.println(al2);
		al2.sort(Comparator.naturalOrder());
		System.out.println(al2);
		al2.sort(Comparator.reverseOrder());
		System.out.println(al2);
	}
}
// ====================================================================================================
package N03_컬렉션;

import java.util.ArrayList; // 교재처럼 *를 하면 import 추가를 계속 안 해도 되니까 편하지만, 나중에 배포할 때 불필요한 것까지 추가가 되는 문제가 생김  
import java.util.Collections;

public class S02_Sample {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<>(); // size는 미리 할당할 필요는 없음!
		al.add(5);
		al.add(4);
		al.add(2);
		al.add(0);
		al.add(1);
		al.add(3);
		ArrayList<Integer> al2 = new ArrayList<>(al.subList(1, 4));
		System.out.println(al2);
		
		System.out.println(al);
		Collections.sort(al);
		System.out.println(al);
		
		System.out.println(al.containsAll(al2));
		
		al.add(0);
		System.out.println(al.retainAll(al2)); // 공통된 교집합만 남기는 거!
		System.out.println(al);
		Collections.sort(al2);
		System.out.println(al2);
		System.out.println(al.contains(al2)); // 이거 왜 false임??? 질문 나왔으나 아직 해결 안됨
		
		al.clear();
		System.out.println("Empty? : " + al.isEmpty());
	}

}
// ====================================================================================================
package N03_컬렉션;

public class S03_MenuInfo {
	
	String name;
	int price;
	boolean isTax;
	
	public S03_MenuInfo(String name, int price, boolean isTax) {
		this.name = name;
		this.price = price;
		this.isTax = isTax;
	}

	@Override
	public String toString() {
		return "S03_MenuInfo [name=" + name + ", price=" + price + ", isTax=" + isTax + "]";
	}
	

}
// ====================================================================================================
package N03_컬렉션;

import java.util.ArrayList;

public class S03_MenuMain {

	public static void main(String[] args) {
		ArrayList<S03_MenuInfo> al = new ArrayList<>();
		al.add(new S03_MenuInfo("아이스크림", 4000, false));
		al.add(new S03_MenuInfo("밀크티", 5800, true));
		al.add(new S03_MenuInfo("딸기무스", 6500, true));
		System.out.println(al);
	}

}
// ====================================================================================================
/*
 * 점수를 보관하는 ArrayList 생성
 * 5개의 점수를 입력받아 저장
 * 점수들의 합계, 평균 출력
 */
package N03_컬렉션;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class S04_Sample {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		ArrayList<Integer> al = new ArrayList<>();
		
		for(int i=0; i<5; i++) {
			System.out.print("점수 입력 : ");
			al.add((int)(Math.random()*100)+1);// sc.nextInt());
			System.out.print(al.get(i)+"\n");
		}
		int sum = 0;
		for(int i=0; i<al.size(); i++) // ArrayList에 있는 것도 향상된 for문 사용 가능 for(Integer score:al) 도 가능하다는 거
			sum += al.get(i);
		System.out.println("합계 : " + sum + " 평균 : " + (double)sum/al.size());
		
		int sum2 = 0;
		DecimalFormat df = new DecimalFormat("#0.0");
		Collections.sort(al);
		// Collections.max(al); 이런 것도 할 수 있음
		System.out.println("최고점 제외 : " + al.remove(al.size()-1)); // Integer일 경우에는 index랑 value랑 헷갈릴 수 있음, 주의 필요!
		System.out.println("최저점 제외 : " + al.remove(0));
		for(int i=0; i<al.size(); i++)
			sum2 += al.get(i);
		System.out.println(al);
		System.out.println("최고, 최저 제외 평균 : " + df.format((double)sum2/al.size()));
	}
}
// ====================================================================================================
package N03_컬렉션;

public class S03_MenuInfo {
	
	String name;
	int price;
	boolean isTax;
	
	public S03_MenuInfo(String name, int price, boolean isTax) {
		this.name = name;
		this.price = price;
		this.isTax = isTax;
	}

	@Override
	public String toString() {
//		return "S03_MenuInfo [name=" + name + ", price=" + price + ", isTax=" + isTax + "]";
		return "\t[name=" + name + ",	price=" + price + ",	isTax=" + isTax + ",	totalPrice="+ totalPrice()+"]	";
	}
	public int totalPrice() {
		return (isTax)? (int) (price * 1.1) : price; // 나중에 if를 못쓰는 구간이 생긴다고 하심. react의 특정영역에서는 if를 못써서 삼항연산 쓸 수밖에 없음...
	}

}
// ====================================================================================================
package N03_컬렉션;

import java.util.ArrayList;

public class S03_MenuMain {

	public static void main(String[] args) {
		ArrayList<S03_MenuInfo> al = new ArrayList<>();
		al.add(new S03_MenuInfo("아이스크림", 4000, false));
		al.add(new S03_MenuInfo("밀크티", 5800, true));
		al.add(new S03_MenuInfo("딸기무스", 6500, true));
//		System.out.println(al);
		
//		for(int i=0; i<al.size(); i++)
//			System.out.println(al.get(i).totalPrice());
		
		System.out.println(al);
	}

}
// ====================================================================================================
Day0628
// ====================================================================================================
ArrayList는 배열처럼 메모리에서 연이어서 만들어짐, 첫번째 주소값만 알고 있으면 그다음칸의 주소를 알 수 있다는 의미, 다음칸의 주소값을 찾을 필요가 없으니 각각의 칸에서는 값만 가지고 있으면 됨
LinkedList는 메모리에서 다음 칸이 떨어져있어서, 값과 다음 칸에 대한 주소값을 가지고 있어서 연결됨을 알게 됨, 내부적인 구조가 조금 다름
상황에 따라 장단점이 있어서 그거에 맞춰서 쓴다심
중간칸을 삭제나 추가할 때 LinkedList가 ArrayList보다 빠름(해당되는 칸에 대한 주소 값만 변경해주면 되니까...)
용량은 LinkedList가 더 많이 차지, 왜냐믄 주소값을 다 갖구 있어야 하니까.
추가, 삭제가 빈번할 때는 LinkedList가 유리할 수도 있음
추가, 삭제가 빈번하지 않을 때는 ArrayList가 유리함
처음이랑 마지막만 추가할 때는 ArrayList가 빠르기 때문에, 추가만 빈번할 때는 ArrayList를 쓰기도...
접근(읽기)은 ArrayList가 빠르지. 처음주소 알고 인덱스 주면 해당 주소를 바로 알 수 있지만, LinkedList는 주소를 타고타고 가야함.
// ====================================================================================================
package N01_컬렉션;

import java.util.ArrayList;
import java.util.LinkedList;

public class S01_Sample01 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<>();
		LinkedList<Integer> ll = new LinkedList<>();
		
		long startTime, endTime;
		
		startTime = System.nanoTime();
		for(int i=0; i<10000; i++)
			al.add(0, i);
		endTime = System.nanoTime();
		System.out.println("ArrayList 추가 소요시간	: " + (endTime-startTime) + "ns");
		
		startTime = System.nanoTime();
		for(int i=0; i<10000; i++)
			al.add(i);
		endTime = System.nanoTime();
		System.out.println("ArrayList 순차추가 소요시간	: " + (endTime-startTime) + "ns");
		
		startTime = System.nanoTime();
		for(int i=0; i<10000; i++)
			ll.add(0, i);
		endTime = System.nanoTime();
		System.out.println("LinkedList 추가 소요시간	: " + (endTime-startTime) + "ns");
		
		startTime = System.nanoTime();
		for(int i=0; i<10000; i++)
			al.get(i);
		endTime = System.nanoTime();
		System.out.println("ArrayList 읽기 소요시간	: " + (endTime-startTime) + "ns");
		
		startTime = System.nanoTime();
		for(int i=0; i<10000; i++)
			ll.get(i);
		endTime = System.nanoTime();
		System.out.println("LinkedList 읽기 소요시간	: " + (endTime-startTime) + "ns");
		
		startTime = System.nanoTime();
		for(int i=9999; i>=0; i--)
			al.get(i);
		endTime = System.nanoTime();
		System.out.println("ArrayList 거꾸로 읽기	: " + (endTime-startTime) + "ns");
		
		startTime = System.nanoTime();
		for(int i=9999; i>=0; i--)
			ll.get(i);
		endTime = System.nanoTime();
		System.out.println("LinkedList 거꾸로 읽기	: " + (endTime-startTime) + "ns");
	}

}
ArrayList 추가 소요시간	:  7474200ns
ArrayList 순차추가 소요시간	:  1201200ns
LinkedList 추가 소요시간	:  1554000ns
ArrayList 읽기 소요시간	:   524100ns
LinkedList 읽기 소요시간	: 41661000ns
ArrayList 거꾸로 읽기		:   219800ns
LinkedList 거꾸로 읽기		: 31008300ns
// ====================================================================================================
자료구조 공부하면 Stack과 queue
Stack(LIFO, 후입선출) 저장 push, 추출 pop (명령어도 push랑 pop임)  
Queue(FIFO, 선입선출), 편의점
어떤 걸 쓸지는 그때그때 다름
예를 들어 브라우저 뒤로가기... 인터넷 페이지 서핑할 때 뒤로가기 하려면 stack으로 해야함
queue는 티켓팅. 사이트 터졌을 때 대기열 생기는 거에서는 먼저 들어온 애를 먼저 처리해줘야 함
Stack은 클래스이기 때문에 바로 객체 생성 가능
Queue는 인터페이스라 구현하여 코드 생성해야 함.

Stack 메서드 : empty(), peek(), pop(), push(Object o), search(Object o)
Queue 메서드 : add(Object o) 맨뒤에 저장, 리턴타입이 boolean, remove()는 맨앞 빠짐 그런데 예외처리를 해줘야 하기 때문에
              offer(Object o)랑 poll()을 씀. element(), peek()
// ====================================================================================================
package N01_컬렉션;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class S02_Sample02 {	
	public static void main(String[] args) {
		Stack<Integer> s = new Stack<>();
		Queue<Integer> q = new LinkedList<>();
		for(int i=1; i<=3; i++) {
			s.push(i);
			q.offer(i);
		}
		System.out.print("stack : ");
		while(!s.empty())
			System.out.print(s.pop() + " ");
		System.out.print("\nqueue : ");
		while(!q.isEmpty())
			System.out.print(q.poll() + " ");
	}
}
// ====================================================================================================
package N01_컬렉션;

import java.util.Stack;

public class S03_Sample03 {

	public static void main(String[] args) {
		Stack<Coin> coinBox = new Stack<>();
		coinBox.push(new Coin(50));
		coinBox.push(new Coin(10));
		coinBox.push(new Coin(500));
		coinBox.push(new Coin(100));
		
		while(!coinBox.empty()) {
			Coin c = coinBox.pop();
			System.out.println("꺼넨 동전 : "+c.getValue());
		}
	}

}

class Coin{
	private int value;

	public Coin(int value) {
		this.value = value;
	}

	public int getValue() {
		return value;
	}
}
// ====================================================================================================
package N01_컬렉션;

import java.util.Stack;

public class S04_Sample04 {

	public static void main(String[] args) {
		
		String str;
		str = "[{(a+b";
		System.out.println(str + " : " + isBracket(str));
		str = "[{(a+b)";
		System.out.println(str + " : " + isBracket(str));
		str = "[{(a+b)}";
		System.out.println(str + " : " + isBracket(str));
		str = "[{(a+b)}]";
		System.out.println(str + " : " + isBracket(str));
		str = "{(a+b)}";
		System.out.println(str + " : " + isBracket(str));
		str = "(a+b)";
		System.out.println(str + " : " + isBracket(str));
		str = "[{a+b} + (b+c)]";
		System.out.println(str + " : " + isBracket(str));
		str = "[{(a+b)*(a-b)} + {(c+d)*(c-d)}]*2";
		System.out.println(str + " : " + isBracket(str));
	}
	public static boolean isBracket(String input) {
		Stack<Character> s = new Stack<>();
		for(int i=0; i<input.length(); i++) {
			char ch = input.charAt(i);
			if(ch == '(' || ch == '{' || ch == '[' )
				s.push(ch);
			else if(ch == ')' || ch == '}' || ch == ']' ) {
				if(s.isEmpty())
					return false;
				char pop = s.pop();
				if(        (pop=='(' && ch != ')') 
						|| (pop=='{' && ch != '}')
						|| (pop=='[' && ch != ']'))
					return false;
			}
//			System.out.println(ch + "   " + s);
		}
		return s.isEmpty();
	}
}
// ====================================================================================================
/*
 * 예약메세지 전송
 * Queue를 활용하면 좋겠지~~~
 */
package N01_컬렉션;

import java.util.LinkedList;
import java.util.Queue;

public class S05_MsgMain {

	public static void main(String[] args) {
		Queue<Msg> m = new LinkedList<>();
		m.offer(new Msg("mail", "고길동"));
		m.offer(new Msg("sms", "둘리"));
		m.offer(new Msg("kakao", "도우너"));
		
		while(!m.isEmpty())
			System.out.println(m.poll());

	}

}

class Msg{
	String command;
	String to;
	
	public Msg(String command, String to) {
		this.command = command;
		this.to = to;
	}

	@Override
	public String toString() {
		return "Msg [command=" + command + ",	to=" + to + "]";
	}
}
// ====================================================================================================
/*
 * Cmd 창에서 최근 사용 명령어 5개를 보여주는 프로그램
 */
package N01_컬렉션;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class S06_CmdMain {
	static Queue<String> qCmds = new LinkedList<>();
	final static int MAX_SIZE = 5;
	
	static void save(String cmd) {
		qCmds.offer(cmd);
		if(qCmds.size() > MAX_SIZE)
			qCmds.poll();
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("help를 입력하면 도움말을 볼 수 있습니다.");
		while(true) {
			System.out.print(">> ");
			String cmd = sc.nextLine().trim();
			save(cmd);
			if(cmd.equalsIgnoreCase("q"))
				System.exit(0); // 프로그램 강제 종료, break;
			else if(cmd.equalsIgnoreCase("help"))
				System.out.println("   help - 도움말을 보여줌\n"
						+ "   q 또는 Q - 프로그램 종료\n"
						+ "   history - 최근 입력한 명령어 " + MAX_SIZE + "개 보여줌");
			else if(cmd.equalsIgnoreCase("history")) {
				int cnt = 0;
				for(String q : qCmds)
					System.out.println("   " + (++cnt) + " : " + q);
			} else
				System.out.println(cmd + " 명령어가 실행되었습니다.");
		}
	}

}
// ====================================================================================================
Iterator
List는 List대로 메서드가 따로 있고 Map은 Map대로 메서드가 따로 있어서...
특히 Map이 다름
각 컬렉션들의 메서드가 다르니 그걸 표준화해서 사용하기 용이하게 해주는 게 이터레이터
Iterator도 인터페이스이기 때문에... 각종 컬렉션들을 공통적으로 사용할 수 있게 도와주는 인터페이스!
Iterator 안에 메서드
boolean hasNext(): Iterator에 다음 요소가 있으면 true 없으면 false
Object next(): 다음칸에 있는 요소를 리턴시켜줌
void remove(): 최근 반환한 요소를 삭제, 최근 반환한 건 next(), 즉, remove() 전에는 next()가 무조건 있어야 함
// ====================================================================================================
package N01_컬렉션;

import java.util.ArrayList;
import java.util.Iterator;

public class S07_IteratorMain {

	public static void main(String[] args) {
		ArrayList<String> al = new ArrayList<>();
		al.add("뭐할까?");
		al.add("뭐하지?");
		al.add("뭐해요?");
		
		Iterator<String> it = al.iterator();
//		al.add("여기 추가는 안됨!"); iterator에 cursor랑 해서 thread하면 Sync를 맞춰줘야 해서 안됨...
		while(it.hasNext())
			System.out.println(it.next());
		System.out.println(al);
		
		it = al.iterator();
		while(it.hasNext()) {
			System.out.println(it.next());
			it.remove();
		}
		System.out.println(al);
	}

}
// ====================================================================================================
package N01_컬렉션;

public class S08_Fruit {
	String name;
	int price;
	public S08_Fruit(String name, int price) {
		this.name = name;
		this.price = price;
	}
	@Override
	public String toString() {
		return "Fruit [name=" + name + ", price=" + price + "]";
	}
}
// ====================================================================================================
package N01_컬렉션;

import java.util.Comparator;

public class S08_DescComparator implements Comparator<S08_Fruit> {

	@Override
	public int compare(S08_Fruit o1, S08_Fruit o2) {
		if(o1.price < o2.price)
			return 1;
		else if(o1.price == o2.price)
			return 0;
		else
			return -1;
	}

}
// ====================================================================================================
package N01_컬렉션;

import java.util.Comparator;

public class S08_AscComparator implements Comparator<S08_Fruit> {

	@Override
	public int compare(S08_Fruit o1, S08_Fruit o2) {
		if(o1.price > o2.price)
			return 1;
		else if(o1.price == o2.price)
			return 0;
		else
			return -1;
	}

}
// ====================================================================================================
// 객체끼리는 비교 기준을 정의해줘야 함. tree 구조는 바로 비교해줘서 위치를 넣어줌
package N01_컬렉션;

import java.util.TreeSet;

public class S08_FruitMain {

	public static void main(String[] args) {
		TreeSet<S08_Fruit> fd = new TreeSet<>(new S08_DescComparator());
		fd.add(new S08_Fruit("수박", 16000));
		fd.add(new S08_Fruit("딸기", 10000));
		fd.add(new S08_Fruit("포도", 20000));
		System.out.println(fd);
		// [Fruit [name=복숭아, price=25000], Fruit [name=수박, price=18000], Fruit [name=키위, price=10000]]
		
		
		TreeSet<S08_Fruit> fa = new TreeSet<>(new S08_AscComparator());
		fa.add(new S08_Fruit("멜론", 15000));
		fa.add(new S08_Fruit("복숭아", 25000));
		fa.add(new S08_Fruit("키위", 10000));
		System.out.println(fa);
		// [Fruit [name=키위, price=10000], Fruit [name=수박, price=18000], Fruit [name=복숭아, price=25000]]

	}

}
// ====================================================================================================
package N01_컬렉션;

public class S09_Person implements Comparable<S09_Person>{
	String name;
	int age;
	public S09_Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public int getAge() {
		return age;
	}
	public String getName() {
		return name;
	}
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
	@Override // implements Comparable<S09_Person>
	public int compareTo(S09_Person o) { // 객체 정렬을 하기 위해 정렬 기준을 설정해준 거!
		return this.age - o.age; // Ascending
//		return o.age - this.age; // Descending
	}
}
// ====================================================================================================
package N01_컬렉션;

import java.util.ArrayList;
import java.util.Comparator;

public class S09_PersonMain {

	public static void main(String[] args) {
		ArrayList<S09_Person> al = new ArrayList<>();
		al.add(new S09_Person("고길동", 40));
		al.add(new S09_Person("둘리", 10));
		al.add(new S09_Person("마이콜", 15));
		al.sort(Comparator.comparingInt(S09_Person::getAge)); // 클래스명 :: 메서드명, 람다할 때 할 거라심
		System.out.println(al);
		al.sort(Comparator.comparingInt(S09_Person::getAge).reversed());
		System.out.println(al);
	}
}
// ====================================================================================================
package N01_컬렉션;

import java.util.ArrayList;
import java.util.Collections;

public class S09_PersonMain2_Comparable {

	public static void main(String[] args) {
		ArrayList<S09_Person> al = new ArrayList<>();
		al.add(new S09_Person("고길동", 40));
		al.add(new S09_Person("둘리", 10));
		al.add(new S09_Person("마이콜", 15));
		System.out.println(al);
		
		Collections.sort(al);
		System.out.println(al);
		Collections.reverse(al); // reverse는 정렬이랑은 상관 없음 그냥 꺼꾸로라서 내림차순 하고 싶으면 먼저 (오름차순) 정렬한 다음 리버스해야 함!
		System.out.println(al);
	}
}
// ====================================================================================================
Set : 순서가 없음, 중복 불가능, 수학의 집합 개념과 동일!
사용법은 List랑 비슷해서 메서드도 비슷한가봄
일반적으로 많이 사용하는... 쓰게 된다면 hashset
// ====================================================================================================
package N02_Set;

import java.util.Arrays;
import java.util.HashSet;

public class S01_Sample01_HashSet {

	public static void main(String[] args) {
		HashSet<String> s = new HashSet<>();
		s.add("아아아");
		s.add("테스트1");
		s.add("테스트2");
		
		System.out.println(s); // 인덱스 번호 못 넣음 그런 거 없음!, 순서 출력은 매번 다를 수 있음
		s.add("테스트 해볼까?");
		s.add("테스트2");
		System.out.println("테스트2 추가 해볼까? : " + s.add("테스트2"));
		System.out.println(s);
		
		s.addAll(Arrays.asList("이것도 해보자", "테스트3"));
		System.out.println(s);
		
		s.remove("아아아"); // 인덱스로 지우는 게 없지~
		System.out.println(s);
	}

}
// ====================================================================================================
package N02_Set;

import java.util.HashSet;

public class S02_Sample02 {

	public static void main(String[] args) {
		HashSet<Integer> s = new HashSet<>();
//		Set<Integer> s = new HashSet<>(); // 다형성이 적용되기 때문에 이렇게 쓰기도 함, Set 종류가 많아서
		while(s.size()<6)
			s.add((int)(Math.random()*45)+1);
		System.out.println(s);
	}

}
// ====================================================================================================
package N01_컬렉션;

import java.util.Objects;

public class S09_Person implements Comparable<S09_Person>{
	String name;
	int age;
	public S09_Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public int getAge() {
		return age;
	}
	public String getName() {
		return name;
	}
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
	@Override // implements Comparable<S09_Person>
	public int compareTo(S09_Person o) {
		return this.age - o.age; // Ascending
//		return o.age - this.age; // Descending
	}
	
	//
	@Override
	public int hashCode() { // 인스턴스 주소값을 보여주는 거임, Set에서 이걸 보고 비교함
//		return age; // 나이만 중복이 안되게 하려면 간단히.
		return Objects.hash(name,age);
	}
	@Override
	public boolean equals(Object obj) {
		if(!(obj instanceof S09_Person))
			return false; 
		S09_Person p = (S09_Person) obj;
		return this.name.equals(p.name) && (this.age==p.age); 
	}
}
// ====================================================================================================
package N02_Set;

import java.util.HashSet;

import N01_컬렉션.S09_Person;

public class S03_PersonMain {

	public static void main(String[] args) {
		HashSet<S09_Person> s = new HashSet<>();
		s.add(new S09_Person("고길동", 40));
		s.add(new S09_Person("둘리", 10));
		s.add(new S09_Person("고길동", 40)); // 주소값이 다르니까 다른 인스턴스라네...
		System.out.println(s);
		
		S09_Person p = new S09_Person("고길동", 40);
		s.add(p);
		s.add(p); // 이 객체는 중복으로 안 들어감
		
		// 내용 확인해서 추가를 할지 안할지 결정하려면 hashCode와 equals 메서드를 오버라이딩해줘야 했던 거!
		
		s.add(new S09_Person("고길동", 40));
		System.out.println(s);
	}
}
// ====================================================================================================
package N02_Set;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;

public class S04_Sample04 {

	public static void main(String[] args) {
		HashSet<Integer> setA = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
		HashSet<Integer> setB = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));
		HashSet<Integer> setHab = new HashSet<>();
		HashSet<Integer> setKyo = new HashSet<>();
		HashSet<Integer> setCha = new HashSet<>();
		System.out.println("setA : " + setA);
		System.out.println("setB : " + setB);
		
		Iterator<Integer> it = setA.iterator();
		while(it.hasNext()) {
			int tmp = it.next();
			setHab.add(tmp);
			if(setB.contains(tmp))
				setKyo.add(tmp);
			else
				setCha.add(tmp); // A-B
		}
		it = setB.iterator();
		while(it.hasNext())
			setHab.add(it.next());
		System.out.println("setHab : " + setHab);
		System.out.println("setKyo : " + setKyo);
		System.out.println("setCha : " + setCha);
		
		HashSet<Integer> test = new HashSet<>();
		for(Integer a: setA) // Iterator는 약간 뭐시기 그 반복을 돌리기 위함인 듯
			test.add(a);
		for(Integer b: setB)
			test.add(b);
		System.out.println("test : " + test);
	}

}
// ====================================================================================================
TreeSet 429p
검색기능 강화 (평균적으로 빠름)
이진검색트리
기본적으로 나무처럼 생겨서 이름에 tree...
추가, 삭제, 검색 속도 모두 빠름~
순서, 중복 없이 저장 (애초에 중복된 거 없다고 가정하고 시작함)
이진검색은 정렬이 되어 있다고 가정하고 시작함
정렬이 안되어 있으면 기준값보다 크다 작다를 말할 수 없기 때문
정렬된 위치에 맞춰서 저장하니까 저장 순서가 저장되지 않음!
걍 알아서 정렬해주는구나 라고 생각하면 됨
HashSet에 없는 기능의 메서드도 있으니 코드 구경하시고 넘어가삼!
// ====================================================================================================
package N02_Set;

import java.util.TreeSet;

public class S05_Sample05_TreeSet {

	public static void main(String[] args) {
		TreeSet<String> t = new TreeSet<>();
		String from = "b";
		String to = "d";
		t.add("d"); t.add("ABC"); t.add("abc"); t.add("bad");
		t.add("a"); t.add("bBC"); t.add("abc"); t.add("cad");
		t.add("b"); t.add("cBC"); t.add("cbc"); t.add("dad");
		System.out.println(t);
		System.out.println(t.subSet(from, to)); // from 이상 to 미만, from 포함, to 미포함,
		
		System.out.println(t.headSet("b")); // head를 기준(지금은 "b")으로 전에 꺼 모두 출력, head가 포함 안됨!
		System.out.println(t.tailSet("b")); // head 이상 출력, head 포함됨!
		System.out.println(t.lower("b")); // 바로 작은 애
		System.out.println(t.higher("b")); // 바로 큰 애
		System.out.println(t.higher("db")); // 없으면 null로 주넹~
	}
}
// ====================================================================================================
package N02_Set;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

public class S06_Sample06 {

	public static void main(String[] args) {
		ArrayList<Integer> nums = new ArrayList<>();
		for(int i=0; i<10; i++)
			nums.add((int)(Math.random()*10)+1);
		for(int i=0; i<5; i++)
			nums.add(nums.get((int)(Math.random()*10)+1));
		System.out.println("중복 제거 전 : " + nums);
		
		HashSet<Integer> s = new HashSet<>();
//		for(int n : nums)
//			s.add(n);
//		System.out.println(s);
		
		Iterator<Integer> it = nums.iterator();
		while(it.hasNext()) {
			if(!(s.add(it.next())))
				it.remove();
		}
		System.out.println("중복 제거 후 : " + nums);
		System.out.println(s);
	}

}
// ====================================================================================================
Map 436p
key와 value 한쌍으로 저장
key는 중복 불가능, value는 중복 상관 없음
순서 없음
key로 식별
나중에 많이 쓰는데 자바스크립트에서 이런 비슷한 오브젝트형식이 있어서 많이 볼거라심
entrySet 은 List나 Set에는 없었지만 Map에는 있음
get이나 remove는 List는 index나 해당 값이 들어가는데 Map에는 key가 들어감
keySet은 key값만 빼오는 거, entrySet의 경우는 key, value 한 쌍
put은 add랑 동일한데, key, value 값이 2개 들어가야 함.
generics도 2개, Key, Value 차례로 들어감
List의 index 대신 순서없이 key를 쓴다고 생각하면 돼~
key가 같은 value가 put되면 value가 나중에 들어온 값으로 변경됨!!!
// ====================================================================================================
package N03_Map;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class S01_Sample01 {

	public static void main(String[] args) {
		HashMap<String, Integer> map = new HashMap<>();
		map.put("고길동", 40);
		map.put("둘리", 10);
		map.put("또치", 13);
		System.out.println(map);
		/*
		 * {둘리=10, 또치=13, 고길동=40}
		 * 이전에 [ ]로 출력해준 거와 달리 { }로 출력해주는데, (이건 dictionary 형태에서는 다 이랬던듯)
		 * 일반적으로 key, value 형태의 데이터들은 eg. 서버에 데이터 주고 받을 때라든지~~~
		 * { key=value } 형태나 { key : value } 로 출력해준다심. Java에서도 한땀씩 직접 넣은 거임~ definition 보삼
		 */
		map.put("도우너", 13); // value 중복은 전혀 상관 없이 들어감~
		System.out.println(map);
		System.out.println(map.put("도우너", 50)); // put도 Object 리턴해줌, 교체하기 전 값 
		System.out.println(map); // key가 같은 아이는 value가 덮어씌워짐!!!
		System.out.println(map.remove("또치"));
		System.out.println(map);
		
		// put과 remove 가 값이 리턴해준다는 것의 장점은...
		System.out.println("중복 값의 기존 값 : " + map.put("도우너", 12)); // 이런 게 한 큐에 된다는 거임...
		System.out.println(map);
		map.put("둘리", map.put("도우너", map.get("둘리"))); // 값 바꿀 때 tmp를 안 쓰고 할 수가 있군ㅋㅋㅋㅋ 근데 이렇게까지 하려나 ㅋㅋㅋ
		System.out.println(map);
		
		System.out.println("map size : " + map.size());
		System.out.println(map.keySet());
		System.out.println(map.entrySet());
		
		System.out.println("방법1==========keySet이랑 Iterator 사용");
		Set<String> names = map.keySet();
		Iterator<String> it = names.iterator();
		while(it.hasNext()) {
			String key = it.next();
			int value = map.get(key);
			System.out.println(key + " : " + value);
		}
		System.out.println("방법2==================향상된 for문 사용");
		for(String k:map.keySet())
			System.out.println(k + " : " + map.get(k));
		
		System.out.println("방법3====================Iterator 사용");
		Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
//		System.out.println(entrySet);
		Iterator<Map.Entry<String, Integer>> entryIt = entrySet.iterator();
		while(entryIt.hasNext()) {
			Map.Entry<String, Integer> entry = entryIt.next();
			String key = entry.getKey();
			int value = entry.getValue();
			System.out.println(key + " : " + value);
		}
	}
}
// ====================================================================================================
배열처리하는 거는 어지간하면 ArrayList 사용,
다른쪽에서 data를 받아야 할 경우 Map 많이 사용 (홈페이지 로그인 같은 거 자바로 받아올 때 Map형태로 온다는 거, 물론 나중에는 편하게 처리해주는 거 갖다쓴다심)
// ====================================================================================================
Day0629
// ====================================================================================================
평가로 시작~ ㅡ_ㅡ
// ====================================================================================================
// 442p 예제 
package N01_컬렉션;

import java.util.HashMap;
import java.util.Map;

public class S01_Sample01 {

	public static void main(String[] args) {
		String[] data = {"A", "B", "C", "A", "A", "B", "B", "C", "A"};
		HashMap<String, Integer> map = new HashMap<>();
		
		for(String d : data)
//			map.put(d, map.get(d)==null?1:map.get(d)+1);
			map.put(d, map.containsKey(d)? map.get(d)+1 : 1); // containsKey로 설명하심
		System.out.println(map);
		
		for(String k : map.keySet())
			System.out.println(k + " : " + printBar('★', map.get(k))+ " " + map.get(k));
		
	}
	
	public static String printBar(char ch, int value) {
		String bar = "";
		for(int i=0; i<value; i++)
			bar += ch;
		return bar;
	}

}
// ====================================================================================================
동기화는 Thread할 때 할 거라고 하시고, 싱글톤은 그렇게 많이 사용할 일 없을 거라시고... 단일컬렉션은 제네릭쓰기 때문에 필요 없다심 
// ====================================================================================================
/*
 * 중복된 단어 찾기
 * 문장을 저장하는 변수에 문장을 알아서 넣고 시작
 * 단어는 공백 기준으로 구분
 * 중복된 단어가 없으면 '중복 단어 없음' 출력
 * 있으면 중복된 단어들 출력
 */
package N01_컬렉션;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public class S02_Sample02 {

	public static void main(String[] args) {
		String str = "I got a boy, 멋진, I got a boy, 착한 "
					+ "I got a boy, handsome boy, 내 맘 다 가져간 "
					+ "I got a boy, 멋진, I got a boy, 착한 "
					+ "I got a boy, awesome boy, 완전 반했나";
		String[] data = str.split(" ");
//		System.out.println(Arrays.toString(data));
//		
//		HashMap<String, Integer> map = new HashMap<>();
//		for(String d : data)
//			map.put(d, map.get(d)==null? 1:map.get(d)+1);
//		System.out.print("중복된 단어 : ");
//		for(String k : map.keySet())
//			if(map.get(k)>1)
//				System.out.print(k + " ");
//		if(map.isEmpty())
//			System.out.println("없음");
		
		// ArrayList 사용해볼까~
//		ArrayList<String> al = new ArrayList<>();
//		ArrayList<String> reAl = new ArrayList<>(); // 중복된 것만 넣읍시다!
//		for(String d : data) {
//			if(al.contains(d) && !reAl.contains(d))
//				reAl.add(d);
//			al.add(d);
//		}
//		if(reAl.isEmpty())
//			System.out.println("중복 단어 없음");
//		else
//			System.out.println(reAl);

		// HashSet 사용~~
		HashSet<String> words = new HashSet<>();
		HashSet<String> dupWords = new HashSet<>();
		for(String word : data)
			if(!words.add(word))
				dupWords.add(word);
		if(dupWords.isEmpty())
			System.out.println("중복 단어 없음");
		else
			System.out.println(dupWords);
	}
}
// ====================================================================================================
pseudocode 얘기까지 나옴 허허허
// ====================================================================================================
/*
 * 숫자를 계속 입력 받음 (종료 : 0)
 * 입력 받은 숫자들을 홀수와 짝수 나눠서 보관
 * 종료가 되면 입력한 숫자들의 
 * 홀수들 목록, 홀수들의 합계, 평균
 * 짝수들 목록, 짝수들의 합계, 평균
 * 메서드로 구현
 */
package N01_컬렉션;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Scanner;

public class S03_Sample03 {

	public static int getSum(ArrayList<Integer> numList) {
		int sum=0;
		for(int num : numList)
			sum += num;
		return sum;
	}
	public static void printInfo(ArrayList<Integer> numList, String msg) {
		if(numList.isEmpty()) {
			System.out.println(msg + " 목록 : 없음");
			System.out.println(msg + " 합계 : 0, 평균 : 0.0");
			return;
		}
		DecimalFormat df = new DecimalFormat("#0.0");
		System.out.println(msg + " 목록 : " + numList);
		System.out.println(msg + " 합계 : " + getSum(numList) + ", 평균 : " + df.format((double)getSum(numList)/numList.size()));
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		ArrayList<Integer> oddList = new ArrayList<>();
		ArrayList<Integer> evenList = new ArrayList<>();
		while(true) {
			System.out.print("숫자 입력 : ");
			int num = sc.nextInt();
			if(num==0)
				break;
			if(num%2 == 1)
				oddList.add(num);
			else
				evenList.add(num);
		}
		printInfo(oddList, "홀수들");
		printInfo(evenList, "짝수들");
	}
}
// ====================================================================================================
메서드를 적절히 나누는 것도 중요한데...
프론트는 함수지향이라 메서드들끼리 왔다갔다해서 심하면 메인에는 메서드 한줄인...
그렇지만 우리는 그정도까지는 안 할꺼라고 하심 헤헷
// ====================================================================================================
package N01_컬렉션;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Scanner;

public class S03_Sample03_2 {

	public static void main(String[] args) {
		ArrayList<Integer> numList = scanNum();
		ArrayList<Integer> oddList = getEvenOrOddList(numList, 1);
		ArrayList<Integer> evenList = getEvenOrOddList(numList, 0);
		printInfo(oddList, "홀수들");
		printInfo(evenList, "짝수들");
	}
	public static ArrayList<Integer> scanNum(){ // 제네릭 활용하면 상황에 따라 입력받는 데이터 타입을 다르게 하는 거도 가능하다심
		Scanner sc = new Scanner(System.in);
		ArrayList<Integer> list = new ArrayList<>();
		int num;
		do {
			System.out.print("숫자 입력(종료:0) : ");
			num = sc.nextInt();
			if(num !=0)
				list.add(num);
		} while(num != 0);
		return list;
	}
	public static ArrayList<Integer> getEvenOrOddList(ArrayList<Integer> numList, int evenOrOdd){
		ArrayList<Integer> list = new ArrayList<>();
		for(int num : numList)
			if(num%2 == evenOrOdd%2)
				list.add(num);
		return list;
	}
	public static int getSum(ArrayList<Integer> numList) {
		int sum=0;
		for(int num : numList)
			sum += num;
		return sum;
	}
	public static void printInfo(ArrayList<Integer> numList, String msg) {
		if(numList.isEmpty()) {
			System.out.println(msg + " 목록 : 없음");
			System.out.println(msg + " 합계 : 0, 평균 : 0.0");
			return;
		}
		DecimalFormat df = new DecimalFormat("#0.0");
		System.out.println(msg + " 목록 : " + numList);
		System.out.println(msg + " 합계 : " + getSum(numList) + ", 평균 : " + df.format((double)getSum(numList)/numList.size()));
	}
}
// ====================================================================================================
/*
 * 두개의 문자열을 입력받음
 * 공통된 문자를 출력
 */
package N01_컬렉션;

import java.util.HashSet;
import java.util.Scanner;

public class S04_Sample04 {

	public static void main(String[] args) {
		char tmp;
		int i;
		String str1 = "abbbcccddd";
		String str2 = "ppwwacwww";
		
		HashSet<Character> set1 = new HashSet<>(); // str1
		HashSet<Character> set2 = new HashSet<>(); // str2
		HashSet<Character> setKyo = new HashSet<>(); // 중복
		
		Scanner sc = new Scanner(System.in);
		System.out.print("첫번째 문자열 입력 : ");
		str1 = sc.next();
		System.out.print("두번째 문자열 입력 : ");
		str2 = sc.next();
		
		for(i=0; i<str1.length(); i++)
			set1.add(str1.charAt(i));
		
		for(i=0; i<str2.length(); i++) {
			tmp = str2.charAt(i);
			if(set2.add(tmp) && set1.contains(tmp))
				setKyo.add(tmp);
		}
		
		System.out.println("str1 문자 : " + set1);
		System.out.println("str2 문자 : " + set2);
		System.out.println("공통된 문자 : " + setKyo);
		
//		char[] charList1 = str1.toCharArray();
//		char[] charList2 = str2.toCharArray();
//		System.out.println(set2.retainAll(set1));
//		System.out.println(set2);
	}
}
// ====================================================================================================
/*
 * 주문할 음식과 가격을 계속 입력받음 (exit 입력하면 종료)
 * 동일한 음식을 주문하면 가격이 추가됨
 * 종료되면 주문한 음식과 가격들을 전체 출력해줌
 * ex)
 * 음식 입력: 피자
 * 가격 입력: 12000
 * 음식 임력: 치킨
 * 가격 입력: 21000
 * 음식 입력: 피자
 * 가격 입력: 22000
 * ----------------
 * 주문 내역
 * 피자 - 34000
 * 치킨 - 21000
 */
package N01_컬렉션;

import java.util.HashMap;
import java.util.Scanner;

public class S05_Sample05 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		HashMap<String, Integer> map = new HashMap<>();
		String menu;
		int price;
		while(true) {
			System.out.print("음식 입력 : ");
			menu = sc.next();
			if(menu.equalsIgnoreCase("exit"))
				break;
			System.out.print("가격 입력 : ");
			price = sc.nextInt(); // 이건 예외처리 비스무리 해줘야 할 듯
			map.put(menu, price + (map.containsKey(menu)?map.get(menu):0));
		}
		System.out.println("====================");
		if(map.isEmpty()) {
			System.out.println("주문 내역 없음");
			return;
		}
		
		System.out.println("주문 내역");
		for(String k : map.keySet())
			System.out.println(k + "	- " + map.get(k));

	}
}
// ====================================================================================================
Day0630
// ====================================================================================================
내일 10시, 2~3시간, 입출력문, 조건문, 반복문, 배열 보강 @ 별관 4층 ㄷㄷ
// ====================================================================================================
어제 과제 설명 및 메서드화
// ====================================================================================================
/*
 * 두개의 문자열을 입력받음
 * 공통된 문자를 출력
 */
package N01_HW;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class S04_Sample04_2 {
	
	static int cnt = 0;
	
	public static void main(String[] args) {

		String str1 = scanStr();
		String str2 = scanStr();
		
		Set<Character> set1 = convert(str1);
		Set<Character> set2 = convert(str2);
		Set<Character> setKyo = intersection(set1, set2);
		
		System.out.println("공통된 문자 : " + setKyo);
		
	}
	
	public static String scanStr() {
		cnt++;
		Scanner sc = new Scanner(System.in);
		System.out.print(cnt + "번째 문자열 입력 : ");
		return sc.next();
	}
	public static Set<Character> convert(String str){
		Set<Character> set = new HashSet<>();
		for(int i=0; i<str.length(); i++)
			set.add(str.charAt(i));
		return set;
	}
	public static Set<Character> intersection(Set<Character> set1, Set<Character> set2){
		Set<Character> intersection = new HashSet<>();
		intersection.addAll(set1);
		intersection.retainAll(set2);
		return intersection;
	}
}
// ====================================================================================================
/*
 * 주문할 음식과 가격을 계속 입력받음 (exit 입력하면 종료)
 * 동일한 음식을 주문하면 가격이 추가됨
 * 종료되면 주문한 음식과 가격들을 전체 출력해줌
 * ex)
 * 음식 입력: 피자
 * 가격 입력: 12000
 * 음식 임력: 치킨
 * 가격 입력: 21000
 * 음식 입력: 피자
 * 가격 입력: 22000
 * ----------------
 * 주문 내역
 * 피자 - 34000
 * 치킨 - 21000
 */
package N01_HW;

import java.util.HashMap;
import java.util.Scanner;

public class S05_Sample05_2 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		HashMap<String, Integer> map = new HashMap<>();
		String menu;
		int price;
		while(true) {
			System.out.print("음식 입력 : ");
			menu = sc.nextLine();
			if(menu.equalsIgnoreCase("exit"))
				break;
			System.out.print("가격 입력 : ");
			price = sc.nextInt(); // 이건 예외처리 비스무리 해줘야 할 듯
			sc.nextLine();
			map.put(menu, price + (map.containsKey(menu)?map.get(menu):0));
		}
		System.out.println("====================");
		if(map.isEmpty()) {
			System.out.println("주문 내역 없음");
			return;
		}
		
		System.out.println("주문 내역");
		for(String k : map.keySet())
			System.out.println(k + "	- " + map.get(k));

	}

}
// 딱히 메서드화시킬 게... 뭐 해야 한다면 할 수야 있지만 지금은 패스~
// ====================================================================================================
/*
 * 학생 이름과 점수를 입력받음 (종료 : exit)
 * 단, 이름은 중복되지 않는다고 가정
 * 학생 입력 종료 후
 * 전체 학생 수
 * 학생들 중 가장 높은 점수와 이름
 * 학생들의 평균점수을 출력
 */
package N02_컬렉션;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class S01_Sample01 {

	public static void main(String[] args) {
		HashMap<String, Integer> map = new HashMap<>();
		Scanner sc = new Scanner(System.in);
		String studentName;
		int score = 0;
		while(true) {
			System.out.print("학생 이름 입력 (종료:exit)	: ");
			studentName = sc.next();
			if(studentName.equalsIgnoreCase("exit"))
				break;
			if(map.containsKey(studentName)) {
				System.out.println(studentName + " 학생의 점수를 이미 입력하였습니다.");
				continue;
			}
			System.out.print(studentName + " 학생 점수 입력	: ");
			score = sc.nextInt();
			map.put(studentName, score);
		}
		
		System.out.println("==============================");
		if(map.isEmpty()) {
			System.out.println("입력한 학생이 없습니다.");
			return;
		}
		
		System.out.println("전체 학생 수	  	: " + map.size() + "명");
		int scoreSum = 0;
		ArrayList<String> firstList = new ArrayList<>(); // 공동 1등처리
		int maxScore = Collections.max(map.values());
		for(String key : map.keySet()) {
			scoreSum += map.get(key);
			if(map.get(key) == maxScore)
				firstList.add(key);
		}
		DecimalFormat df = new DecimalFormat("#0.0");
		System.out.println("학생 평균		  	: " + df.format((double)scoreSum/map.size()) +"점");
		System.out.println("1등 : " + firstList + " / 점수  : " + maxScore + "점");
	}
}
// ====================================================================================================
keySet()이랑 EntrySet() 설명하시다가... 
ArrayList<Set<String>> 이런 거도 쓸 수 있다는 거...까지 얘기나옴 ㄷㄷ
// ====================================================================================================
/*
 * 카페 메뉴 관리 프로그램
 * MenuInfo 클래스
 * name ex) 아메리카노
 * price ex) 2000
 * group ex) 커피
 * type ex) 진한 커피
 * 멤버 변수들을 초기화해주는 생성자 구현
 */
package N02_컬렉션;

public class S02_MenuInfo {
	String name;
	int price;
	String group;
	String type;
	public S02_MenuInfo(String name, int price, String group, String type) {
		this.name = name;
		this.price = price;
		this.group = group;
		this.type = type;
	}
	@Override
	public String toString() {
		return name + "	: " + price + "원, " + group + "	/ " + type;
	}
	
	public String showInfo2() {
		return "[1] " + name + " [2] " + price + "원 [3] " + group + " [4] " + type;
	}
	
}
// ====================================================================================================
/*
 * map 컬렉션에 커피 메뉴들 관리
 * key : 커피 이름, value: MenuInfo 인스턴스
 * (기본 메뉴 3개 정도 넣어두기)
 * 메뉴 선택
 * [1] 메뉴보기, [2]메뉴조회, [3]메뉴추가,
 * [4] 메뉴삭제, [5]메뉴수정, [6]종료
 */
package N02_컬렉션;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

public class S02_CafeMain {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		HashMap<String, S02_MenuInfo> menu = new HashMap<>();
		menu.put("아메리카노", new S02_MenuInfo("아메리카노", 2000, "커피", "진한 커피"));
		menu.put("라떼", new S02_MenuInfo("라떼", 3500, "커피", "?? 커피"));
		
		int choice;
		String menuChoice;
		System.out.println("카페 메뉴 관리 프로그램");
		while(true) {
			System.out.println("\n[1] 메뉴보기, [2] 메뉴조회, [3] 메뉴추가, "
								+ "[4] 메뉴삭제, [5] 메뉴수정, [6] 종료");
			System.out.print("어떤 걸 하시겠습니까? : ");
			choice = sc.nextInt();
			if(choice==6) {
				System.out.println("\n카페 메뉴 관리 프로그램 종료");
				break;
			} else if(choice==1) {
				showMenu(menu);
			} else if(choice==2) {
				menuChoice = pickMenu(menu, "조회");
				getMenu(menu, menuChoice);
			} else if(choice==3) {
				putMenu(menu);
				showMenu(menu);
			} else if(choice==4) {
				menuChoice = pickMenu(menu, "삭제");
				menu.remove(menuChoice);
			} else if(choice==5) {
				menuChoice = pickMenu(menu, "수정");
				reputMenu(menu, menuChoice);
			}
		}
	}
	
	public static void showMenu(HashMap<String, S02_MenuInfo> menu) {
		System.out.println();
		for(String key : menu.keySet())
			System.out.println(menu.get(key));
	}
	
	public static void getMenu(HashMap<String, S02_MenuInfo> menu, String name) {
		System.out.println();
		System.out.println(menu.get(name));
	}
	
	public static String pickMenu(HashMap<String, S02_MenuInfo> menu, String msg) {
		Scanner sc = new Scanner(System.in);
		ArrayList<String> menuList = new ArrayList<>();
		int cnt = 0;
		System.out.println();
		for(String key : menu.keySet()) {
			menuList.add(key);
			System.out.print("[" + (++cnt) + "] " + key + " ");
		}
		System.out.print("\n어떤 메뉴를 " + msg + "하시고 싶으십니까? : ");
		return menuList.get(sc.nextInt()-1);
	}
	public static void putMenu(HashMap<String, S02_MenuInfo> menu) {
		Scanner sc = new Scanner(System.in);
		System.out.println("\n추가할 메뉴의 정보를 입력해주세요.");
		System.out.print("메뉴 이름 : ");
		String name = sc.next();
		if(menu.containsKey(name)) {
			System.out.println("기존에 있는 메뉴입니다. 조회 후 필요 시 수정해주세요.");
			return;
		}
		System.out.print("메뉴 가격 : ");
		int price = sc.nextInt();
		System.out.print("메뉴 종류 : ");
		String group = sc.next();
		sc.nextLine();
		System.out.print("메뉴 설명 : ");
		String type = sc.nextLine();
		menu.put(name, new S02_MenuInfo(name, price, group, type));
	}
	public static void reputMenu(HashMap<String, S02_MenuInfo> menu, String name) {
		Scanner sc = new Scanner(System.in);
		System.out.println();
		System.out.println(menu.get(name).showInfo2());
		System.out.print("수정할 정보를 선택해주세요. : ");
		int ch = sc.nextInt();
		String newName = name;
		switch(ch) {
			case 1:
				System.out.print("수정할 메뉴 이름 : ");
				newName = sc.next();
				menu.get(name).name = newName; 
				menu.put(newName, menu.get(name));
				menu.remove(name);
				break;
			case 2:
				System.out.print("수정할 메뉴 가격 : ");
				menu.get(name).price = sc.nextInt();
				break;
			case 3:
				System.out.print("수정할 메뉴 종류 : ");
				menu.get(name).group = sc.next();
				break;
			case 4:
				System.out.print("수정할 메뉴 설명 : ");
				sc.nextLine();
				menu.get(name).type = sc.nextLine();
				break;
		}
		getMenu(menu, newName);
	}
}
// ====================================================================================================
제네릭 458p
드디어 다시 진도 이거도 봤던 거긴 했던 듯... ㅡㅡ
// ====================================================================================================
package N03_제네릭;

import java.util.ArrayList;

class Student<T, E>{ // T는 type의 앞글자를 따왔음 뭐 걍 쓰고 싶은 거 써도 됨, 제네릭 갯수 제한은 없음, 여러개 쓰면 됨
	T studentId;
	E age;

	public Student(T studentId) {
		this.studentId = studentId;
	}
	
	public E getAge() {
		return age;
	}
	
}

public class S01_Sample {

	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		int sum;
		list.add(111);
		list.add(222);
		list.add("aaa"); // 숫자열 외에 것도 들어감!, Object형으로 변환되어 다 들어갈 수 있음
		sum = (Integer)list.get(0) + (Integer)list.get(1); // 형변환 필요! 들어가 있는 게 Object형이니까...
		
		ArrayList<Integer> list2 = new ArrayList();
		list2.add(111);
		list2.add(222);
//		list2.add("aaa"); // 숫자열 외에 것은 못 들어감!
		sum = list2.get(0) + list2.get(1); // 형변환 필요 없음!
		/*
		 * 제네릭 설정 시 이점
		 * 1. 강한 타입 체크: 원치 않는 타입의 데이터를 못 넣게 방지함
		 * 2. 형변환 불필요
		 * 어떨 때는 숫자를 처리하고 싶을 때가 있고 어떨 때는 문자를 처리하고 싶을 때도 활용 가능!
		 */
		Student<String> s1 = new Student("무지개반 12번");
		Student<Integer> s2 = new Student(20203391); // 클래스를 한 번만 만들어도 된다는 거!!!
		Student s = new Student(3333); // 이건 컬렉션과 동일하게 Object형으로 변환되어 들어감~
	}

}
// ====================================================================================================
package N03_제네릭;

import java.util.ArrayList;
import java.util.List;

class Product{} // class Product<T>{}
class Tv extends Product{}
class Audio extends Product{}

public class S02_Sample02 {

	public static void main(String[] args) {
		ArrayList<Product> list1 = new ArrayList<>(); // Product가 생략됨!, 생략 권장, new ArrayList<Product>();
//		ArrayList<Product> list2 = new ArrayList<Tv>(); // 다형성 적용 안됨!!! 무조건 선언부와 생성부가 동일해야 함!!!
		List<Product> list3 = new ArrayList<>(); // 이건 제네릭스 다형성은 아니고 List와 ArrayList에 대한 다형성이 적용된 거임, 책에 헷갈릴 수도 있게 적혀있다고 설명하심
		list1.add(new Product());
		list1.add(new Tv()); // 이건 다형성 적용됨, 위에서 안되는 건 처음 선언부할 때만 신경쓰라는 의미임!!!
	}

}
// ====================================================================================================
466p 제한된 지네릭 클래스
class FruitBox<T extends Fruit> {}
class apple extends Fruit {}
class banana extends Fruit {}
// <T>로만 쓰면 어떤 타입이든 다 설정할 수 있는데, 그중에서 Fruit 상속 받은 타입으로만 담을 수 있도록 제한을 걸어줌
// 한 종류의 제네릭을 설정한 것이 아닌 상속을 사용하여 
// 자식 한 명만 설정되는 게 아닌 모든 자식 클래스, 그러니까 좀더 넓은 범위의 제네릭을 설정가능하게 해줌

469p 와일드 카드 ?

// ====================================================================================================
package N03_제네릭;

import java.util.ArrayList;
import java.util.List;

class Shape{}
class Circle extends Shape{}
class Rectangle{}

class Box<T>{
	T shape;  // T 도형 담는 참조 변수, 무슨 도형일지 정해지지 않음, 때에 따라 다르게 
}
class Box2<T extends Shape>{
	T shape;  // T 도형 담는 참조 변수, 무슨 도형일지 정해지지 않음, 때에 따라 다르게 
}
public class S03_Sample03 {

	public static void main(String[] args) {
		Box<Shape> box1 = new Box<>();
		Box<Circle> box2 = new Box<>();
		Box<Rectangle> box3 = new Box<>();
		Box<String> box4 = new Box<>(); // 그냥 T로 하면 따지면 String도 된다는 거~
		
		Box2<Shape> box5 = new Box2<>();
		Box2<Circle> box6 = new Box2<>(); // extends 사용 하면 가능!
//		Box2<Rectangle> box7 = new Box2<>(); // 불가!
//		Box2<String> box8 = new Box2<>(); // 불가!
		
		/*		
		 * 469p 와일드 카드 ? 모든 문자를 다 받을 수 있는 만능형 문자
		 * 자바에서만 쓰는 용어는 아님
		 * 윈도우에서도 사용 가능 *.jpg
		 * 대체적으로 기호는 * 아님 ? 를 씀
		 * T 도 되는 거 아님? 왜 와일드 카드가 나왔겠음 
		 */
		List<?> list = new ArrayList<>();
		list.add(null);
//		list.add("abc"); // 애초에 list ? 는 null만 넣을 수 있음
//		? super 이건 다음시간~~~
	}
}
// ====================================================================================================
Day0703
// ====================================================================================================
잠시 제네릭 복습시간 후 바로 와일드카드 설명 도입  
// ====================================================================================================
와일드 카드랑 타입변수 - T
타입변수인 T는 객체를 생성할 때 결정
만약 그 생성된 객체에 메서드를 구현할 경우
해당 메서드의 매개변수(파라미터)를 설정할 때,
그 매개변수가 제네릭 클래스(내가 객체를 생성할 때 제네릭을 설정해야 하는 클래스, 컬렉션이나 내가 만든 제네릭을 설정한 클래스들)라면
제네릭을 T로 지정하면 타입변수인 T와 동일하므로 객체 생성시 결정된다
하지만 T와 상관없이 모든 클래스를 받는 제네릭을 설정하고 싶으면 '?' 처리함
// ====================================================================================================
package N01_제네릭;

import java.util.ArrayList;

class Student<T> {
	T score;
	public void method(T score) {
		/*
		 * 매개변수로 받은 값과 score를 더한 결과를 출력해주는 메서드를 구현하고 싶음
		 * 매개변수로 받는 값에 대한 타입은 int? String? double?
		 * this.score + score
		 */
	}
	
//	public void method3(? score) { // 와일드카드 일반 변수는 안 되는가봄 까비. 그렇담 오버로딩 안 했겠지...
//	}
	
	public void method2(ArrayList<?> list) {
		/*
		 * 매개변수로 무조건 ArrayList로 받을 거라고 고정하고,
		 * ArrayList의 제네릭은 고정하고 싶지 않을 때 
		 * ArrayList의 제네릭을 뭐라고 지정하면 좋을까?
		 * T로 하면 될까? 안됨!
		 * T로 하면 Student<String> s = new Student(); 단계에서 자료형이 고정됨!
		 * 이럴 때 나온 게 와일드카드라는 거겠지!
		 */
	}
}

public class S01_Sample01 {

	public static void main(String[] args) {
		Student<String> s = new Student();
		s.score = "100";
		s.method("95");
		ArrayList<String> strList = new ArrayList<>();
		ArrayList<Integer> intList = new ArrayList<>();
		s.method2(strList);
		s.method2(intList);
	}
}
// ====================================================================================================
// 470p 교재 예제
package N01_제네릭;

class Fruit{ }
class Apple extends Fruit { }
class Juice { }
class Juicer {
	static void makeJuice(FruitBox<? extends Fruit> box) { } // class를 만들 때 저렇게 만들어놨으면 매개변수 제네릭에는 extends Fruit 안 써도 되긴 함
}

class Box<T> { }
class FruitBox<T extends Fruit> extends Box<T> { }
public class S02_Sample02 {

	public static void main(String[] args) {
		Box box1 = new Box();
		Box<String> box2 = new Box<String>();
		Box<Fruit> box3 = new Box<Fruit>();
		
		FruitBox<Fruit> box4 = new FruitBox<>();
		FruitBox<Apple> box5 = new FruitBox<>();
		Juicer.makeJuice(box4);
		Juicer.makeJuice(box5);
	}

}
// ====================================================================================================
와일드 카드
? extends T : T와 그 자손들 (상한이 T)
? super T 	: T와 그 부모들 (하한이 T)
?			: 제한 없음, 모든 타입이 가능 (? extends Object와 동일)
// ====================================================================================================
enum(열거형) 475p
상수들의 집합
상수들을 하나로 몰아서 관리하는 집합
클래스 만들 듯이 만들 수 있다심
제한된 집합
enum Weekday{ 월요일, 화요일, 수요일, ... }
코드의 가독성 향상시켜줌
enum에 관한 메서드가 있다심. 여러가지 상수들을 공통적인 메서드로 관리해줄 거라고 함
나중에 쓰기는 할 거라고 하심
나중에 회원가입을 구현한 다음, 회원 타입을 관리자, 게스트 등으로 이렇게 열거형으로 만들어서 관리한다심 
// ====================================================================================================
package N02_열거타입;

public class S01_Card {
	static final int CLOVER = 0;
	static final int HEART = 1;
	
	static final int TWO = 0;
	static final int THREE = 1;
	
	/*
	 * 원래 Enum은 class 나 Interface 만들 듯 따로 만들어서 관리한다심
	 * enum도 보통 class처럼 첫글자는 대문자로
	 */
	enum Kind { CLOVER, HEART };  
	enum Value { TWO, THREE };
}
// ====================================================================================================
package N02_열거타입;

public class S01_CardMain {

	public static void main(String[] args) {
		if(S01_Card.CLOVER == S01_Card.TWO)
			System.out.println("같음"); // 내용물을 가지고 비교하기 때문에 "같음"으로 출력
		else
			System.out.println("다름");
		// 생각해보면 CLOVER랑 TWO는 의미상 다른 것이기 때문에 다르다고 해야 함
		
//		if(S01_Card.Kind.CLOVER == S01_Card.Value.TWO) // 애초에 종류가 다르기 때문에 비교가 안됨 
	}

}
// ====================================================================================================
package N02_열거타입;

//public enum S02_UserRole {
//	ADMIN,
//	GUEST
//}

public enum S02_UserRole {
	ADMIN("관리자"),
	GUEST("게스트"); 
	/*
	 * 이름 같은 초기값을 지정해줄 수 있음
	 * 방법은 세미콜론으로 끝내고 생성자가 필요함
	 * new S02_UserRole(name) 처럼 같은 느낌이라고 생각하면 됨!
	 * 당연하지만 매개변수는 name 하나만 있어야 하는 거 아니고 클래스 만들듯이 여러 개 있어도 됨!
	 */
	
	private String name;
	
	S02_UserRole(String name){
		this.name = name;
	}

	public String getName() {
		return name;
	}
}
// ====================================================================================================
package N02_열거타입;

import java.util.Arrays;

public class S02_Sample02 {

	public static void main(String[] args) {
		System.out.println("상수 출력		: " + S02_UserRole.ADMIN); // ADMIN 출력됨
		// values() : 열거형의 상수들을 배열로 리턴
		S02_UserRole[] role = S02_UserRole.values(); // 타입은 Enum 명!
		System.out.println("values()	: " + Arrays.toString(S02_UserRole.values()));
		// valueOf(String n) : n과 일치하는 상수를 리턴
		System.out.println("valueOf()	: " + S02_UserRole.valueOf("ADMIN"));
//		String str = S02_UserRole.valueOf("ADMIN"); // 안됨!
		S02_UserRole n = S02_UserRole.valueOf("ADMIN"); // 됨!
		S02_UserRole n1 = S02_UserRole.ADMIN; // 따지고 보면 얘랑 같은데 왜 쓸까? 이렇게는 메인에서 입력 받아서 쓴다하면 못쓰잖아! 이럴 때 valueOf 쓰는 거!
		// name() : 상수를 문자열로 리턴 
		String str = n.name();
		System.out.println("name()		: " + n.name());
		// ordianl() : 상수의 위치를 리턴, 배열처럼 0부터 시작함!
		int i = n.ordinal();
		System.out.println("ordinal()	: " + n.ordinal());
		
		System.out.println("getName()	: " + n.getName()); // getName(): 관리자
	}
}
// ====================================================================================================
어노테이션 481p
우리 이미 봤음 @Override 할 때!
자바 컴파일러에게 나는 이런 걸 할 거다 미리 알려줘서 불필요한 행동을 줄여주는 거
주석(주석은 사람이 보는 거) 같은 거
메서드, 클래스, 변수에 지정할 수 있음
자바에서는 할 때 별로 쓸일은 없지만 스프링할 때 열심히 때려 박을 거라고 그때가서 다시 본다심ㅋㅋㅋ
버전이 올라가면서 안 쓰는 기능들한테 달아주는 거

@Deprecated
예전 버전이니까 쓰지마세요 라고 알려주는 거
하위 버전이랑 호환이 안되면 안 되니 지우지는 않고 냅두는 대신 알려줌
// ====================================================================================================
package N03_어노테이션;

import java.util.ArrayList;

class Acc{
	@Deprecated
	public void add() { // 이제 이거 구리니까 쓰지말고 upgradeAdd() 쓰셈 
		System.out.println("더하기");
	}
	public void upgradeAdd() {
		System.out.println("더 좋은 더하기");
	}
}
public class S01_Sample01 {

	public static void main(String[] args) {
		Acc a = new Acc();
		a.add(); // 주석을 아무리 달아놔도 구현 코드를 찾아가서 보지는 않는다는 거! 그래서 어노테이션 넣으면! 취소선(삭선ㅋㅋㅋ) 끄임! 
		a.upgradeAdd();
		
		
		// 괄호 안에 어떤 거를 안 보이게 할 건지 써줌, 여러 개 하려면 { } 로 묶음, 자바에서 자동으로 넣으라고 알려주기도 함 
		@SuppressWarnings("unchecked")
		ArrayList al = new ArrayList<>(); // 노란줄 떠있는 게 거슬릴 때! 클래스, 메서드, 변수 위에 달면 관련된 항에 어노테이션 달아주면 됨!
	}
}
// ====================================================================================================
package N03_어노테이션;
@FunctionalInterface
public interface S02_Sample02 {
	public void method();
//	public void method2(); // @FunctionalInterface 는 인터페이스에 추상 메서드를 1개만 넣도록 해주는 거
	// 이거는 지금 당장은 활용은 못하는데 람다라는 거를 쓸 때 기능을 쓰게 하기 위해서라고 하심. 람다할 때 볼거라고 하심
}
// ====================================================================================================
/*
 * Thread 쓰레드 506p
 * 메인프로그램 실행시키면 쓰레드 작동되어 알게 모르게 사용하고 있었음... 
 * 메인이 작동되는 동안 별도의 쓰레드도 작동이 될 수 있게끔 
 * 여러 개의 코드가 동시에 작동되는 거를 쓰레드로 작동되어
 * 원래 메인이 끝나면 종료되던 걸
 * 병렬로 코드들이 동시에 처리된다고 생각하면 됨
 * 여러개 동시에 실행시키는 거.
 * 예를 들어 스캐너를 입력받는 동안 아무 것도 못했는데, 별도의 쓰레드를 하면 
 * 
 * 기본적으로 쓰레드 클래스를 상속받아서, 혹은 러너블이라는 인터페이스를 구현
 * 원래는 두가지가 더있어서 총 4가지라심 (익명 클래스로 하는 거랑 람다 사용하는 거)
 * 러너블은 왜 쓸까? 쓰레드 클래스 상속은 다른 클래스 상속받아야 할 때 못쓰니까 인터페이스로 만들 수 있게 개척해둔 거임
 * 동시에 처리되기 때문에 생기는 문제도 있다시지만 지금은 그냥 넘어간다심
 */
package N04_쓰레드;

// 쓰레드 구현 1. Thread 클래스 상속
class MyThread1 extends Thread {
	@Override
	public void run() { // 쓰레드를 실행시킬 때 실행시키는 메서드, 원하는 대로 구현하려면 오버라이딩해줘야 함!
		for(int i=0; i<10; i++) {
			try {
				Thread.sleep(1000);
			} catch (Exception e) {
				
			}
			System.out.println("1 : " + getName()); // Thread에 getName()이 구현되어 있고, 쓰레드 클래스명 출력해줌
		}
	}
}

// 쓰레드 구현 2. Runnable 인터페이스를 구현 
class MyThread2 implements Runnable {
	@Override
	public void run() {
		for(int i=0; i<10; i++) {
			try {
				Thread.sleep(1000);
			} catch (Exception e) {
				
			}
			System.out.println("2 : " + Thread.currentThread().getName()); // 인터페이스라 바로 호출 못함
		}
	}
}
public class S01_Sample01 {

	public static void main(String[] args) {
		Thread t = new MyThread1(); // 보통은 부모 클래스인 Thread로 쓴다심!
		Runnable r = new MyThread2(); // 인터페이스를 구현한 것은 Runnable로 만든 후 Thread에 넣어 줘야 함!
		Thread t2 = new Thread(r); // 인터페이스를 구현한 것은 여기까지 해야 사용할 수 있음!
		
		t.start(); // run 메서드를 호출하는 거긴 한데, .run으로 호출하면 메인에서 그냥 호출하는 거로 별도의 쓰레드를 사용되는 게 아님, start로 호출해야 별도의 쓰레드로, 실행되는 영역이 나뉘어 동작됨
		t2.start(); // 우선순위를 지정해주는 메서드는 있지만 매번 100프로 지정되는 것은 아니라심 signal과 동일함ㅎ 
		try {
			Thread.sleep(5000);
		} catch (Exception e) {
			
		}
		System.out.println("5초 후 main 종료");
	}
}
// ====================================================================================================
main의 자료 구조는 stack 구조. 
start()는 메인에 쌓인다음 start가 다른 쓰레드에서 Run()을 실행시킴
메인에 쌓인 start()는 
교재에 가비지 콜렉터에 개념이 없다시면서
사용이 끝난 거를 메모리에서 지워지도록 자바가 알아서 해준다심
// ====================================================================================================
package N04_쓰레드;

public class S02_Sample02 {

	public static void main(String[] args) {
		Runnable r = new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(2000);
				} catch (Exception e) {
					
				}
				System.out.println("Runnable : Hello");
			}
		}; // 익명클래스로 일회성 구현, ; 로 끝나야 함!!!
		Thread t = new Thread(r);
		
		Thread t1 = new Thread() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000);
				} catch (Exception e) {
					
				}
				System.out.println("Thread : Hello");
			}
		};

		t.start();
		t1.start();
		try {
			Thread.sleep(1000);
		} catch (Exception e) {
			
		}
		System.out.println("main : Hello");
	}

}
// ====================================================================================================
package N04_쓰레드;

public class S03_Sample03 {

	public static void main(String[] args) {
		long startTime = System.currentTimeMillis();
		
		for(int i=0; i<1000; i++)
			System.out.print("☆");

		long endTime = System.currentTimeMillis();
		System.out.println("첫번째 반복문 소요시간 : " + (endTime - startTime)); // 대략 6~10초 걸림
		
		for(int i=0; i<1000; i++)
			System.out.print("★");

		endTime = System.currentTimeMillis();
		System.out.println("전체 소요시간 : " + (endTime - startTime)); // 대략 10~17초 걸림
	}

}
// ====================================================================================================
/*
 * 멀티쓰레드를 하게 되면 
 * 이쪽저쪽 왔다갔다 하는 시간이 추가로 걸림(동시에 충돌되면 priority처리해야 하니까 그런 거일 듯)
 * 우선순위는 1~10인데 설정하지 않으면 기본값은 5로 설정됨, 10에 가까울 수록 먼저 처리함
 * Round-Robin 방식 순환 할당 : JVM에서 실행 자원을 할당받은 만큼만 하고 넘기는 거
 * CS 공부하시면 이런 거 공부할 거라심... 시분할 시스템 뭐 이렇거도 있고
 */
package N04_쓰레드;

class MyThread extends Thread{
	@Override
	public void run() {
		for(int i=0; i<1000; i++)
			System.out.print("☆");

		long endTime = System.currentTimeMillis();
		System.out.println("☆ 소요시간 : " + (endTime - S03_Sample04.startTime));
	}
}

public class S03_Sample04 {

	static long startTime;
	
	public static void main(String[] args) {
		Thread t = new MyThread();
		t.setPriority(1);
		startTime = System.currentTimeMillis();
		t.start();		
		
		for(int i=0; i<1000; i++)
			System.out.print("★");

		long endTime = System.currentTimeMillis();
		System.out.println("★ 소요시간 : " + (endTime - startTime));
	}

}
// ====================================================================================================
517p
쓰레드에 I/O블락킹 (I/O는 input/output 어디서나 쓰는 공용어)
쓰레드는 입력 대기 동안 그냥 다음 자원으로 넘기는 걸 말함
// ====================================================================================================
Swing은 일단 안써! 구린 거!
버전업되서 javaFX를 씀, 우린 안 할 거예요. 프론트에서 꾸밀 거니까
자바에서 띄울 필요 없다심 자바스크립트에서 할 거라심 이런 거 보지 말라심ㅋㅋㅋㅋㅋ
// ====================================================================================================
package N04_쓰레드;

import javax.swing.JOptionPane;

public class S04_Sample05 {

	public static void main(String[] args) {
		String str = JOptionPane.showInputDialog("입력");
		for(int i=0; i<30; i++) {
			try {
				Thread.sleep(1000);
				System.out.println(i);
			}catch(Exception e) {
				
			}
		}
	}
}
// ====================================================================================================
package N04_쓰레드;

import javax.swing.JOptionPane;

class Th extends Thread{

	@Override
	public void run() {
		for(int i=0; i<30; i++) {
			try {
				Thread.sleep(1000);
				System.out.println(i);
			}catch(Exception e) {
				
			}
		}
	}
	
}
public class S04_Sample06 {
	public static void main(String[] args) {
		System.out.println("메인 쓰레드 시작==========");
		Thread t = new Th();
		t.start();
		String input = JOptionPane.showInputDialog("입력"); // 입력 받는 동안 자원을 넘김
		System.out.println("입력 : " + input);
		System.out.println("메인 쓰레드 종료==========");
	}

}
// ====================================================================================================
package N04_쓰레드;

class Thread1 extends Thread{
	@Override
	public void run() {
		for(int i=0; i<300; i++)
			System.out.print("☆");
	}
}

class Thread2 extends Thread{
	@Override
	public void run() {
		for(int i=0; i<300; i++)
			System.out.print("★");
	}
}
public class S05_Sample07 {
	public static void main(String[] args) {

		Thread t1 = new Thread1();
		Thread t2 = new Thread2();
		System.out.println("기본 우선 순위 : " + t1.getPriority());
		System.out.println("기본 우선 순위 : " + t2.getPriority());
		
		t1.setPriority(10);
		t2.setPriority(1);
		System.out.println("변경 후 우선 순위 : " + t1.getPriority());
		System.out.println("변경 후 우선 순위 : " + t2.getPriority());
		
		t1.start();
		t2.start();
	}
}
// 521p처럼 멀티코어로 실행시킬 수 있는 방법이 있는지?? 방법이 어떻게 되는지?? 있긴 있을 건데 해본적은 없어서 찾아보셔야 한다심
MATLAB은 실행 시 설정해줄 수 있는데, java는 실행할 때 인자값을 받는 게...있었던 거 같기도 하고 기억이 나지 않는군ㅋㅋㅋ
// ====================================================================================================
523p
쓰레드 그룹이라는 게 있었는데 이거야 말로 JDK 9버전부터 Deprecated
대신에 쓰레드 풀이라는 게 생겼다심 둘다 보겠다심
쓰레드가 작동될 수 있는 영역을 미리 할당해뒀다는 거임
공간의 크기 설정도 해놓을 수 있음 eg. 쓰레드를 3개 만들 공간을 먼저 만들어 줄거야 // 그렇지만 넘친다고 해서 문제가 생기진 않음. 대기했다가 공간이 남았을 때 들어간다던지 공간을 추가로 할당해서 쓴다든지. 초과했을 때의 장점이 크기 때문에 쓴다심
// ====================================================================================================
package N04_쓰레드;

class A implements Runnable{
	
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName() + " 시작");
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
		}
		System.out.println(Thread.currentThread().getName() + " 종료");
		
	}
	
}

public class S06_Sample08 {

	public static void main(String[] args) {
		ThreadGroup g = new ThreadGroup("그룹명"); // 그룹명은 알아서 작명해~, 그룹명이란 그룹만 일단 만들어진 상태
		Thread t1 = new Thread(g, new A(), "쓰레드1"); // t1에 대한 이름도 "쓰레드1"로 지정해줄 수 있음!
		Thread t2 = new Thread(g, new A(), "쓰레드2");
		t1.setPriority(10);
		t1.start();
		t2.start();
		g.list(); // java.lang.ThreadGroup[name=그룹명,maxpri=10] Thread[쓰레드1,10,그룹명] Thread[쓰레드2,5,그룹명]
		try {
			Thread.sleep(2000);
			System.out.println("현재 실행 중인 쓰레드 수 : " + g.activeCount());
		} catch (InterruptedException e) {
		}
	}

}
// ====================================================================================================
package N04_쓰레드;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class B implements Runnable{
	String name;
	
	public B(String name) {
		this.name = name;
	}

	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName() + " " + name + " 시작");
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
		}
		System.out.println(Thread.currentThread().getName() + " " + name + " 종료");
		
	}
	
}

public class S07_Sample09 {

	public static void main(String[] args) {
		// ExecutorService 쓰레드의 생명주기(life cycle)를 담당하는 인터페이스, 기본적으로 인터페이스는 객체 인스턴스 생성이 안되니까 메서드를 활용함 
		ExecutorService es = Executors.newFixedThreadPool(3); // 매개변수는 크기 지금은 쓰레드 3개짜리
		// 생명주기 : 생성 실행 종료 삭제
		
		es.execute(new B("abc")); // 매개변수 안에는 실행시킬 쓰레드가 들어가야 함
		es.shutdown(); // 실행되는 쓰레드까지만 실행시키고 풀을 중지시키는 거도 있음
//		es.shutdownNow(); // 이거는 걍 강제 종료인 듯, 언급은 안 됐지만 걍 있길래 봄ㅎ
		
		for(int i=0; i<10; i++)
			es.execute(new B("B"+(i+1)));
	}

}
// ====================================================================================================
데몬 쓰레드는 메인이 종료되면 종료됨 eg. 가비지 컬렉터, 워드프로세서 자동저장, 화면자동갱신
지정해주는 것도 setDeamon(true)로 걍 간단하다. 확인도 isDaemon()
// ====================================================================================================
package N04_쓰레드;
class C implements Runnable{

	@Override
	public void run() {
		while(true) {
			try {
				Thread.sleep(3000);
				System.out.println("자동 저장");
			} catch (InterruptedException e) {
			}
		}
	}
	
}
public class S08_Sample10 {

	public static void main(String[] args) {
		Thread t = new Thread(new C());
		t.setDaemon(true);
		t.start();
		for(int i=0; i<10; i++) {
			try {
				Thread.sleep(1000);
				System.out.println(i+1);
			} catch (InterruptedException e) {
			}
		}
		System.out.println("메인 종료");
	}
}
// ====================================================================================================
쓰레드 상태 제어
				일시 정지
                   ↕
쓰레드 생성 → 실행 대기 → 실행 → 쓰레드 소멸
실행중 → 일시정지 요청 → 일시정지 → 재실행 요청 → 실행 대기 → 실행
요런 루틴임. 재실행 요청이 된다음 실행 대기로 먼저 넘어갔다가 실행으로 넘어간다는 거에 유의하시길!
동기화는 나중에 할 거라심, 스케쥴링은 뭐 이런 걸 말한다고 퉁치심
stop(), suspend(), resume()은 interupt 문제를 많이 야기시켜서 deprecated됐다심
// ====================================================================================================
package N04_쓰레드;
class IThread extends Thread{

	@Override
	public void run() {
		try {
			int i=1;
			while(true) {
				System.out.println(i++);
				Thread.sleep(1000);
			}
		} catch (InterruptedException e) {
		}
		System.out.println("쓰레드 종료");
	}
	
}
public class S09_Sample11 {

	public static void main(String[] args) {
		Thread t = new IThread();
		t.start();
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
		}
		t.interrupt();
		/* 
		 * InterruptedException을 발생시켜서 중지시키는 거, 그러니까 식당에서 저기요 같은 느낌!
		 * 그런데 잠깐이라도 멈춰 있어야 중단이 되는 거 (이런 조건이 걸림)
		 * 그래서 위에 sleep이 주석처리되어 있어서 계속 실행중인 거면 인터럽트 발생이 안됨
		 * "대기하는 도중에 생기는 문제"를 발생시키지 못함
		 * 데드락, 교착상태 기약없이 무한정 기다리는 상태
		 * 어쨌든 interrupt()는 안전하게 중지시킬 수 있는 방법 중 하나...sleep 같은 게 있어야 한다는 거 꼭 확인 필요!
		 * 메서드 이용 말고 flag를 이용해서 중지하는 방법도 있다심... 용어가 여기서도 나오는 건가 으으으
		 */
		System.out.println("메인 종료");
	}
}
// ====================================================================================================
package N04_쓰레드;

class FlagThread extends Thread{

	private boolean stop = false; // 초기값은 false
	
	public void setStop(boolean stop) {
		this.stop = stop;
	}

	@Override
	public void run() {
		int i=1;
		while(!stop)
			System.out.println(i++);
		System.out.println("쓰레드 종료");
	}
	
}
public class S10_Sample12 {

	public static void main(String[] args) {
		FlagThread t = new FlagThread(); // Thread t = new FlagThread(); 이걸로 하면 stop flag 사용 못함 
		t.start();
		try {
			Thread.sleep(50);
		} catch (InterruptedException e) {
		}
		t.setStop(true);
		System.out.println("메인 종료");
	}

}
// ====================================================================================================
package N04_쓰레드;

class DepreThread implements Runnable{

	@Override
	public void run() {
		while(true) {
			System.out.println(Thread.currentThread().getName());
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
			}
		}
	}
}

public class S11_Sample13 {

	public static void main(String[] args) {
		Thread[] t = new Thread[3];
		for(int i=0; i<t.length; i++) {
			t[i] = new Thread(new DepreThread(), "쓰레드"+(i+1));
			t[i].start();
		}
		try {
			Thread.sleep(2100);
			t[0].suspend();
			Thread.sleep(2100);
			t[1].suspend();
			Thread.sleep(2100);
			t[0].resume();
			Thread.sleep(2100);
			t[2].stop();
			t[1].resume();
			Thread.sleep(2100);
			t[0].stop();
			t[1].stop();
		} catch (InterruptedException e) {
		}
		System.out.println("메인 종료");
	}

}
// ====================================================================================================
yield 는 양보하는 거
join 은 다른 쓰레드가 종료될 때까지 대기 
// ====================================================================================================
package N04_쓰레드;
class ThreadA extends Thread{
	boolean stop;
	boolean work = true;
	
	@Override
	public void run() {
		while(!stop) {
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
			}
			if(work)
				System.out.println("쓰레드A 작동중");
			else {
				System.out.println("쓰레드A 양보중");
				Thread.yield();
			}
		}
		System.out.println("쓰레드A 종료");
	}
}

class ThreadB extends Thread{
	boolean stop;
	boolean work = true;
	
	@Override
	public void run() {
		while(!stop) {
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
			}
			if(work)
				System.out.println("쓰레드B 작동중");
			else {
				System.out.println("쓰레드B 양보중");
				Thread.yield();
			}
		}
		System.out.println("쓰레드B 종료");
	}
}

class SumThread extends Thread{
	int sum=0;
	@Override
	public void run() {
		for(int i=1; i<=100; i++)
			sum += i;
	}
}
public class S12_Sample14 {

	public static void main(String[] args) {
		ThreadA ta = new ThreadA();
		ThreadB tb = new ThreadB();
		ta.start();
		tb.start();
		try {
			
			Thread.sleep(3);
			ta.work = false;
			System.out.println("A 양보 시작");
			Thread.sleep(3);
			ta.work = true;
			System.out.println("A 작동 재시작");
			Thread.sleep(3);
			tb.work = false;
			ta.work = false;
			System.out.println("A, B 동시 양보 시작");
			Thread.sleep(3);
			ta.stop = true;
			tb.stop = true;
			System.out.println("A, B 종료");
		} catch (InterruptedException e) {
		}
		SumThread s = new SumThread();
		s.start();
		try {
			s.join(); // join은 예외처리를 강요함...
		} catch (InterruptedException e) {
		}
		System.out.println("sum 결과 : " + s.sum);
	}
}
// ====================================================================================================
동기화: 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것
하다가 멈춘 공통된 데이터를 작업할 수 없게끔 락을 걸어주는 거
다른 쓰레드가 작업할 때는 접근 안됨
메서드나 영역 앞에 synchronized 키워드만 넣어주기만 하면 됨
public synchronized void method(){ } 한개만 실행시켜줌, 다른 쓰레드는 못씀, 이런 걸 동기화 메서드라고 함.
그래서 그냥 메서드를 만든 후 내부 특정 영역에만 쓰레드가 한 개만 접근하게 하고 싶은 경우
public void method(){
	// 여러 쓰레드 접근 가능한 영역
	synchronized(공유 객체){
		// 특정 코드만 한개의 쓰레드만 접근하도록 하고 싶을 때
	}
	// 여러 쓰레드 접근 가능한 영역
}
특정 영역만 설정해놓으면 조금더 자원을 효율적으로 관리할 수 있음
이런 걸 애초에 "동기화 블럭"이라는 용어를 씀
// ====================================================================================================
Day0704
// ====================================================================================================
동기화 539p
object클래스에 락(lock)이라는 객체가 실제로 있음,
임의 쓰레드가 임계영역에 돌입하면 락이라는 객체를 얻고,
모두 실행하면 락이 소멸되고 모든 쓰레드가 돌입할 수 있게 됨
synchronized를 쓴다고 모든 문제가 해결되지는 않고, 쓰면서 생기는 문제도 있다심...이따가 코드 작성하면서 볼거라심
여러개 쓰레드가 착하게 순서대로 합시다. 라고 하는 게 아니라...
스케줄러라는 게 있어서 스케줄러가 짠만큼 작동하는 건데,
자원 낭비가 있는 건가... 실제 쓰레드는 할만큼 다 하고, 다 했다고 해서 넘기지 않음
계속 두드림
이런 문제점을 해결하기 위해서 나타난 메서드가 wait()랑 notify()
wait()는 일시정지 시킴
notify()는 일시정지(정확히는 대기 상태)인 메서드를 되돌리는(실행시키는) 메서드
두개를 잘 활용하면 여러 쓰레드가 번갈아가면서 작동할 수 있도록 할 수 있음!
// ====================================================================================================
// 539p 예제
package N01_쓰레드;

class Account{
	private int balance = 1000;

	public int getBalance() {
		return balance;
	}
	public synchronized void withdraw(int money) {
		if(balance >= money) {
			try {
				Thread.sleep(1000);
			}catch(Exception e) {
			}
			balance -= money;
		}
	}
}

class RunnableEx implements Runnable {
	Account account = new Account();
	@Override
	public void run() {
		while(account.getBalance() > 0) {
			int money = (int)(Math.random()*3+1)*100;
			account.withdraw(money);
			System.out.println(Thread.currentThread().getName() + " 잔액 : " + account.getBalance());
		}
	}
}

public class S01_Sample01 {

	public static void main(String[] args) {
//		Thread t1 = new Thread(new RunnableEx());
//		Thread t2 = new Thread(new RunnableEx());
//		t1.start();
//		t2.start();
		Runnable r = new RunnableEx();
		new Thread(r).start(); // 이거는 인스턴스에 담지 않아서 start 시키고 끝, 그 이후엔 접근 불가 
		new Thread(r).start(); // account를 공용으로 사용하려고 이렇게 한 건가 ㄷㄷ
	}
}
// ====================================================================================================
대기 상태랑 정지 상태는 다른 거.
대기는 언제든 신호가 오면 실행시킬 수 있는 거고 정지는 신호가 와도 실행시킬 수 없는 상태
wait()하면 정지되는 거고
notify()하면 정지상태의 쓰레드를 모두 대기 상태로 만드는 거. not 실행
// ====================================================================================================
package N01_쓰레드;

import java.util.ArrayList;

class Table{
	String[] dishNames = {"donut","donut","burger"};
	final int MAX_FOOD=6;
	private ArrayList<String> dishes = new ArrayList<>();
	
	public synchronized void add(String dish) {
		if(dishes.size() >= MAX_FOOD)
			return;
		dishes.add(dish);
		System.out.println("Dishes : " + dishes.toString()); // toString 생략가능
	}
	
	public boolean remove(String dishName) {
		synchronized (this) {
			while(dishes.size() == 0) {
				String name = Thread.currentThread().getName();
				System.out.println(name + " is waiting");
				try { Thread.sleep(500); }catch(Exception e) { }
			} // while 종료
			for(int i=0; i<dishes.size(); i++) {
				if(dishName.equals(dishes.get(i))) {
					dishes.remove(i);
					return true;
				}
			}
		} // synchronized 종료
		return false;
	}
	
	public int dishNum() { // 메뉴판 개수 넘겨주는 메서드
		return dishNames.length;
	}
}

class Cook implements Runnable{
	private Table table;

	Cook(Table table) {
		this.table = table;
	}

	@Override
	public void run() {
		while(true) {
			int idx = (int)(Math.random()*table.dishNum());
			table.add(table.dishNames[idx]);
			try { Thread.sleep(100); }catch(Exception e) { }
		}
	}
	
}

class Customer implements Runnable{
	private Table table;
	private String food;
	
	public Customer(Table table, String food) {
		this.table = table;
		this.food = food;
	}
	
	boolean eatFood() {
		return table.remove(food);
	}
	
	@Override
	public void run() {
		while(true) {
			try { Thread.sleep(100); }catch(Exception e) { }
			String name = Thread.currentThread().getName();
			if(eatFood())
				System.out.println(name + " ate a " + food);
			else
				System.out.println(name + " failed to eat");
		}
	}
	
}

public class S02_Sample02 {

	public static void main(String[] args) {
		Table table = new Table();
		new Thread(new Cook(table),"COOK").start();
		new Thread(new Customer(table, "donut"), "손님1").start();
		new Thread(new Customer(table, "burger"), "손님2").start();
		try { Thread.sleep(2000); }catch(Exception e) { }
		System.exit(0);
	}
}
// ====================================================================================================
package N01_쓰레드;

import java.util.ArrayList;

class Table1{
	String[] dishNames = {"donut","donut","burger"};
	final int MAX_FOOD=6;
	private ArrayList<String> dishes = new ArrayList<>();
	
	public synchronized void add(String dish) {
		while(dishes.size() >= MAX_FOOD) {
			String name = Thread.currentThread().getName();
			System.out.println(name + " is waiting...");
			try {
				wait();
				Thread.sleep(500);
			} catch(Exception e) {
			}
		}
//		if(dishes.size() >= MAX_FOOD)
//			return;
		dishes.add(dish);
		notify();
		System.out.println("Dishes : " + dishes.toString()); // toString 생략가능
	}
	
	public void remove(String dishName) {
		synchronized (this) {
			String name = Thread.currentThread().getName();
			while(dishes.size() == 0) {
				System.out.println(name + " is waiting");
				try { 
					wait();
					Thread.sleep(500);
				} catch(Exception e) {
				}
			} // while 종료
			while(true) {
				for(int i=0; i<dishes.size(); i++) {
					if(dishName.equals(dishes.get(i))) {
						dishes.remove(i);
						notify();
						return;
					}
				}
				try {
					System.out.println(name + " is waiting...");
					wait();
					Thread.sleep(500);
				} catch(Exception e) {
				}
			}
		} // synchronized 종료
//		return false;
	}
	
	public int dishNum() { // 메뉴판 개수 넘겨주는 메서드
		return dishNames.length;
	}
}

class Cook1 implements Runnable{
	private Table1 table;

	Cook1(Table1 table) {
		this.table = table;
	}

	@Override
	public void run() {
		while(true) {
			int idx = (int)(Math.random()*table.dishNum());
			table.add(table.dishNames[idx]);
			try { Thread.sleep(100); }catch(Exception e) { }
		}
	}
	
}

class Customer1 implements Runnable{
	private Table1 table;
	private String food;
	
	public Customer1(Table1 table, String food) {
		this.table = table;
		this.food = food;
	}
	
//	boolean eatFood() {
//		return table.remove(food);
//	}
	
	@Override
	public void run() {
		while(true) {
			try { Thread.sleep(100); }catch(Exception e) { }
			String name = Thread.currentThread().getName();
			table.remove(food);
//			if(eatFood())
				System.out.println(name + " ate a " + food);
//			else
//				System.out.println(name + " failed to eat");
		}
	}
	
}

public class S03_Sample3 {

	public static void main(String[] args) {
		Table1 table = new Table1();
		new Thread(new Cook1(table),"COOK").start();
		new Thread(new Customer1(table, "donut"), "손님1").start();
		new Thread(new Customer1(table, "burger"), "손님2").start();
		try { Thread.sleep(5000); }catch(Exception e) { }
		System.exit(0);
	}
}
// ====================================================================================================
package N01_쓰레드;

class WorkObject {
	public synchronized void methodA() {
		System.out.println("메서드A 실행");
		notify();
		try {
			wait();
		} catch (InterruptedException e) {
		}
	}
	public synchronized void methodB() {
		System.out.println("메서드B 실행");
		notify();
		try {
			wait();
		} catch (InterruptedException e) {
		}
	}
}
class ThreadA extends Thread {
	WorkObject wo;

	public ThreadA(WorkObject wo) {
		this.wo = wo;
	}

	@Override
	public void run() {
		for(int i=0; i<10; i++) {
			System.out.print(Thread.currentThread().getName() + " ");
			wo.methodA();
		}
	}
}
class ThreadB extends Thread {
	WorkObject wo;

	public ThreadB(WorkObject wo) {
		this.wo = wo;
	}

	@Override
	public void run() {
		for(int i=0; i<10; i++) {
			System.out.print(Thread.currentThread().getName() + " ");
			wo.methodB();
		}
	}
}
public class S04_Sample04 {

	public static void main(String[] args) {
		WorkObject wo = new WorkObject();
		ThreadA ta = new ThreadA(wo);
		ThreadB tb = new ThreadB(wo);
//		ThreadA tc = new ThreadA(wo);
//		ThreadB td = new ThreadB(wo);
		ta.start();
		tb.start();
//		tc.start();
//		td.start();
	}
}
// ====================================================================================================
/*
 * 1부터 10까지를 출력하는 쓰레드를 생성
 * 단, 두 쓰레드가 번갈아가면서 숫자를 출력해야 함
 */
package N01_쓰레드;

class NumThread extends Thread {
	String name;
	int num;
	Object lock;

	public NumThread(String name, int num, Object lock) {
		this.name = name;
		this.num = num;
		this.lock = lock;
	}

	@Override
	public void run() {
		while(num<=10) {
			synchronized(lock) {
				System.out.println(name + " : " + num);
				num = num+2;
				lock.notify();
				try {
					lock.wait();
				} catch (Exception e) {
				}
			}
		}
	}
}
public class S05_Sample06 {

	public static void main(String[] args) {
		
		Object lock = new Object();
		NumThread ta = new NumThread("A", 1, lock);
		NumThread tb = new NumThread("B", 2, lock);
		ta.start();
		tb.start();
		try { Thread.sleep(500); }catch(Exception e) { }
		System.exit(0);
	}
}
// ====================================================================================================
package N02_쓰레드2;

public abstract class User {
	String userId;
	int hp;
}
// ====================================================================================================
package N02_쓰레드2;

public interface Msg {
	void attackMsg(int dam);	// 공격 시 출력 메서드
	void userSkillMsg(); 		// 스킬 사용시 출력 메서드
	void hpMsg();				// 체력 출력 메서드
	void endMsg();				// 종료 출력 메서드
	
}
// ====================================================================================================
package N02_쓰레드2;

public class Character extends User implements Msg{

	public Character(String userId, int hp) {
		this.userId = userId;
		this.hp = hp;
	}
	
	@Override
	public void attackMsg(int dam) {
		System.out.println(userId + "가 상대에게 " + dam + "의 데미지를 입힘");
	}

	@Override
	public void userSkillMsg() {
		System.out.println(userId + "가 상대에게 30의 데미지를 입힘");
	}

	@Override
	public void hpMsg() {
		System.out.println(userId + "의 남은 체력 : " + hp);
	}

	@Override
	public void endMsg() {
		System.out.println(userId + "가 상대에게 승리");
	}
}
// ====================================================================================================
package N02_쓰레드2;

public class PlayUser extends Thread {
	Character user;
	Character com;
	public PlayUser(Character user, Character com) {
		this.user = user;
		this.com = com;
	}
	@Override
	public void run() {
		int damage;
		int coolTime;
		try {
			while(true) {
				coolTime = (int)(Math.random()*3)+1;
				Thread.sleep(coolTime*1000);
				if((int)(Math.random()*10)==5) {
					user.userSkillMsg();
					com.hp -= 30;
				} else {
					damage = (int)(Math.random()*10)+1;
					user.attackMsg(damage);
					com.hp -= damage;
				}
				
				System.out.print("\t");
				com.hpMsg();
				if(com.hp <= 0) {
					user.endMsg();
					System.exit(0);  // break하면 나머지 쓰레드는 종료가 안되니까...break는 여기서 안 됨, 종료 flag 변수 생성 권장하심 귀찮아서 안하셨으면서...헤헷
				}
			}
		} catch(Exception e) {
			
		}
	}
}
// ====================================================================================================
package N02_쓰레드2;

public class PlayCom extends Thread {
	Character user;
	Character com;
	public PlayCom(Character user, Character com) {
		this.user = user;
		this.com = com;
	}
	@Override
	public void run() {
		int damage;
		int coolTime;
		try {
			while(true) {
				coolTime = (int)(Math.random()*3)+1;
				Thread.sleep(coolTime*1000);
				if((int)(Math.random()*10)==5) {
					com.userSkillMsg();
					user.hp -= 30;
				} else {
					damage = (int)(Math.random()*10)+1;
					com.attackMsg(damage);
					user.hp -= damage;
				}
				System.out.println(user.userId + " 의 남은 체력 : " + user.hp);
				if(user.hp <= 0) {
					com.endMsg();
					System.exit(0);
				}
			}
		} catch(Exception e) {
			
		}
	}
}
// ====================================================================================================
/*
 * 쓰레드를 이용해서 User, Com 전투함
 * 기본 데미지 1~10 랜덤
 * 10% 확률로 스킬 사용 (데미지 30)
 * 기본 체력은 둘다 100
 * 공격 속도는 1~3초 랜덤
 */
package N02_쓰레드2;

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print("유저 아이디 입력 : ");
		String id = sc.next();
		Character user = new Character(id, 50);
		Character com = new Character("com", 50);
		PlayUser playUser = new PlayUser(user, com);
		PlayUser playCom = new PlayUser(com, user);
		playUser.start();
		playCom.start();
	}
}
// ====================================================================================================
람다 ( Lamda ) 552p
함수라고 생각하면 되는데, 자바에서는 함수가 없고 메서드라고 표현하지만
결국 함수나 메서드나 같은 걸로 생각해도 된다심
왜 구별하냐면
자바는 객체지향이라 클래스 내부에서만 만들 수 있다는 의미를 내포 
언어마다 다른데, 클래스 바깥에 함수를 생성할 수 있는...
자바스크립트에서는 함수라고 함(물론 자바스크립트에서는 클래스도 있어서 클래스 안에는 메서드 생성할 수 있긴 한데...)
함수형 프로그래밍...
하나의 표현식
자바랑은 거리가 멀지만 너무 너무 편함...메서드 만드려면 클래스 만들어야 하고 메서드 호출하려면 또 인스턴스 생성해야 하고 귀찮음!
list.중복제거.정렬.숫자변경 ... chaining
like list.add().remove(). ... (이건 스트림할 때 본다심)
Arrays.setAll( arr, (i) -> (int)(Math.random()*5)+1 );
화살표가 들어가다 보니깐 '화살표 함수'라고도 한다심
*기본 형식
(매개 변수) -> {
	실행시킬 코드;
};
인터페이스 AA = (int a, int b) -> { return a+b; }
code가 한줄일 경우 return 생략 가능 (int a, int b) -> { a+b; }, 중괄호랑 ;도 생략
자료형도 생략가능 (a, b) -> a+b; // 이거는 인터페이스에서 자료형을 유추해서 알 수 있어서...
매개변수가 없을 경우 그냥 ()를 쓰면 됨, 이때는 괄호 생략하면 안 됨!
느낌은 익명 클래스, 익명 객체... 람다도 익명 객체!
람다는 인터페이스가 필요함!
인터페이스에 있는 추상 메서드를 객체 생성 없이  
// ====================================================================================================
package N03_람다;

@FunctionalInterface
public interface S01_Calc {
	static int AAA = 10;
	int sum(int a, int b);
}
// ====================================================================================================
package N03_람다;

public class S01_Sample01 {

	public static void main(String[] args) {
		S01_Calc c = (int a, int b) -> { return a+b; };
		c = (a, b) -> a+b; // 한 줄일 때 중괄호, return 생략 가능(두줄 이상이면 불가능), 자료형은 인터페이스에서 이미 알려줬으니 생략 가능
		// 매개변수가 하나이면 (a) 대신 a 로 괄호 생략 가능
		/*
		 * 람다를 사용할 때 단점은 다른 클래스에서는 새로 생성해야 함(단점이자 장점이라심...)
		 * 람다 용 인터페이스(함수형 인터페이스)에서는 추상메서드가 1개로 고정됨! @FunctionalInterface
		 */
		System.out.println(c.sum(5, 10));
		System.out.println(c.AAA); // 이건 되넹...
		
		// 람다로 쓰레드 생성하는 거 이제 할 수 있음!
		new Thread(()-> {
			for(int i=0; i<10; i++)
				System.out.println("람다로 쓰레드 만들었어요!!!");
		}).start(); // 중괄호 안에 들어간 코드가 결국 run을 구현한 거임
		try { Thread.sleep(500); }catch(Exception e) { }
		System.out.println("메인 종료");
	}
}
// ====================================================================================================
람다용 인터페이스도 따로 있음, 일단 연습 예제 후 이따가 볼거라심!
// ====================================================================================================
package N03_람다;

@FunctionalInterface
interface Study {
	public void gugudan(int n);
}

@FunctionalInterface
interface Study2 {
	public int sum(int[] arr);
}
public class S02_Sample02 {

	public static void main(String[] args) {
		Study s = n -> {
			for(int i=1; i<=9; i++)
				System.out.println(n + "*" + i + "=" + n*i);
		};
		s.gugudan(9);
		
		Study2 s2 = arr -> {
			int sum = 0;
			for(int i=0; i<arr.length; i++)
				sum += arr[i];
			return sum;
		};
		int[] arr = { 80, 90, 100, 30, 40 };
		System.out.println(s2.sum(arr));
	}
}
// ====================================================================================================
제공되는 함수형 인터페이스
java.lang.Runnable / void run()
Supplier<T> / T get()
Consumer<T> / void accept(T t)
Function<T, R> / R apply(T t)
Predicate<T> / boolean test(T t) 
이거 말고 더 있다심...
package java.util.function 가보면 더 있긴 함...
IntFunction 같은 거도 종류별로 있고...매개변수 2개 있는 거 BiConsumer도 있고
// ====================================================================================================
package N03_람다;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class S03_Sample03 {

	public static void main(String[] args) {
		
		Supplier<String> getHello = () -> { // 함수형 인터페이스 공용이기 때문에, 변수이름을 식별 가능하게 하는 편
			return "hello";
		};
		System.out.println(getHello.get());
		
		Consumer<Integer> setLoop = n -> {
			System.out.println("Consumer 연습");
			for(int i=1; i<=n; i++)
				System.out.println(i);
		};
		setLoop.accept(3);
		
		Function<String, Integer> f = str -> Integer.parseInt(str);
		System.out.println(f.apply("123") + 1);
		
		Predicate<Integer> isEven = n -> n%2==0;
		System.out.println(isEven.test(50));
		System.out.println(isEven.test(101));
		
		Predicate<Integer> isOdd = n -> n%2==1;
		System.out.println(isOdd.test(50));
		System.out.println(isOdd.test(101));
	}

}
// ====================================================================================================
Day0705
// ====================================================================================================
함수형 인터페이스 560p
매개변수가 2개인 건 Bi만 붙이면 됨
Supplier<T> / T get() 이건 매개변수가 없었던 거니까 없음
BiConsumer<T, U> / void accept(T t, U u)
BiFunction<T, U, R> / R apply(T t, U u)
BiPredicate<T, U> / boolean test(T t, U u)

UnaryOperator<T> / T apply(T t) // Function<T, R>에서 제네릭이 모두 같을 때 귀찮으니까!
BinaryOperator<T> / T apply(T t1, T t2) // BiFunction<T, U, R>에서 제네릭이 모두 같을 때 귀찮으니까!
// ====================================================================================================
package N01_람다;

import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.BinaryOperator;
import java.util.function.UnaryOperator;

public class S01_Sample01 {

	public static void main(String[] args) {
		BiConsumer<String, Integer> b1 = (str, n) -> System.out.println(str + " " + n);
		System.out.print("BiConsumer b1.accept(\"hello\", 123) : ");
		b1.accept("hello", 123);
		BiFunction<String, Integer, String> b2 = (str, n) -> str + " " + n;
		System.out.print("BiFunction b2.apply(\"hello\", 123)  : ");
		System.out.println(b2.apply("hello", 123));
		BiPredicate<Integer, Integer> b3 = (n1, n2) -> n1>n2;
		System.out.print("BiPredicate b3.test(123, 456)      : ");
		System.out.println(b3.test(123, 456));
		
		BinaryOperator<Integer> bo = (n1, n2) -> n1>n2? n1:n2; // BiFunction<T, U, R>에서 제네릭이 모두 같을 때
		System.out.print("BinaryOperator bo.apply(123, 456)  : ");
		System.out.println(bo.apply(123, 456));
		UnaryOperator<String> uo = str -> str + " 123"; // 마찬가지로 Function<T, R>에서 제네릭이 모두 같을 때
		System.out.print("UnaryOperator uo.apply(\"hello\")    : ");
		System.out.println(uo.apply("hello"));
	}
}
// ====================================================================================================
package N01_람다;

import java.util.ArrayList;
import java.util.HashMap;

public class S02_Sample02 {

	public static void main(String[] args) {
		ArrayList<Integer> list = new ArrayList<>();
		for(int i=0; i<10; i++)
			list.add(i);
		for(Integer num:list)
			System.out.print(num + " ");
		// 이렇게 해왔지만... 이제 람다를 배웠으니 컬렉션을 편하게 써보자. forEach!
		System.out.println();
		System.out.print("forEach의 매개변수는 Consumer<T> / void accept(T t)     : ");
		list.forEach((num)->System.out.print(num + " "));
		System.out.println();
		// map은 key, value가 있어서 forEach 사용법이 좀 다르다심 이따가 볼거라심
		
		// remove도 반복문 직접 돌리지 않고 조건을 걸어서 할 수 있음!
		list.removeIf(num->num%2==0);
		System.out.print("removeIf의 매개변수는 Predicate<T> / boolean test(T t)  : ");
		System.out.println(list);
		
		// replace도 String에 메서드가 있는데 컬렉션에서는 replaceAll이 있음
		list.replaceAll(num->num+1);
		System.out.print("replaceAll의 매개변수는 UnaryOperator<T> / T apply(T t) : ");
		System.out.println(list);
		
		// map 람다 사용법!
		HashMap<String, Integer> map = new HashMap<>();
		map.put("고길동", 50);
		map.put("둘리", 10);
		System.out.print("map의 forEach의 매개변수는 BiConsumer<T, U> / void accept(T t, U u) : ");
		map.forEach((key, value)->System.out.print(key + "-" + value + " "));
	}
}
// ====================================================================================================
package N01_람다;

import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;

class Calc{
	public static int staticMethod(int x, int y) {
		return x+y;
	}
	public int method(int x, int y) {
		return x+y;
	}
}

class LambdaMember {
	String name;
	int age;
	public LambdaMember() {
		System.out.println("기본생성자 호출");
	}
	public LambdaMember(String name) {
		System.out.println("name 생성자 호출");
		this.name = name;
	}
	public LambdaMember(String name, int age) {
		System.out.println("name, age 생성자 호출");
		this.name = name;
		this.age = age;
	}
}
public class S03_Sample03 {

	public static void main(String[] args) {
		Function<String, Integer> f = str -> Integer.parseInt(str);
		/*
		 * 메서드 참조 566p
		 * 함수형인터페이스 변수명 = 클래스명::메서드이름
		 * 함수형인터페이스 변수명 = 참조변수::메서드이름
		 */
		Function<String, Integer> f2 = Integer::parseInt; // ㅋㅋㅋ이클립스에서 기울어져 있으면(parseInt) static 메서드 명쾌하다ㅋㅋㅋ
		BinaryOperator<Integer> f3 = Calc::staticMethod;
//		BinaryOperator<Integer> f4 = Calc::method; // 이건 안돼~
		Calc c = new Calc();
		BinaryOperator<Integer> f4 = c::method; // 이렇게는 돼~
		System.out.println(f3.apply(123, 456) + " " + f4.apply(123, 456));
		/*
		 * 생성자의 메서드 참조 567p
		 * 이건 매개변수 막 다 끌어올 필요가 없어서 편하긴 한듯...
		 * 아니 근데 뭐 어차피 호출할거면 그냥 기존 방식에서 별로 줄지 않는 거 아닌가. 메서드 참조도 참조변수로 메서드참조하는 것도 그닥... 이건 왜 쓰는 거지...ㄷㄷ
		 */
		Supplier<LambdaMember> s 					= LambdaMember :: new; // () -> new LambdaMember();
		Function<String, LambdaMember> func			= LambdaMember :: new; // (name) -> new LambdaMember(name);
		BiFunction<String, Integer, LambdaMember> b = LambdaMember :: new; // (name, age) -> new LambdaMember(name, age);
		LambdaMember m = b.apply("고길동", 50);
	}
}
// ====================================================================================================
package N01_람다;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;

@FunctionalInterface
interface NumberOperator {
	int operate(int n1, int n2);
}
/*
 * 람다 연습2
 * 인터페이스를 구현하고, 람다 표현식을 작성해서
 * 배열에 저장되어 있는 값 중 최대값과 최소값을 출력
 */
@FunctionalInterface
interface Ex2 {
	void printInfo(int[] nums);
}

public class S04_Sample04 {

	public static void main(String[] args) {
		NumberOperator add = (n1, n2) -> n1+n2;
		NumberOperator sub = (n1, n2) -> n1-n2;
		NumberOperator mul = (n1, n2) -> n1*n2;
		System.out.println("===============람다 연습1===============");
		System.out.println("두 개의 정수를 받아서 합계 구하는 거	: " + add.operate(10, 20));
		System.out.println("두 개의 정수를 받아서 빼기 구하는 거	: " + sub.operate(10, 20));
		System.out.println("두 개의 정수를 받아서 곱하기 구하는 거	: " + mul.operate(10, 20));
		
		System.out.println("===============람다 연습2===============");
		int[] arr = { 5, 10, 3, 7, 6, 11 };
		Ex2 ex2 = (nums) -> {
//			try {
//				int max = nums[0];
//				int min = nums[0];
//			for(int num:nums) {
//				if(num<min)
//					min = num;
//				if(num>max)
//					max = num;
//			}
//			System.out.println("최대값 : " + max + ", 최소값 : " + min);
//			} catch(Exception e) {
//				System.out.println("배열 길이 : 0");
//			}
			TreeSet<Integer> t = new TreeSet<>();
			for(int n:arr)
				t.add(n);
			System.out.println("최대값 : " + t.last() + ", 최소값 : " + t.first());
		};
		ex2.printInfo(arr);
	}
}
// ====================================================================================================
/*
 * 스트림 568p
 * 약간 iterator 같은 거라고 생각하시면 된다심
 * 여러개의 타입들의 데이터를 다룰 때 각각의 방식으로 기억을 하는 불편을 해소
 * 여러 타입들의 데이터를 단일화 시켜서 공통적인 메서드로 사용을 할 수 있도록 하는 거.
 */
package N02_스트림;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class S01_Sample01 {

	public static void main(String[] args) {
		String[] strArr = { "3aaa", "5bb", "1c" };
		List<String> strList = Arrays.asList(strArr);
//		System.out.println(strList);
		
		Stream<String> s1 = Arrays.stream(strArr); // 배열만 Arrays를 사용
		Stream<String> s2 = strList.stream(); // 배열 빼고는 모두 .stream()
		
//		System.out.print("배열 데이터를 사용한 결과	: "); // 1ccc3aaa5bbb
//		s1.sorted().forEach(System.out::print); // 오호. (str)->System.out.print(str) 이랑 같은 거! 메서드 호출!
//		System.out.println();
//		System.out.print("컬렉션 데이터를 사용한 결과	: "); // 1ccc3aaa5bbb
//		s2.sorted().forEach(System.out::print); // 배열 데이터를 사용한 방식과 동일한 방식으로 컬렉션 데이터를 사용할 수 있다는 거!
//		System.out.println();
		// 중간에 처리를 하는 sorted()는 중간연산이라하고, forEach() 출력이나 반환 같은 거 하는 걸 최종연산이라 한다심. 종류는 조금 이따가 볼거라심
		/*
		 * 스트림의 특징
		 * 1. 스트림은 데이터 소스를 변경하지 않는다. 기존 데이터가 변경되지 않아서 새로 담아야 하는데, 또 그건 귀찮으니까 반환시켜주는 최종연산이 또 있나봄
		 * 2. 스트림은 일회용이다. // 다시 쓰려면 s2 = strList.stream(); 같은 거 무조건 해야 s2.연산 가능
		 * 3. 스트림은 작업을 내부 반복으로 처리한다. // 향상된 for문도 같은 개념인 건가? 
		 *    이터레이터, 컬렉션은 외부반복. hasNext() next() 했던거 우리가 컨트롤 했던 거.
		 * 4. 지연된 연산, 최종 연산이 수행되기 전까지 중간 연산이 수행되지 않음, 정확하게 필요한 것만 작업을 해서 불필요한 것을 하지 않는 것이 특징
		 * 5. Stream<Integer> vs IntStream 제네릭 생략 가능한 IntStream에는 int에 특화된 메서드들이 추가로 있다심...
		 * 6. 병렬 스트림 : 작업을 분산처리 할 수 있다보니깐 작업의 성능이 향상될 가능성이 있음. 병렬 처리가 복잡도에 따라 성능이 향상되기도 하지만 떨어질 수도 있어서 병렬처리가 무조건 장점이 되지는 않는다심
		 */
		
//		Stream<Integer>
		IntStream is = new Random().ints(); 	// Int로 설정할 수 있는 모든 범위중에서 랜덤 픽
		is = new Random().ints(1, 11); 			// 1부터 10!까지 랜덤하게 하려면 매개변수를 넣어주면 됨
		is = new Random().ints(1, 11).limit(4); // 개수를 제한하는 중간 연산 limit!
//		is.forEach(System.out::println);
		
		is = IntStream.range(1, 5); 			// 1에서 5전까지
//		is.forEach(System.out::println);		// 1, 2, 3, 4
		is = IntStream.rangeClosed(1, 5); 		// 1에서 5 포함까지
//		is.forEach(System.out::println);		// 1, 2, 3, 4, 5
		// python range(n)은 없나봄... 애쉽...
		
		is = IntStream.iterate(0, n->n+2); 		// iterate(초기값, 람다식), 근데 마찬가지로 이러면 안 끝남!
		is = IntStream.iterate(0, n->n+2).limit(5);
//		is.forEach(System.out::print); 			// 02468
		
		is = IntStream.generate(()->5).limit(5); // generate(매개변수 없는 람다식), return 값으로 꽉 채운 데이터 반환됨...
//		is.forEach(System.out::print);			 // 55555
//		System.out.println();
		
		// 파일과 빈 스트림은 파일 입출력할 때 한다심~
		/*
		 * 스티림의 연산
		 * 중간 연산
		 * distinct() : 중복 제거
		 * ....으로 연결되어 있다고 해서 메서드 체이닝~라고 하기도 함. 뭐 용어가 중요한 건 아님~하고 넘어가심!
		 * filter( Predicate <T> p ) : 조건에 만족하는 것만 리턴
		 * map ( R Function <T> f ) : 데이터를 반환해서 새로운 스트림으로 생성, 보통 자료형 변환할 때 사용, 스핀오프로 mapToDouble 등등 있음
		 * sorted : 정렬 (기준은 Comparator로 이따가 할 거라심) Comparator.naturalOrder() 등...
		 * flatMap : 평면화된 스트림을 생성
		 * limit(long n) : 아까 했어... 스트림의 일부를 잘라낸다. 앞에서부터 n개
		 * skip(long n) : n개 건너뜀
		 * peek : 주어진 기능만 작동하고, 스트림은 건드리지 않음. 아무런 기능을 하지는 않지만...엄청 많이 중간연산을 하는 중간쯤에서 중간 처리 결과를 확인하기 위해서 사용 
		 * 중간연산은 순서가 결과에 영향을 미침. 처음부터 처리 시작함.
		 */
		List<Integer> iList = Arrays.asList(1, 2, 3, 4, 5);
		Stream<Integer> iS = iList.stream().filter(n -> n%2==0);
//		iS.forEach(System.out::print); // 24
		iS = strList.stream().map(String::length); // strList = [3aaa, 5bb, 1c];
//		iS.forEach(System.out::print); // 432
		
		// 연관된 거는 한 줄로 쓰긴 하지만. 잘 보이려면 한줄씩 쓰고 주석처리 하면 가독성이 높아진다심
		IntStream lotto = new Random().ints(1,46) 	// 난수 1~45까지 스트림 생성 
										.distinct() // 중복 제거
										.limit(5)	// 5개로 제한
										.sorted();  // 정렬
//		lotto.forEach(System.out::println);
		
		// flatMap 예제~ ㄷㄷ
		List<List<Integer>> numbers = Arrays.asList(
												Arrays.asList(1, 2),
												Arrays.asList(3, 4, 5, 6),
												Arrays.asList(7, 8, 9)
										);
		List<Integer> flatNumbers = numbers.stream().flatMap(List::stream).collect(Collectors.toList());
		System.out.println(flatNumbers);// [1, 2, 3, 4, 5, 6, 7, 8, 9]
		iS = flatNumbers.stream().skip(5);
		iS.forEach(System.out::print);	// 6789
		
	}
}
// ====================================================================================================
package N02_스트림;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class S02_Sample02 {

	public static void main(String[] args) {
		/*
		 * 최종연산
		 * void forEach ( Consumer )
		 * boolean anyMatch 조건에 만족하는 게 있냐 없냐
		 * Optional max, min ( Comparator ) eg. Integer::compareTo
		 * Optional reduce ( BinaryOperator or 메서드 참조 )
		 */
		List<String> list = Arrays.asList("3aaa", "5bb", "1c");
//		list.stream().forEach(System.out::print); // 3aaa5bb1c
		String str = list.stream()
						.collect(Collectors.joining(", "));
//		System.out.println(str); // 3aaa, 5bb, 1c
//		System.out.println(list.stream().count()); // 개수 반환, Long cnt, 3
//		System.out.println(list.stream().filter(s->s.length()>=4).count());
		
		// anyMatch
		List<Integer> intList = Arrays.asList(1, 50, 3, 10, 6);
//		System.out.println(intList.stream().anyMatch(n -> n%2 == 0)); 	// true
//		System.out.println(intList.stream().allMatch(n -> n%2 == 0)); 	// false
//		System.out.println(intList.stream().noneMatch(n -> n%2 == 0)); 	// false
		
//		System.out.println(intList.stream().max(Integer::compareTo));	// Optional[50]
//		Optional<Integer> max = intList.stream().max(Integer::compareTo); // return 타입이 Optional, 제네릭도 있음 헷.
		/*
		 * Optional이라는 걸 왜 쓰는지!
		 * 내가 찾으려고 하는 값이 없었을 경우를 대비한 거!!!
		 * 기본데이터 타입은 NULL을 가질 수 없음 NULLPointerException 바로 발생시킴
		 * 데이터가 비었을 경우 Optional.empty로 명시해줌~ 굳
		 * .get() 으로 내용물 꺼냄
		 * OrElse??? 같은 게 있다시는데 이따가 할 듯 뭔지 모르겠당 헤헷
		 */
//		System.out.println(max.get());
//		System.out.println(intList.stream().min(Integer::compareTo).get());
		
		// reduce, 스트림 데이터를 순차적으로 메소드에 따라 계산해서 값을 Optional로 리턴시켜줌
//		System.out.println(intList.stream().reduce(Integer::sum).get());
	}
}
// ====================================================================================================
package N02_스트림;

import java.util.Comparator;
import java.util.stream.Stream;

class Student implements Comparable<Student>{
	String name;
	int ban;
	int totalScore;
	public Student(String name, int ban, int totalScore) {
		this.name = name;
		this.ban = ban;
		this.totalScore = totalScore;
	}
	
	public String getName() {  // 클래스명::변수 이렇게 할 수 없으니 게터 메서드를 만들어 놓는 거...
		return name;
	}

	public int getBan() {
		return ban;
	}

	public int getTotalScore() {
		return totalScore;
	}

	@Override
	public String toString() {
		return String.format("[%s, %d, %d]", name, ban, totalScore);
	}

	@Override
	public int compareTo(Student o) {
		return o.totalScore - this.totalScore; // 기본 정렬을 내림차순으로!
	}
	/*
	 * 양수
	 * 0
	 * 음수 라는데...??? 들어온 애가 더 크면 위로 올라가니까 내림차순 되는 건 맞음 ㄷㄷ
	 */
}
public class S03_Sample03 {

	public static void main(String[] args) {
		Stream<Student> stuStream = Stream.of(
										new Student("aaa", 3, 300),
										new Student("bbb", 1, 200),
										new Student("ccc", 2, 100),
										new Student("ddd", 2, 150),
										new Student("eee", 1, 250),
										new Student("qqq", 3, 280),
										new Student("www", 1, 210),
										new Student("rrr", 2, 150)
									);
		System.out.println("반별 정렬 후 점수를 기본 정렬 시킨 결과 출력");
		stuStream.sorted(Comparator.comparing(Student::getBan)
									.thenComparing(Comparator.naturalOrder()))
									.forEach(System.out::println);
	}

}
// ====================================================================================================
589p 예제
split(" +") 이거 정규표현식, 정규표현식은 자바스크립트할 때(회원가입 구현) 얘기할 거라심 ㄷㄷ
스페이스가 여러개 있을 때 같은거..
.get()
.isPresent() boolean 있냐 없냐!
// ====================================================================================================
package N02_스트림;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class S04_Sample04 {

	public static void main(String[] args) {
		List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
//		System.out.println(list.stream().findFirst()); // 스트림에 첫번째꺼 반환, Optional[1]
		Optional<Integer> number = list.stream().filter(n->n>10).findFirst();
		
//		if(number.isPresent())
//			System.out.println(number.get());
//		else
//			System.out.println("없음");
		
//		System.out.println(number.orElse(-1)); // -1, 없으니까!!!
		
		/*
		 * IntStream 처럼
		 * Optional 제네릭 안 쓰고 하는 건 
		 * OptionalInt, OptionalLong, OptionalDouble 같은 게 있음
		 */
		
		/*
		 * 집계 메서드
		 * sum : 합계 구해주는 메서드
		 */
		int sum = list.stream().mapToInt(Integer::intValue).sum();
//		System.out.println(sum); // 15
		
		OptionalDouble avg = list.stream().mapToDouble(Integer::doubleValue).average();
		// mapToDouble(Integer::doubleValue) ㄷㄷ List 제네릭이 Integer
//		System.out.println(avg.orElse(0.0)); // 3.0
		
		
		// 605p 그룹화
		List<String> names = Arrays.asList("Aaaa", "Bbb", "Aaa", "Bcc", "Ccc", "Cdd");
		Map<Character, List<String>> group = names.stream().collect(Collectors.groupingBy(str->str.charAt(0)));
//		System.out.println(group); // {A=[Aaaa, Aaa], B=[Bbb, Bcc], C=[Ccc, Cdd]}
		
		int[] data = {5, 6, 4, 2, 3, 1, 1, 2, 2, 4, 8};
		Integer[] data1 = {5, 6, 4, 2, 3, 1, 1, 2, 2, 4, 8};
		List<Integer> list1 = new ArrayList<>(Arrays.asList(data1));
		// 짝수만 중복제거해서 내림차순 정렬한 결과를 result 배열에 저장후 출력
		Stream<Integer> s = list1.stream().filter(n->n%2==0).distinct().sorted(Comparator.reverseOrder());
		System.out.println("걍 출력");
		s.forEach(System.out::println);
		List<Integer> list2 = list1.stream()
									.filter(n->n%2==0)
									.distinct()
									.sorted(Comparator.reverseOrder())
									.collect(Collectors.toList());
		System.out.println("list에 저장한 결과 : " + list2);
		Integer[] newData = list1.stream()
									.filter(n->n%2==0)
									.distinct()
									.sorted(Comparator.reverseOrder())
									.toArray(Integer[]::new);
		System.out.println("Integer[]에 저장한 결과 : " + Arrays.toString(newData));
		int[] result = Arrays.stream(data)	// 배열을 스트림 IntStream
							.boxed()		// Stream<Integer> 가 됨.
							.filter(n->n%2==0)
							.distinct()
							.sorted(Comparator.reverseOrder())
							.mapToInt(Integer::intValue) // Stream<Integer> → IntStream으로 변환
							.toArray();		// int[] 배열로 리턴
		System.out.println("int[]에 저장한 결과 : " + Arrays.toString(result));
		
		TreeSet<Integer> ts = new TreeSet<>(); // sort 쓰려면 list 써야 하는데... 귀찮
		for(int i:data) {
			if(i%2==0)
				ts.add(i);
		}
		int[] data2 = new int[ts.size()];
		for(int i=0; i<data2.length; i++) {
			data2[i] = ts.last();
			ts.remove(ts.last());
		}
		System.out.println("스트림 안 하고 구현 결과 : " + Arrays.toString(data2));
	}

}
// ====================================================================================================
Day0706
// ====================================================================================================
/*
 * 입출력스트림 624p
 * 입출력 스트림 : 가운데 통로!, 기존에 배웠던 스트림이랑은 다름
 * 입력 : 키보드, 마우스, 파일...
 *  ↕ 입력스트림
 * 자바
 *  ↕ 출력스트림
 * 출력 : 모니터, 파일, 프로그램
 * 
 * 입출력을 동시에 담당하는 스트림은 없음. 입력 따로, 출력 따로
 * 어떤 걸 기반으로 전송을 할 건지에 따라, 스트림의 종류가 다양함
 * 입출력의 성능 향상을 거들어주는 보조스트림이라는 것도 있음
 * 게시판 작업 같은 걸 하거나 업로드, 다운로드, 로그파일을 만들어서 내보낸다던가 할 때 종종 이용할 예정
 * 
 * 바이트 기반 스트림
 * 바이트 기반은 한 바이트씩 쪼개서 전송 // cf 문자기반 스트림은 문자 한글자씩 쪼개서 전송
 * 1,0,1,0으로 구성된 그림, 동영상, 사운드 파일들을 전송할 때 사용
 * IO스트림은 FIFO 먼저 들어온 순으로 먼저 나옴
 * 최상위 클래스는 InputStream, OutputStream (추상클래스)
 * read(), write() 메서드들은 오버로딩 되어 있음
 * 추가적으로 기억하면 좋은 거는 void close(), void flush() 메서드
 * 모든 스트림에 다 있진 않지만(??? 아니 나중에 모든 입출력에 다 있다고 말씀하심) 대부분의 입출력 스트림에 있다심
 * close() : 스트림 닫기
 * flush() : 입력을 하든 출력을 하든 통로를 거쳐 전송되어, 특별하게 건들지 않으면 알아서 내보내지는데, 
 * 			 특정 바이트까지 채워질 때까지 기다렸다가 모였을 때 전송해달라... 성능향상 목적으로 작업을 진행하는데
 * 			 스트림에 남은 찌꺼기를 내보내는거 그냥 close를 하면 마지막 나머지는 전송되지 못한채 스트림이 닫힘
 * 			 그럴 때 내보내기 위해서 사용하는 게 flush()
 * 
 * 보조스트림
 * 보조스트림은 입출력스트림이 있어야 함. 추가적인 부품을 껴주는 거. 성능향상을 기대... 
 * 버퍼 ㅡ_ㅡ
 * 
 * 문자기반 스트림
 * 바이트기반스트림은 한글 같은 거 다 깨짐 왜냐면 한글은 2바이트이기 때문에...
 * 그래서 문자기반스트림을 사용
 * 문자스트림도 Reader랑 Writer 있음!
 * 매개변수가 조금 다른 거 뿐임
 * 
 * 거의 사용하는게 read, write, flush, close 정도라심
 * 630p 예제
 * 실제로 배열 스트림은 잘 안 쓰긴 하는데, 흐름상 나온 거 같다심... ㅡㅡ
 * 나중엔 파일로, 메모장 같은 걸로 바뀔 거라심
 */
package N01_입출력스트림;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class S01_Sample01 {

	public static void main(String[] args) throws IOException {
		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9}; // 자료형에서 보관할 수 있는 가장 짧은 정수형, 0~255 범위임!
		byte[] outSrc = null;
		
		ByteArrayInputStream input = new ByteArrayInputStream(inSrc);
		ByteArrayOutputStream output = new ByteArrayOutputStream();

//		int data = 0; // 읽어온 데이터를 잠깐동안 저장해서 사용할 임시변수, 읽어왔을 때 read에서 -1을 내보낼 때가 있기 때문에 byte로 못함..
//		while((data = input.read()) != -1)
//			output.write(data);
//		outSrc = output.toByteArray();
//		System.out.println(Arrays.toString(outSrc));
		
		// write가 오버로딩 되어 있어서 배열로 바로 넣을 수도 있다심, 631p
//		byte[] temp = new byte[inSrc.length]; // 파일 같은 경우는 모를 때가 많아서 넉넉하게 해놓을 수 있다심...
//		input.read(temp, 0, temp.length); // 어지간해선 걍 위에 한 것처럼 반복문처리 한다심
//		output.write(temp, 0, temp.length); // 가운데 숫자는 offset 시작 idx
//		outSrc = output.toByteArray();
//		System.out.println(Arrays.toString(outSrc));
		
		// temp 사이즈가 변경됨!
//		byte[] temp = new byte[4];
//		while(input.available()>0) {
//			input.read(temp); // 예외처리를 강요함! throws IOException 추가됨
//			output.write(temp);
//			outSrc = output.toByteArray();
//			System.out.println("temp : " + Arrays.toString(temp));
//			System.out.println("outSrc : " + Arrays.toString(outSrc));
//		} // 마지막 출력결과 outSrc : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6, 7] 끝에 이상, 수정 필요!!!
		
		byte[] temp = new byte[4];
		while(input.available()>0) {
			int len = input.read(temp); // 읽어온 만큼
			output.write(temp, 0, len); // 넣을 때 줄여줌!
			outSrc = output.toByteArray();
			System.out.println("temp : " + Arrays.toString(temp));
			System.out.println("outSrc : " + Arrays.toString(outSrc));
		} // 마지막 출력결과 temp : [8, 9, 6, 7], outSrc : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	}
}
// ====================================================================================================
package N01_입출력스트림;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class S02_Sample02 {

	public static void main(String[] args) throws IOException { // throws FileNotFoundException : FileInputStream에서 강요
		FileInputStream fis = new FileInputStream("src/N01_입출력스트림/S02_Sample02.java"); // 앞글자만 따서 보통 fis, 매개변수는 파일 경로
		FileOutputStream fos = new FileOutputStream("./N01_입출력스트림_S02_Sample02.txt"); // 파일경로 작성... 윈도우에서는 /, 원래는 \라심 ./ : 현재 작업 중인 폴더, ../ : 이전 폴더
		int data = 0;
		while((data=fis.read()) != -1) {
			System.out.print((char)data); // 바이트는 숫자니까 형변환 필요, 한글깨짐은 별 수 없음, 처리하려면 문자기반으로 해야 함...
			fos.write(data);
		}
		fos.close();
		fis.close();		// 파일은 열린 순 역순으로 닫음
		// 이런 거 하면 로그 같은 거 내보내기 할 수도 있고~~ 
		// 데몬쓰레드도 배웠으니 ??? 할 수도 있고 ㅋㅋㅋ
	}
}
// ====================================================================================================
/*
 * 보조스트림 사용하면 성능 향상이 되는데
 * 그냥 txt 파일로는 속도 차이를 체감하기 어려우니
 * 이미지 파일을 다운받아서 작업해봄
 * 
 * 보조스트림 안쓴 작업 소요 시간 : 837
 * 보조스트림 안쓴 사용 소요 시간 : 11
 */
package N01_입출력스트림;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class S03_Sample03 {

	public static void main(String[] args) throws Exception {
		FileInputStream fis = null;
		FileOutputStream fos = null;
		BufferedInputStream bis = null;
		BufferedOutputStream bos = null;
		int data;
		long start;
		long end;
		
		// 보조스트림 사용 안함
		fis = new FileInputStream("src/N01_입출력스트림/sky.jpg");
		fos = new FileOutputStream("N01_입출력스트림_S03_Sample03_Copy_sky1.jpg");
		start = System.currentTimeMillis();
		while((data=fis.read()) != -1) {
			fos.write(data);
		}
		fos.flush();
		end = System.currentTimeMillis();
		fos.close();
		fis.close();
		System.out.println("보조스트림 안쓴 작업 소요 시간 : " + (end-start));
		
		// 보조스트림 사용
		fis = new FileInputStream("src/N01_입출력스트림/sky.jpg");
		bis = new BufferedInputStream(fis);
		fos = new FileOutputStream("N01_입출력스트림_S03_Sample03_Copy_sky2.jpg");
		bos = new BufferedOutputStream(fos);
		start = System.currentTimeMillis();
		while ((data = bis.read()) != -1) { // 보조스트림으로 작업!
			bos.write(data);				// 보조스트림으로 작업!
		}
		bos.flush();						// 보조스트림으로 작업!
		end = System.currentTimeMillis();
		bos.close(); // close는 보조스트림부터!
		bis.close();
		fos.close();
		fis.close();
		System.out.println("보조스트림 안쓴 사용 소요 시간 : " + (end-start));
	}
}
// ====================================================================================================
/*
 * flush() 사용
 */
package N01_입출력스트림;

import java.io.BufferedOutputStream;
import java.io.FileOutputStream;

public class S04_Sample04 {

	public static void main(String[] args) throws Exception {
		FileOutputStream fos = new FileOutputStream("N01_입출력스트림_S04_Sample04.txt");
		BufferedOutputStream bos = new BufferedOutputStream(fos, 5); // 작업단위 5로 지정
		for(int i='1'; i<='9'; i++)
			bos.write(i);
		fos.close();
		// 결과 12345 저장됨...
		
		FileOutputStream fos1 = new FileOutputStream("N01_입출력스트림_S04_Sample04_1.txt");
		BufferedOutputStream bos1 = new BufferedOutputStream(fos1, 5); // 작업단위 5로 지정
		for(int i='1'; i<='9'; i++)
			bos1.write(i);
		bos1.flush(); // 보조스트림에 남아 있는 거 모조리!
		bos1.close();
		fos1.close();
		// 결과 123456789 저장됨!!!
		
		FileOutputStream fos2 = new FileOutputStream("N01_입출력스트림_S04_Sample04_2.txt");
		BufferedOutputStream bos2 = new BufferedOutputStream(fos2); // 작업단위 지정 안 함
		for(int i='1'; i<='9'; i++)
			bos2.write(i);
		bos2.flush(); // 보조스트림에 남아 있는 거 모조리!
		bos2.close();
		fos2.close();
		// 결과 123456789 저장됨!!!
	}
}
// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================

// ====================================================================================================













































